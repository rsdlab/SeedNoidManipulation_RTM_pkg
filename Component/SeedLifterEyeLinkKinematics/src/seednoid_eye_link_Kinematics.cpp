/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2018-05-30 18:42:02.647220
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70,x71,x72,x73,x74,x75;
x0=IKcos(j[2]);
x1=IKcos(j[5]);
x2=IKcos(j[4]);
x3=IKsin(j[2]);
x4=IKcos(j[3]);
x5=IKsin(j[5]);
x6=IKsin(j[4]);
x7=IKsin(j[3]);
x8=IKcos(j[7]);
x9=IKsin(j[1]);
x10=IKsin(j[7]);
x11=IKsin(j[6]);
x12=IKcos(j[1]);
x13=IKcos(j[6]);
x14=IKcos(j[0]);
x15=IKsin(j[0]);
x16=((1.0)*x9);
x17=((1.0)*x11);
x18=((0.078)*x9);
x19=((1.0)*x10);
x20=((0.078)*x12);
x21=((1.0)*x1);
x22=((0.1)*x7);
x23=((1.0)*x13);
x24=((0.1)*x6);
x25=((1.0)*x6);
x26=((1.0)*x12);
x27=((1.0)*x8);
x28=((0.461)*x0);
x29=((1.0)*x2);
x30=((1.0)*x5);
x31=((0.1)*x12);
x32=((-1.0)*x6);
x33=(x0*x6);
x34=(x3*x7);
x35=(x4*x9);
x36=(x0*x2);
x37=(x0*x4);
x38=(x2*x3);
x39=(x3*x4);
x40=(x3*x6);
x41=((0.078)*x40);
x42=(x0*x25*x7);
x43=(x16*x36);
x44=((0.078)*x36*x7);
x45=(x26*x34);
x46=(((x3*x35))+(((-1.0)*x26*x7)));
x47=((((-1.0)*x42))+x38);
x48=(x40+((x36*x7)));
x49=((((0.1)*x37*x5))+(((0.461)*x3)));
x50=((((-0.1)*x38))+((x22*x33)));
x51=((((-1.0)*x16*x4))+x45);
x52=((((-1.0)*x16*x34))+(((-1.0)*x26*x4)));
x53=(x46*x5);
x54=(x1*x46);
x55=((((-1.0)*x16*x7))+(((-1.0)*x26*x39)));
x56=(x44+x41);
x57=(x52*x6);
x58=(x1*x55);
x59=((((-1.0)*x16*x33))+((x2*((((x34*x9))+((x12*x4)))))));
x60=(((x37*x5))+((x1*x47)));
x61=(((x5*(((((-1.0)*x29*x3))+x42))))+((x1*x37)));
x62=((((-1.0)*x43))+x57);
x63=((((-1.0)*x30*x37))+(((-1.0)*x21*x47)));
x64=(((x29*(((((-1.0)*x35))+x45))))+(((-1.0)*x0*x12*x25)));
x65=((((-1.0)*x26*x36))+(((-1.0)*x25*x51)));
x66=(x1*x62);
x67=(((x1*((((x51*x6))+((x12*x36))))))+((x5*x55)));
x68=(x54+((x5*((((x32*x52))+x43)))));
x69=(((x13*x60))+((x11*x61)));
x70=((((-1.0)*x23*x60))+(((-1.0)*x17*x61)));
x71=(x70*x8);
x72=((((-1.0)*x18*x33))+((x5*((((x12*x22))+(((-0.1)*x3*x35))))))+((x2*((((x18*x34))+((x20*x4))))))+((x1*(((((0.1)*x36*x9))+(((-1.0)*x24*x52))))))+((x28*x9)));
x73=(((x13*x68))+((x11*(((((-1.0)*x30*x46))+(((-1.0)*x21*x62)))))));
x74=(((x10*((((x13*((x53+x66))))+((x11*x68))))))+((x59*x8)));
x75=((((-1.0)*x8*(((((1.0)*x23*((((x1*(((((-1.0)*x36*x9))+x57))))+x53))))+(((1.0)*x17*((((x5*((x43+(((-1.0)*x25*x52))))))+x54))))))))+((x10*x59)));
eerot[0]=(((x14*x74))+((x15*(((((-1.0)*x27*x48))+(((-1.0)*x19*x69)))))));
eerot[1]=(((x14*x73))+((x15*(((((-1.0)*x23*x61))+(((-1.0)*x17*x63)))))));
eerot[2]=(((x14*x75))+((x15*(((((-1.0)*x27*x70))+(((-1.0)*x19*x48)))))));
eetrans[0]=(((x14*x72))+((x15*((x49+(((-1.0)*x21*x50))+(((-1.0)*x56)))))));
eerot[3]=(((x14*((((x10*x69))+((x48*x8))))))+((x15*x74)));
eerot[4]=(((x14*((((x13*x61))+((x11*x63))))))+((x15*x73)));
eerot[5]=(((x14*((((x10*x48))+x71))))+((x15*x75)));
eetrans[1]=(((x14*(((((-1.0)*x49))+x56+((x1*x50))))))+((x15*x72)));
eerot[6]=((((-1.0)*x10*(((((1.0)*x23*x67))+(((1.0)*x17*((((x5*(((((-1.0)*x12*x36))+((x32*x51))))))+x58))))))))+((x64*x8)));
eerot[7]=(((x11*x67))+((x13*(((((-1.0)*x30*x65))+(((-1.0)*x21*x55)))))));
eerot[8]=(((x10*x64))+((x8*((((x13*x67))+((x11*((((x5*x65))+x58)))))))));
eetrans[2]=((0.1455)+((x1*((((x24*x51))+((x31*x36))))))+(((-1.0)*x20*x33))+((x2*((((x20*x34))+(((-1.0)*x18*x4))))))+((x5*(((((-1.0)*x31*x39))+(((-1.0)*x22*x9))))))+((x12*x28)));
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {0, 7}; return freeparams; }
IKFAST_API int GetNumJoints() { return 8; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j0,cj0,sj0,htj0,j7,cj7,sj7,htj7,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij0[2], _nj0,_ij7[2], _nj7;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij0[0] = -1; _ij0[1] = -1; _nj0 = 0;  _ij7[0] = -1; _ij7[1] = -1; _nj7 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j0=pfree[0]; cj0=cos(pfree[0]); sj0=sin(pfree[0]), htj0=tan(pfree[0]*0.5);
j7=pfree[1]; cj7=cos(pfree[1]); sj7=sin(pfree[1]), htj7=tan(pfree[1]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=(((r00*(IKcos(j0))))+((r10*(IKsin(j0)))));
new_r01=((((-1.0)*r12*(IKsin(j0))))+(((-1.0)*r02*(IKcos(j0)))));
new_r02=(((r01*(IKcos(j0))))+((r11*(IKsin(j0)))));
new_px=(((py*(IKsin(j0))))+((px*(IKcos(j0)))));
new_r10=((-1.0)*r20);
new_r11=r22;
new_r12=((-1.0)*r21);
new_py=((0.1455)+(((-1.0)*pz)));
new_r20=((((-1.0)*r00*(IKsin(j0))))+((r10*(IKcos(j0)))));
new_r21=((((-1.0)*r12*(IKcos(j0))))+((r02*(IKsin(j0)))));
new_r22=((((-1.0)*r01*(IKsin(j0))))+((r11*(IKcos(j0)))));
new_pz=((((-1.0)*px*(IKsin(j0))))+((py*(IKcos(j0)))));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x76=((1.0)*px);
IkReal x77=((1.0)*pz);
IkReal x78=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x78))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x77)));
rxp0_2=((((-1.0)*r10*x76))+((py*r00)));
rxp1_0=((((-1.0)*r21*x78))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x77)));
rxp1_2=(((py*r01))+(((-1.0)*r11*x76)));
rxp2_0=((((-1.0)*r22*x78))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x77)));
rxp2_2=(((py*r02))+(((-1.0)*r12*x76)));
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
sj4array[0]=((0.169197396963124)+(((2.16919739696312)*npy*sj7))+(((-2.16919739696312)*cj7*npx)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j6eval[2];
IkReal x79=(cj7*npy);
IkReal x80=(npx*sj7);
j6eval[0]=((((0.2)*(IKabs(npz))))+(IKabs(((((0.2)*x79))+(((0.2)*x80))))));
j6eval[1]=((x79*x79)+(x80*x80)+(((2.0)*x79*x80))+(npz*npz));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
j5eval[0]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x81=cj7*cj7;
IkReal x82=npx*npx;
IkReal x83=npy*npy;
IkReal x84=npz*npz;
IkReal x85=(cj7*npy);
IkReal x86=(npx*sj7);
IkReal x87=((10.0)*x82);
IkReal x88=(x81*x83);
j6eval[0]=((((2.0)*x85*x86))+(((-1.0)*x81*x82))+x88+x82+x84);
j6eval[1]=((IKabs(npz))+(IKabs(((((-1.0)*x86))+(((-1.0)*x85))))));
j6eval[2]=IKsign(((((-1.0)*x81*x87))+(((10.0)*x84))+(((10.0)*x88))+(((20.0)*x85*x86))+x87));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j5, j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x89=cj7*cj7;
IkReal x90=npx*npx;
IkReal x91=(cj7*npy);
IkReal x92=(npx*sj7);
IkReal x93=((10.0)*x90);
CheckValue<IkReal> x94=IKPowWithIntegerCheck(IKsign(((((10.0)*x89*(npy*npy)))+x93+(((20.0)*x91*x92))+(((10.0)*(npz*npz)))+(((-1.0)*x89*x93)))),-1);
if(!x94.valid){
continue;
}
CheckValue<IkReal> x95 = IKatan2WithCheck(IkReal(npz),IkReal(((((-1.0)*x92))+(((-1.0)*x91)))),IKFAST_ATAN2_MAGTHRESH);
if(!x95.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x94.value)))+(x95.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x96=IKcos(j6);
IkReal x97=IKsin(j6);
IkReal x98=(npx*sj7);
IkReal x99=(cj7*npy);
IkReal x100=((1.0)*x96);
IkReal x101=(npz*x97);
IkReal x102=((0.2)*x96);
IkReal x103=((1.0)*x97);
evalcond[0]=((-0.1)+x101+(((-1.0)*x100*x98))+(((-1.0)*x100*x99)));
evalcond[1]=((((-1.0)*x103*x98))+(((-1.0)*x103*x99))+(((-1.0)*npz*x100)));
evalcond[2]=((0.02)+((x102*x98))+((x102*x99))+(((-0.2)*x101)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x104=(npx*sj7);
IkReal x105=(cj7*npy);
IkReal x106=((1.0)*cj6);
j5eval[0]=((IKabs((((cj6*npz))+((sj6*x105))+((sj6*x104)))))+(IKabs(((-0.1)+(((-1.0)*x104*x106))+((npz*sj6))+(((-1.0)*x105*x106))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x107=((1.0)*cj6);
IkReal x108=((1.0)*sj6);
IkReal x109=(npx*sj7);
IkReal x110=(cj7*npy);
j5eval[0]=((IKabs(((((-1.0)*npz*x107))+(((-1.0)*x108*x110))+(((-1.0)*x108*x109)))))+(IKabs(((-0.1)+(((-1.0)*x107*x110))+((npz*sj6))+(((-1.0)*x107*x109))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x111=((1.0)*cj6);
IkReal x112=((1.0)*sj6);
IkReal x113=(npx*sj7);
IkReal x114=(cj7*npy);
CheckValue<IkReal> x116 = IKatan2WithCheck(IkReal(((((-1.0)*x112*x113))+(((-1.0)*x112*x114))+(((-1.0)*npz*x111)))),IkReal(((-0.1)+(((-1.0)*x111*x113))+(((-1.0)*x111*x114))+((npz*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x116.valid){
continue;
}
IkReal x115=x116.value;
j5array[0]=((-1.0)*x115);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x115)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x117=IKsin(j5);
IkReal x118=IKcos(j5);
IkReal x119=(cj7*npy);
IkReal x120=(npx*sj7);
IkReal x121=(sj6*x117);
IkReal x122=((1.0)*cj6*x118);
evalcond[0]=((((-1.0)*x119*x122))+(((-1.0)*x120*x122))+((x120*x121))+(((-0.1)*x118))+((cj6*npz*x117))+((x119*x121))+((npz*sj6*x118)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x908=(npx*sj7);
IkReal x909=(cj7*npy);
IkReal x910=((1.0)*cj6);
CheckValue<IkReal> x912 = IKatan2WithCheck(IkReal(((-0.1)+(((-1.0)*x908*x910))+((npz*sj6))+(((-1.0)*x909*x910)))),IkReal((((cj6*npz))+((sj6*x908))+((sj6*x909)))),IKFAST_ATAN2_MAGTHRESH);
if(!x912.valid){
continue;
}
IkReal x911=x912.value;
j5array[0]=((-1.0)*x911);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x911)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x913=IKsin(j5);
IkReal x914=IKcos(j5);
IkReal x915=((1.0)*cj7*npy);
IkReal x916=(sj6*x914);
IkReal x917=(cj6*x913);
IkReal x918=((1.0)*npx*sj7);
evalcond[0]=((((-1.0)*cj6*npz*x914))+(((-0.1)*x913))+((npz*sj6*x913))+(((-1.0)*x916*x918))+(((-1.0)*x915*x916))+(((-1.0)*x915*x917))+(((-1.0)*x917*x918)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x919=cj7*cj7;
IkReal x920=npx*npx;
IkReal x921=npy*npy;
IkReal x922=npz*npz;
IkReal x923=(cj7*npy);
IkReal x924=(npx*sj7);
IkReal x925=((10.0)*x920);
IkReal x926=(x919*x921);
j6eval[0]=((((-1.0)*x919*x920))+(((2.0)*x923*x924))+x926+x922+x920);
j6eval[1]=((IKabs(((((-1.0)*x923))+(((-1.0)*x924)))))+(IKabs(npz)));
j6eval[2]=IKsign(((((20.0)*x923*x924))+(((-1.0)*x919*x925))+x925+(((10.0)*x922))+(((10.0)*x926))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j5, j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x927=cj7*cj7;
IkReal x928=npx*npx;
IkReal x929=(cj7*npy);
IkReal x930=(npx*sj7);
IkReal x931=((10.0)*x928);
CheckValue<IkReal> x932 = IKatan2WithCheck(IkReal(npz),IkReal(((((-1.0)*x929))+(((-1.0)*x930)))),IKFAST_ATAN2_MAGTHRESH);
if(!x932.valid){
continue;
}
CheckValue<IkReal> x933=IKPowWithIntegerCheck(IKsign(((((10.0)*x927*(npy*npy)))+(((20.0)*x929*x930))+(((-1.0)*x927*x931))+(((10.0)*(npz*npz)))+x931)),-1);
if(!x933.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x932.value)+(((1.5707963267949)*(x933.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x934=IKcos(j6);
IkReal x935=IKsin(j6);
IkReal x936=(npx*sj7);
IkReal x937=(cj7*npy);
IkReal x938=((1.0)*x934);
IkReal x939=(npz*x935);
IkReal x940=((0.2)*x934);
IkReal x941=((1.0)*x935);
evalcond[0]=((-0.1)+(((-1.0)*x936*x938))+(((-1.0)*x937*x938))+x939);
evalcond[1]=((((-1.0)*x936*x941))+(((-1.0)*x937*x941))+(((-1.0)*npz*x938)));
evalcond[2]=((0.02)+((x936*x940))+(((-0.2)*x939))+((x937*x940)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x942=(npx*sj7);
IkReal x943=(cj7*npy);
IkReal x944=((1.0)*cj6);
j5eval[0]=((IKabs(((-0.1)+((npz*sj6))+(((-1.0)*x942*x944))+(((-1.0)*x943*x944)))))+(IKabs((((sj6*x943))+((sj6*x942))+((cj6*npz))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x945=((1.0)*cj6);
IkReal x946=((1.0)*sj6);
IkReal x947=(npx*sj7);
IkReal x948=(cj7*npy);
j5eval[0]=((IKabs(((-0.1)+(((-1.0)*x945*x947))+(((-1.0)*x945*x948))+((npz*sj6)))))+(IKabs(((((-1.0)*x946*x948))+(((-1.0)*x946*x947))+(((-1.0)*npz*x945))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x949=((1.0)*cj6);
IkReal x950=((1.0)*sj6);
IkReal x951=(npx*sj7);
IkReal x952=(cj7*npy);
CheckValue<IkReal> x954 = IKatan2WithCheck(IkReal(((((-1.0)*npz*x949))+(((-1.0)*x950*x951))+(((-1.0)*x950*x952)))),IkReal(((-0.1)+((npz*sj6))+(((-1.0)*x949*x951))+(((-1.0)*x949*x952)))),IKFAST_ATAN2_MAGTHRESH);
if(!x954.valid){
continue;
}
IkReal x953=x954.value;
j5array[0]=((-1.0)*x953);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x953)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x955=IKsin(j5);
IkReal x956=IKcos(j5);
IkReal x957=(cj7*npy);
IkReal x958=(npx*sj7);
IkReal x959=(sj6*x955);
IkReal x960=((1.0)*cj6*x956);
evalcond[0]=((((-0.1)*x956))+(((-1.0)*x958*x960))+(((-1.0)*x957*x960))+((x957*x959))+((x958*x959))+((cj6*npz*x955))+((npz*sj6*x956)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x961=(npx*sj7);
IkReal x962=(cj7*npy);
IkReal x963=((1.0)*cj6);
CheckValue<IkReal> x965 = IKatan2WithCheck(IkReal(((-0.1)+(((-1.0)*x962*x963))+(((-1.0)*x961*x963))+((npz*sj6)))),IkReal((((cj6*npz))+((sj6*x961))+((sj6*x962)))),IKFAST_ATAN2_MAGTHRESH);
if(!x965.valid){
continue;
}
IkReal x964=x965.value;
j5array[0]=((-1.0)*x964);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x964)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x966=IKsin(j5);
IkReal x967=IKcos(j5);
IkReal x968=((1.0)*cj7*npy);
IkReal x969=(sj6*x967);
IkReal x970=(cj6*x966);
IkReal x971=((1.0)*npx*sj7);
evalcond[0]=((((-1.0)*x969*x971))+(((-0.1)*x966))+(((-1.0)*x970*x971))+(((-1.0)*x968*x969))+((npz*sj6*x966))+(((-1.0)*x968*x970))+(((-1.0)*cj6*npz*x967)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x972=IKPowWithIntegerCheck(cj4,-1);
if(!x972.valid){
continue;
}
cj5array[0]=((10.8459869848156)*(x972.value)*(((-0.228605)+(((0.071916)*sj4))+pp)));
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j6eval[3];
IkReal x973=npx*npx;
IkReal x974=cj7*cj7;
IkReal x975=npz*npz;
IkReal x976=npy*npy;
IkReal x977=(npx*sj7);
IkReal x978=((461.0)*cj4);
IkReal x979=(cj7*npy);
IkReal x980=((1000.0)*x973);
IkReal x981=(x974*x976);
j6eval[0]=((((-2.0)*x977*x979))+(((-1.0)*x981))+(((-1.0)*x975))+(((-1.0)*x973))+((x973*x974)));
j6eval[1]=IKsign(((((-1.0)*x980))+(((-1000.0)*x975))+(((-1000.0)*x981))+((x974*x980))+(((-2000.0)*x977*x979))));
j6eval[2]=((IKabs(((((-1.0)*npz*sj5*x978))+(((100.0)*x979))+(((100.0)*x977))+((cj5*x978*x979))+((cj5*x977*x978)))))+(IKabs(((((-1.0)*sj5*x978*x979))+(((-100.0)*npz))+(((-1.0)*cj5*npz*x978))+(((-1.0)*sj5*x977*x978))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x982=cj7*cj7;
IkReal x983=npx*npx;
IkReal x984=npz*npz;
IkReal x985=npy*npy;
IkReal x986=cj5*cj5;
IkReal x987=(npx*sj7);
IkReal x988=(cj5*npz);
IkReal x989=(cj5*x983);
IkReal x990=((10.0)*x982);
IkReal x991=(cj5*cj7*npy);
IkReal x992=(cj5*x984);
IkReal x993=((461.0)*cj4*sj5);
IkReal x994=(cj5*x985);
IkReal x995=((461.0)*cj4*x986);
j6eval[0]=((((-1.0)*x982*x989))+x992+x989+(((2.0)*x987*x991))+((x982*x994)));
j6eval[1]=IKsign((((x990*x994))+(((10.0)*x992))+(((10.0)*x989))+(((20.0)*x987*x991))+(((-1.0)*x989*x990))));
j6eval[2]=((IKabs((((x988*x993))+(((-100.0)*cj5*x987))+(((-1.0)*cj7*npy*x995))+(((-100.0)*x991))+(((-1.0)*x987*x995)))))+(IKabs((((x991*x993))+((npz*x995))+(((100.0)*x988))+((cj5*x987*x993))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x996=cj7*cj7;
IkReal x997=npx*npx;
IkReal x998=npy*npy;
IkReal x999=npz*npz;
IkReal x1000=((1000.0)*sj5);
IkReal x1001=(sj5*x996);
IkReal x1002=(cj7*npx*npy*sj5*sj7);
j6eval[0]=((((-1.0)*x1001*x997))+((x1001*x998))+((sj5*x997))+((sj5*x999))+(((2.0)*x1002)));
j6eval[1]=IKsign(((((2000.0)*x1002))+((x1000*x999))+((x1000*x997))+((x1000*x996*x998))+(((-1.0)*x1000*x996*x997))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1003=npx*npx;
IkReal x1004=cj7*cj7;
IkReal x1005=(npx*sj7);
IkReal x1006=((0.461)*cj4);
IkReal x1007=(cj7*npy);
IkReal x1008=((((-1.0)*x1003))+(((-1.0)*(npz*npz)))+(((-2.0)*x1005*x1007))+(((-1.0)*x1004*(npy*npy)))+((x1003*x1004)));
j6eval[0]=x1008;
j6eval[1]=IKsign(x1008);
j6eval[2]=((IKabs(((((0.1)*x1007))+(((0.1)*x1005))+((x1006*x1007))+((x1005*x1006)))))+(((0.001)*(IKabs(((((-100.0)*npz))+(((-461.0)*cj4*npz))))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=0;
cj5=1.0;
j5=0;
IkReal x1009=cj7*cj7;
IkReal x1010=npx*npx;
IkReal x1011=(npx*sj7);
IkReal x1012=((0.35958)*sj4);
IkReal x1013=(cj7*npy);
IkReal x1014=((5.0)*pp);
IkReal x1015=(x1010+(((-1.0)*x1009*x1010))+(((2.0)*x1011*x1013))+(npz*npz)+((x1009*(npy*npy))));
j6eval[0]=x1015;
j6eval[1]=IKsign(x1015);
j6eval[2]=((((5.0e-6)*(IKabs(((((1000000.0)*npz*pp))+(((-208605.0)*npz))+(((71916.0)*npz*sj4)))))))+(IKabs(((((-1.0)*x1012*x1013))+(((-1.0)*x1011*x1014))+(((-1.0)*x1011*x1012))+(((1.043025)*x1013))+(((1.043025)*x1011))+(((-1.0)*x1013*x1014))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1016=cj7*cj7;
IkReal x1017=npx*npx;
IkReal x1018=(cj7*npy);
IkReal x1019=(npx*sj7);
IkReal x1020=((0.35958)*sj4);
IkReal x1021=((5.0)*pp);
CheckValue<IkReal> x1022=IKPowWithIntegerCheck(IKsign((((x1016*(npy*npy)))+x1017+(((-1.0)*x1016*x1017))+(((2.0)*x1018*x1019))+(npz*npz))),-1);
if(!x1022.valid){
continue;
}
CheckValue<IkReal> x1023 = IKatan2WithCheck(IkReal(((((-1.043025)*npz))+((npz*x1021))+((npz*x1020)))),IkReal(((((-1.0)*x1018*x1020))+(((-1.0)*x1018*x1021))+(((-1.0)*x1019*x1020))+(((-1.0)*x1019*x1021))+(((1.043025)*x1018))+(((1.043025)*x1019)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1023.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1022.value)))+(x1023.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1024=IKsin(j6);
IkReal x1025=IKcos(j6);
IkReal x1026=(npx*sj7);
IkReal x1027=(cj7*npy);
IkReal x1028=((1.0)*x1025);
IkReal x1029=(npz*x1024);
IkReal x1030=((0.2)*x1025);
IkReal x1031=((1.0)*x1024);
evalcond[0]=((((-1.0)*x1027*x1031))+(((-1.0)*x1026*x1031))+(((-1.0)*npz*x1028)));
evalcond[1]=((-0.1)+x1029+(((-1.0)*x1026*x1028))+(((-0.461)*cj4))+(((-1.0)*x1027*x1028)));
evalcond[2]=((-0.208605)+((x1026*x1030))+(((0.071916)*sj4))+(((-0.2)*x1029))+pp+((x1027*x1030)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1032=npx*npx;
IkReal x1033=cj7*cj7;
IkReal x1034=(cj7*npy);
IkReal x1035=(npx*sj7);
IkReal x1036=((0.461)*cj4);
CheckValue<IkReal> x1037=IKPowWithIntegerCheck(IKsign(((((-2.0)*x1034*x1035))+(((-1.0)*x1032))+(((-1.0)*(npz*npz)))+(((-1.0)*x1033*(npy*npy)))+((x1032*x1033)))),-1);
if(!x1037.valid){
continue;
}
CheckValue<IkReal> x1038 = IKatan2WithCheck(IkReal(((((-0.1)*npz))+(((-1.0)*npz*x1036)))),IkReal(((((0.1)*x1034))+(((0.1)*x1035))+((x1034*x1036))+((x1035*x1036)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1038.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1037.value)))+(x1038.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1039=IKsin(j6);
IkReal x1040=IKcos(j6);
IkReal x1041=(npx*sj7);
IkReal x1042=(cj7*npy);
IkReal x1043=((1.0)*x1040);
IkReal x1044=(npz*x1039);
IkReal x1045=((0.2)*x1040);
IkReal x1046=((1.0)*x1039);
evalcond[0]=((((-1.0)*npz*x1043))+(((-1.0)*x1041*x1046))+(((-1.0)*x1042*x1046)));
evalcond[1]=((-0.1)+x1044+(((-0.461)*cj4))+(((-1.0)*x1041*x1043))+(((-1.0)*x1042*x1043)));
evalcond[2]=((-0.208605)+((x1042*x1045))+(((0.071916)*sj4))+((x1041*x1045))+pp+(((-0.2)*x1044)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1047=npx*npx;
IkReal x1048=cj7*cj7;
IkReal x1049=((0.461)*cj4);
IkReal x1050=(npx*sj7);
IkReal x1051=(cj7*npy);
IkReal x1052=((((-2.0)*x1050*x1051))+(((-1.0)*(npz*npz)))+(((-1.0)*x1048*(npy*npy)))+(((-1.0)*x1047))+((x1047*x1048)));
j6eval[0]=x1052;
j6eval[1]=((((0.001)*(IKabs(((((-100.0)*npz))+(((461.0)*cj4*npz)))))))+(IKabs(((((0.1)*x1050))+(((0.1)*x1051))+(((-1.0)*x1049*x1051))+(((-1.0)*x1049*x1050))))));
j6eval[2]=IKsign(x1052);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x1053=cj7*cj7;
IkReal x1054=npx*npx;
IkReal x1055=(npx*sj7);
IkReal x1056=((0.35958)*sj4);
IkReal x1057=(cj7*npy);
IkReal x1058=((5.0)*pp);
IkReal x1059=((((2.0)*x1055*x1057))+x1054+((x1053*(npy*npy)))+(((-1.0)*x1053*x1054))+(npz*npz));
j6eval[0]=x1059;
j6eval[1]=IKsign(x1059);
j6eval[2]=((((5.0e-6)*(IKabs(((((1000000.0)*npz*pp))+(((-208605.0)*npz))+(((71916.0)*npz*sj4)))))))+(IKabs(((((-1.0)*x1055*x1058))+(((-1.0)*x1055*x1056))+(((-1.0)*x1056*x1057))+(((-1.0)*x1057*x1058))+(((1.043025)*x1055))+(((1.043025)*x1057))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1060=cj7*cj7;
IkReal x1061=npx*npx;
IkReal x1062=(cj7*npy);
IkReal x1063=(npx*sj7);
IkReal x1064=((0.35958)*sj4);
IkReal x1065=((5.0)*pp);
CheckValue<IkReal> x1066=IKPowWithIntegerCheck(IKsign((((x1060*(npy*npy)))+x1061+(((-1.0)*x1060*x1061))+(((2.0)*x1062*x1063))+(npz*npz))),-1);
if(!x1066.valid){
continue;
}
CheckValue<IkReal> x1067 = IKatan2WithCheck(IkReal(((((-1.043025)*npz))+((npz*x1065))+((npz*x1064)))),IkReal(((((-1.0)*x1063*x1065))+(((-1.0)*x1063*x1064))+(((-1.0)*x1062*x1065))+(((-1.0)*x1062*x1064))+(((1.043025)*x1063))+(((1.043025)*x1062)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1067.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1066.value)))+(x1067.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1068=IKsin(j6);
IkReal x1069=IKcos(j6);
IkReal x1070=(npx*sj7);
IkReal x1071=(cj7*npy);
IkReal x1072=((1.0)*x1069);
IkReal x1073=(npz*x1068);
IkReal x1074=((0.2)*x1069);
IkReal x1075=((1.0)*x1068);
evalcond[0]=((((-1.0)*x1070*x1075))+(((-1.0)*x1071*x1075))+(((-1.0)*npz*x1072)));
evalcond[1]=((-0.1)+x1073+(((-1.0)*x1070*x1072))+(((-1.0)*x1071*x1072))+(((0.461)*cj4)));
evalcond[2]=((-0.208605)+(((-0.2)*x1073))+((x1070*x1074))+((x1071*x1074))+(((0.071916)*sj4))+pp);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1076=npx*npx;
IkReal x1077=cj7*cj7;
IkReal x1078=((0.461)*cj4);
IkReal x1079=(npx*sj7);
IkReal x1080=(cj7*npy);
CheckValue<IkReal> x1081=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1077*(npy*npy)))+(((-1.0)*(npz*npz)))+((x1076*x1077))+(((-1.0)*x1076))+(((-2.0)*x1079*x1080)))),-1);
if(!x1081.valid){
continue;
}
CheckValue<IkReal> x1082 = IKatan2WithCheck(IkReal(((((-0.1)*npz))+((npz*x1078)))),IkReal(((((-1.0)*x1078*x1079))+(((-1.0)*x1078*x1080))+(((0.1)*x1079))+(((0.1)*x1080)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1082.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1081.value)))+(x1082.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1083=IKsin(j6);
IkReal x1084=IKcos(j6);
IkReal x1085=(npx*sj7);
IkReal x1086=(cj7*npy);
IkReal x1087=((1.0)*x1084);
IkReal x1088=(npz*x1083);
IkReal x1089=((0.2)*x1084);
IkReal x1090=((1.0)*x1083);
evalcond[0]=((((-1.0)*x1086*x1090))+(((-1.0)*x1085*x1090))+(((-1.0)*npz*x1087)));
evalcond[1]=((-0.1)+x1088+(((0.461)*cj4))+(((-1.0)*x1085*x1087))+(((-1.0)*x1086*x1087)));
evalcond[2]=((-0.208605)+(((0.071916)*sj4))+pp+(((-0.2)*x1088))+((x1086*x1089))+((x1085*x1089)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
IkReal x1091=cj7*cj7;
IkReal x1092=npx*npx;
IkReal x1093=npz*npz;
IkReal x1094=npy*npy;
IkReal x1095=(npx*sj7);
IkReal x1096=(cj7*npy);
IkReal x1097=((461.0)*cj4);
IkReal x1098=((1000.0)*x1092);
IkReal x1099=(x1091*x1094);
j6eval[0]=((((2.0)*x1095*x1096))+x1092+x1093+x1099+(((-1.0)*x1091*x1092)));
j6eval[1]=IKsign(((((2000.0)*x1095*x1096))+x1098+(((-1.0)*x1091*x1098))+(((1000.0)*x1093))+(((1000.0)*x1099))));
j6eval[2]=((IKabs(((((100.0)*npz))+((x1095*x1097))+((x1096*x1097)))))+(IKabs((((npz*x1097))+(((-100.0)*x1095))+(((-100.0)*x1096))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=1.0;
cj5=0;
j5=1.5707963267949;
IkReal x1100=npx*npx;
IkReal x1101=cj7*cj7;
j6eval[0]=((((-2.0)*cj7*npx*npy*sj7))+(((-1.0)*(npz*npz)))+(((-1.0)*x1100))+(((-1.0)*x1101*(npy*npy)))+((x1100*x1101)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1102=cj7*cj7;
IkReal x1103=npx*npx;
IkReal x1104=npz*npz;
IkReal x1105=npy*npy;
IkReal x1106=(npx*sj7);
IkReal x1107=((92.2)*cj4);
IkReal x1108=((5000.0)*pp);
IkReal x1109=((359.58)*sj4);
IkReal x1110=(cj7*npy);
IkReal x1111=((1000.0)*x1103);
IkReal x1112=((200.0)*x1102);
CheckValue<IkReal> x1113=IKPowWithIntegerCheck(((((-200.0)*x1104))+(((-200.0)*x1103))+(((-400.0)*x1106*x1110))+((x1103*x1112))+(((-1.0)*x1105*x1112))),-1);
if(!x1113.valid){
continue;
}
CheckValue<IkReal> x1114=IKPowWithIntegerCheck((x1111+(((1000.0)*x1104))+(((2000.0)*x1106*x1110))+(((1000.0)*x1102*x1105))+(((-1.0)*x1102*x1111))),-1);
if(!x1114.valid){
continue;
}
if( IKabs(((x1113.value)*(((((-71.916)*npz*sj4))+(((-1.0)*x1107*x1110))+(((208.605)*npz))+(((-1.0)*x1106*x1107))+(((-1000.0)*npz*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1114.value)*(((((-1.0)*x1109*x1110))+(((1043.025)*x1106))+(((1043.025)*x1110))+(((-1.0)*x1108*x1110))+(((-1.0)*x1106*x1108))+(((-1.0)*x1106*x1109))+(((461.0)*cj4*npz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1113.value)*(((((-71.916)*npz*sj4))+(((-1.0)*x1107*x1110))+(((208.605)*npz))+(((-1.0)*x1106*x1107))+(((-1000.0)*npz*pp))))))+IKsqr(((x1114.value)*(((((-1.0)*x1109*x1110))+(((1043.025)*x1106))+(((1043.025)*x1110))+(((-1.0)*x1108*x1110))+(((-1.0)*x1106*x1108))+(((-1.0)*x1106*x1109))+(((461.0)*cj4*npz))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((x1113.value)*(((((-71.916)*npz*sj4))+(((-1.0)*x1107*x1110))+(((208.605)*npz))+(((-1.0)*x1106*x1107))+(((-1000.0)*npz*pp))))), ((x1114.value)*(((((-1.0)*x1109*x1110))+(((1043.025)*x1106))+(((1043.025)*x1110))+(((-1.0)*x1108*x1110))+(((-1.0)*x1106*x1108))+(((-1.0)*x1106*x1109))+(((461.0)*cj4*npz))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1115=IKcos(j6);
IkReal x1116=IKsin(j6);
IkReal x1117=(npx*sj7);
IkReal x1118=(cj7*npy);
IkReal x1119=((1.0)*x1115);
IkReal x1120=(npz*x1116);
IkReal x1121=((0.2)*x1115);
IkReal x1122=((1.0)*x1116);
evalcond[0]=((-0.1)+x1120+(((-1.0)*x1118*x1119))+(((-1.0)*x1117*x1119)));
evalcond[1]=((((-1.0)*x1117*x1122))+(((-1.0)*npz*x1119))+(((0.461)*cj4))+(((-1.0)*x1118*x1122)));
evalcond[2]=((-0.208605)+(((0.071916)*sj4))+pp+((x1117*x1121))+(((-0.2)*x1120))+((x1118*x1121)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1123=cj7*cj7;
IkReal x1124=npx*npx;
IkReal x1125=(npx*sj7);
IkReal x1126=(cj7*npy);
IkReal x1127=((461.0)*cj4);
IkReal x1128=((1000.0)*x1124);
CheckValue<IkReal> x1129=IKPowWithIntegerCheck(IKsign((x1128+(((2000.0)*x1125*x1126))+(((1000.0)*x1123*(npy*npy)))+(((1000.0)*(npz*npz)))+(((-1.0)*x1123*x1128)))),-1);
if(!x1129.valid){
continue;
}
CheckValue<IkReal> x1130 = IKatan2WithCheck(IkReal(((((100.0)*npz))+((x1125*x1127))+((x1126*x1127)))),IkReal(((((-100.0)*x1125))+(((-100.0)*x1126))+((npz*x1127)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1130.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1129.value)))+(x1130.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1131=IKcos(j6);
IkReal x1132=IKsin(j6);
IkReal x1133=(npx*sj7);
IkReal x1134=(cj7*npy);
IkReal x1135=((1.0)*x1131);
IkReal x1136=(npz*x1132);
IkReal x1137=((0.2)*x1131);
IkReal x1138=((1.0)*x1132);
evalcond[0]=((-0.1)+x1136+(((-1.0)*x1134*x1135))+(((-1.0)*x1133*x1135)));
evalcond[1]=((((-1.0)*npz*x1135))+(((-1.0)*x1134*x1138))+(((0.461)*cj4))+(((-1.0)*x1133*x1138)));
evalcond[2]=((-0.208605)+(((0.071916)*sj4))+((x1134*x1137))+pp+(((-0.2)*x1136))+((x1133*x1137)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
IkReal x1139=cj7*cj7;
IkReal x1140=npx*npx;
IkReal x1141=npz*npz;
IkReal x1142=npy*npy;
IkReal x1143=(npx*sj7);
IkReal x1144=(cj7*npy);
IkReal x1145=((461.0)*cj4);
IkReal x1146=((1000.0)*x1140);
IkReal x1147=(x1139*x1142);
j6eval[0]=(x1140+x1141+x1147+(((2.0)*x1143*x1144))+(((-1.0)*x1139*x1140)));
j6eval[1]=IKsign((x1146+(((1000.0)*x1147))+(((1000.0)*x1141))+(((2000.0)*x1143*x1144))+(((-1.0)*x1139*x1146))));
j6eval[2]=((IKabs(((((-1.0)*npz*x1145))+(((-100.0)*x1143))+(((-100.0)*x1144)))))+(IKabs(((((100.0)*npz))+(((-1.0)*x1143*x1145))+(((-1.0)*x1144*x1145))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj5=-1.0;
cj5=0;
j5=-1.5707963267949;
IkReal x1148=npx*npx;
IkReal x1149=cj7*cj7;
j6eval[0]=((((-2.0)*cj7*npx*npy*sj7))+(((-1.0)*(npz*npz)))+(((-1.0)*x1148))+(((-1.0)*x1149*(npy*npy)))+((x1148*x1149)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1150=cj7*cj7;
IkReal x1151=npx*npx;
IkReal x1152=npz*npz;
IkReal x1153=npy*npy;
IkReal x1154=(npx*sj7);
IkReal x1155=((92.2)*cj4);
IkReal x1156=((5000.0)*pp);
IkReal x1157=((359.58)*sj4);
IkReal x1158=(cj7*npy);
IkReal x1159=((1000.0)*x1151);
IkReal x1160=((200.0)*x1150);
CheckValue<IkReal> x1161=IKPowWithIntegerCheck(((((-1.0)*x1153*x1160))+(((-400.0)*x1154*x1158))+((x1151*x1160))+(((-200.0)*x1151))+(((-200.0)*x1152))),-1);
if(!x1161.valid){
continue;
}
CheckValue<IkReal> x1162=IKPowWithIntegerCheck(((((-1000.0)*x1152))+(((-1.0)*x1159))+(((-1000.0)*x1150*x1153))+((x1150*x1159))+(((-2000.0)*x1154*x1158))),-1);
if(!x1162.valid){
continue;
}
if( IKabs(((x1161.value)*(((((-71.916)*npz*sj4))+(((208.605)*npz))+((x1154*x1155))+((x1155*x1158))+(((-1000.0)*npz*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1162.value)*(((((-1043.025)*x1158))+(((-1043.025)*x1154))+((x1156*x1158))+((x1154*x1156))+((x1154*x1157))+(((461.0)*cj4*npz))+((x1157*x1158)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1161.value)*(((((-71.916)*npz*sj4))+(((208.605)*npz))+((x1154*x1155))+((x1155*x1158))+(((-1000.0)*npz*pp))))))+IKsqr(((x1162.value)*(((((-1043.025)*x1158))+(((-1043.025)*x1154))+((x1156*x1158))+((x1154*x1156))+((x1154*x1157))+(((461.0)*cj4*npz))+((x1157*x1158))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((x1161.value)*(((((-71.916)*npz*sj4))+(((208.605)*npz))+((x1154*x1155))+((x1155*x1158))+(((-1000.0)*npz*pp))))), ((x1162.value)*(((((-1043.025)*x1158))+(((-1043.025)*x1154))+((x1156*x1158))+((x1154*x1156))+((x1154*x1157))+(((461.0)*cj4*npz))+((x1157*x1158))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1163=IKcos(j6);
IkReal x1164=IKsin(j6);
IkReal x1165=(npx*sj7);
IkReal x1166=(cj7*npy);
IkReal x1167=((1.0)*x1163);
IkReal x1168=(npz*x1164);
IkReal x1169=((0.2)*x1163);
IkReal x1170=((1.0)*x1164);
evalcond[0]=((-0.1)+(((-1.0)*x1166*x1167))+x1168+(((-1.0)*x1165*x1167)));
evalcond[1]=((((-1.0)*x1165*x1170))+(((-1.0)*npz*x1167))+(((-0.461)*cj4))+(((-1.0)*x1166*x1170)));
evalcond[2]=((-0.208605)+(((-0.2)*x1168))+((x1165*x1169))+((x1166*x1169))+(((0.071916)*sj4))+pp);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1171=cj7*cj7;
IkReal x1172=npx*npx;
IkReal x1173=(npx*sj7);
IkReal x1174=(cj7*npy);
IkReal x1175=((461.0)*cj4);
IkReal x1176=((1000.0)*x1172);
CheckValue<IkReal> x1177 = IKatan2WithCheck(IkReal(((((100.0)*npz))+(((-1.0)*x1173*x1175))+(((-1.0)*x1174*x1175)))),IkReal(((((-1.0)*npz*x1175))+(((-100.0)*x1173))+(((-100.0)*x1174)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1177.valid){
continue;
}
CheckValue<IkReal> x1178=IKPowWithIntegerCheck(IKsign((x1176+(((1000.0)*x1171*(npy*npy)))+(((1000.0)*(npz*npz)))+(((-1.0)*x1171*x1176))+(((2000.0)*x1173*x1174)))),-1);
if(!x1178.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1177.value)+(((1.5707963267949)*(x1178.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[3];
IkReal x1179=IKcos(j6);
IkReal x1180=IKsin(j6);
IkReal x1181=(npx*sj7);
IkReal x1182=(cj7*npy);
IkReal x1183=((1.0)*x1179);
IkReal x1184=(npz*x1180);
IkReal x1185=((0.2)*x1179);
IkReal x1186=((1.0)*x1180);
evalcond[0]=((-0.1)+(((-1.0)*x1181*x1183))+x1184+(((-1.0)*x1182*x1183)));
evalcond[1]=((((-1.0)*x1181*x1186))+(((-1.0)*npz*x1183))+(((-0.461)*cj4))+(((-1.0)*x1182*x1186)));
evalcond[2]=((-0.208605)+((x1182*x1185))+(((0.071916)*sj4))+pp+((x1181*x1185))+(((-0.2)*x1184)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1187=cj5*cj5;
IkReal x1188=cj7*cj7;
IkReal x1189=npx*npx;
IkReal x1190=((1000.0)*sj5);
IkReal x1191=(npx*sj7);
IkReal x1192=((100.0)*sj5);
IkReal x1193=((461.0)*cj4);
IkReal x1194=(cj7*npy);
IkReal x1195=(cj5*sj5);
IkReal x1196=(sj5*x1194);
CheckValue<IkReal> x1197=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1188*x1189*x1190))+((x1189*x1190))+((x1188*x1190*(npy*npy)))+(((2000.0)*x1191*x1196))+((x1190*(npz*npz))))),-1);
if(!x1197.valid){
continue;
}
CheckValue<IkReal> x1198 = IKatan2WithCheck(IkReal((((npz*x1193*x1195))+(((-1.0)*x1187*x1193*x1194))+(((-1.0)*x1187*x1191*x1193))+((npz*x1192))+((x1193*x1194))+((x1191*x1193)))),IkReal(((((-1.0)*x1191*x1192))+(((-1.0)*npz*x1187*x1193))+(((-1.0)*x1193*x1194*x1195))+((npz*x1193))+(((-1.0)*x1191*x1193*x1195))+(((-1.0)*x1192*x1194)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1198.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1197.value)))+(x1198.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1199=IKcos(j6);
IkReal x1200=IKsin(j6);
IkReal x1201=(cj7*npy);
IkReal x1202=((0.461)*cj4);
IkReal x1203=((1.0)*cj5);
IkReal x1204=(npz*x1200);
IkReal x1205=((1.0)*x1201);
IkReal x1206=(npz*x1199);
IkReal x1207=(npx*sj7*x1199);
IkReal x1208=(npx*sj7*x1200);
evalcond[0]=((-0.1)+(((-1.0)*x1199*x1205))+x1204+(((-1.0)*x1207))+(((-1.0)*cj5*x1202)));
evalcond[1]=((((-1.0)*x1200*x1205))+(((-1.0)*x1208))+(((-1.0)*x1206))+((sj5*x1202)));
evalcond[2]=((-0.208605)+(((0.071916)*sj4))+(((-0.2)*x1204))+pp+(((0.2)*x1199*x1201))+(((0.2)*x1207)));
evalcond[3]=((((-1.0)*x1200*x1201*x1203))+(((-1.0)*x1203*x1206))+(((-1.0)*x1203*x1208))+(((-0.1)*sj5))+((sj5*x1204))+(((-1.0)*sj5*x1199*x1205))+(((-1.0)*sj5*x1207)));
evalcond[4]=(((cj5*x1204))+(((-1.0)*x1199*x1201*x1203))+(((-0.1)*cj5))+(((-1.0)*x1203*x1207))+((sj5*x1208))+((sj5*x1206))+(((-1.0)*x1202))+((sj5*x1200*x1201)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1209=cj5*cj5;
IkReal x1210=cj7*cj7;
IkReal x1211=npx*npx;
IkReal x1212=((10.0)*cj5);
IkReal x1213=(npx*sj7);
IkReal x1214=(cj5*npz);
IkReal x1215=(cj5*cj7*npy);
IkReal x1216=((4.61)*cj4*sj5);
IkReal x1217=((4.61)*cj4*x1209);
CheckValue<IkReal> x1218 = IKatan2WithCheck(IkReal((x1214+((npz*x1217))+((cj5*x1213*x1216))+((x1215*x1216)))),IkReal((((x1214*x1216))+(((-1.0)*cj5*x1213))+(((-1.0)*x1213*x1217))+(((-1.0)*cj7*npy*x1217))+(((-1.0)*x1215)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1218.valid){
continue;
}
CheckValue<IkReal> x1219=IKPowWithIntegerCheck(IKsign(((((20.0)*x1213*x1215))+((x1212*(npz*npz)))+((x1211*x1212))+(((-1.0)*x1210*x1211*x1212))+((x1210*x1212*(npy*npy))))),-1);
if(!x1219.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1218.value)+(((1.5707963267949)*(x1219.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1220=IKcos(j6);
IkReal x1221=IKsin(j6);
IkReal x1222=(cj7*npy);
IkReal x1223=((0.461)*cj4);
IkReal x1224=((1.0)*cj5);
IkReal x1225=(npz*x1221);
IkReal x1226=((1.0)*x1222);
IkReal x1227=(npz*x1220);
IkReal x1228=(npx*sj7*x1220);
IkReal x1229=(npx*sj7*x1221);
evalcond[0]=((-0.1)+x1225+(((-1.0)*x1228))+(((-1.0)*x1220*x1226))+(((-1.0)*cj5*x1223)));
evalcond[1]=((((-1.0)*x1227))+(((-1.0)*x1229))+((sj5*x1223))+(((-1.0)*x1221*x1226)));
evalcond[2]=((-0.208605)+(((0.2)*x1220*x1222))+(((0.071916)*sj4))+(((0.2)*x1228))+pp+(((-0.2)*x1225)));
evalcond[3]=((((-1.0)*x1224*x1229))+(((-1.0)*x1224*x1227))+((sj5*x1225))+(((-1.0)*sj5*x1228))+(((-0.1)*sj5))+(((-1.0)*x1221*x1222*x1224))+(((-1.0)*sj5*x1220*x1226)));
evalcond[4]=((((-1.0)*x1224*x1228))+(((-1.0)*x1223))+((sj5*x1229))+((sj5*x1227))+((sj5*x1221*x1222))+((cj5*x1225))+(((-0.1)*cj5))+(((-1.0)*x1220*x1222*x1224)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x1230=npx*npx;
IkReal x1231=cj7*cj7;
IkReal x1232=(npx*sj7);
IkReal x1233=(cj7*npy);
IkReal x1234=((461.0)*cj4*sj5);
IkReal x1235=((1000.0)*x1230);
IkReal x1236=((461.0)*cj4*cj5);
CheckValue<IkReal> x1237 = IKatan2WithCheck(IkReal(((((-100.0)*npz))+(((-1.0)*x1233*x1234))+(((-1.0)*npz*x1236))+(((-1.0)*x1232*x1234)))),IkReal((((x1233*x1236))+(((100.0)*x1233))+(((100.0)*x1232))+((x1232*x1236))+(((-1.0)*npz*x1234)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1237.valid){
continue;
}
CheckValue<IkReal> x1238=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1235))+((x1231*x1235))+(((-2000.0)*x1232*x1233))+(((-1000.0)*x1231*(npy*npy)))+(((-1000.0)*(npz*npz))))),-1);
if(!x1238.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x1237.value)+(((1.5707963267949)*(x1238.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x1239=IKcos(j6);
IkReal x1240=IKsin(j6);
IkReal x1241=(cj7*npy);
IkReal x1242=((0.461)*cj4);
IkReal x1243=((1.0)*cj5);
IkReal x1244=(npz*x1240);
IkReal x1245=((1.0)*x1241);
IkReal x1246=(npz*x1239);
IkReal x1247=(npx*sj7*x1239);
IkReal x1248=(npx*sj7*x1240);
evalcond[0]=((-0.1)+(((-1.0)*x1239*x1245))+x1244+(((-1.0)*x1247))+(((-1.0)*cj5*x1242)));
evalcond[1]=((((-1.0)*x1248))+(((-1.0)*x1246))+((sj5*x1242))+(((-1.0)*x1240*x1245)));
evalcond[2]=((-0.208605)+(((-0.2)*x1244))+(((0.2)*x1247))+(((0.071916)*sj4))+pp+(((0.2)*x1239*x1241)));
evalcond[3]=((((-1.0)*x1240*x1241*x1243))+(((-1.0)*x1243*x1248))+(((-1.0)*x1243*x1246))+((sj5*x1244))+(((-1.0)*sj5*x1239*x1245))+(((-0.1)*sj5))+(((-1.0)*sj5*x1247)));
evalcond[4]=(((cj5*x1244))+((sj5*x1240*x1241))+(((-1.0)*x1243*x1247))+(((-1.0)*x1242))+((sj5*x1246))+((sj5*x1248))+(((-1.0)*x1239*x1241*x1243))+(((-0.1)*cj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x1249=((((0.2)*npx*sj7))+(((0.2)*cj7*npy)));
CheckValue<IkReal> x1252 = IKatan2WithCheck(IkReal(x1249),IkReal(((-0.2)*npz)),IKFAST_ATAN2_MAGTHRESH);
if(!x1252.valid){
continue;
}
IkReal x1250=((1.0)*(x1252.value));
if((((x1249*x1249)+(((0.04)*(npz*npz))))) < -0.00001)
continue;
CheckValue<IkReal> x1253=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1249*x1249)+(((0.04)*(npz*npz)))))),-1);
if(!x1253.valid){
continue;
}
if( (((x1253.value)*(((-0.208605)+(((0.071916)*sj4))+pp)))) < -1-IKFAST_SINCOS_THRESH || (((x1253.value)*(((-0.208605)+(((0.071916)*sj4))+pp)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1251=IKasin(((x1253.value)*(((-0.208605)+(((0.071916)*sj4))+pp))));
j6array[0]=((((-1.0)*x1250))+(((-1.0)*x1251)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+(((-1.0)*x1250))+x1251);
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

{
IkReal j5eval[3];
IkReal x1254=((1000.0)*sj6);
j5eval[0]=cj4;
j5eval[1]=((IKabs(((((1000.0)*cj6*npz))+((npx*sj7*x1254))+((cj7*npy*x1254)))))+(IKabs(((-1143.025)+(((359.58)*sj4))+(((5000.0)*pp))))));
j5eval[2]=IKsign(cj4);
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x1255=((1000.0)*sj6);
IkReal x1256=(cj7*npy);
IkReal x1257=(npx*sj7);
IkReal x1258=((1000.0)*cj6);
j5eval[0]=cj4;
j5eval[1]=IKsign(cj4);
j5eval[2]=((IKabs(((-100.0)+((npz*x1255))+(((-1.0)*x1256*x1258))+(((-1.0)*x1257*x1258)))))+(IKabs((((npz*x1258))+((x1255*x1257))+((x1255*x1256))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x1259=((10.0)*cj4);
j5eval[0]=((((-1.0)*cj6*npx*sj7*x1259))+((npz*sj6*x1259))+(((-1.0)*cj6*cj7*npy*x1259))+(((-1.0)*cj4)));
j5eval[1]=cj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x1260=(npx*sj7);
IkReal x1261=(cj7*npy);
IkReal x1262=((1.0)*cj6);
j5eval[0]=((IKabs(((-0.1)+(((-1.0)*x1261*x1262))+(((-1.0)*x1260*x1262))+((npz*sj6)))))+(IKabs((((cj6*npz))+((sj6*x1261))+((sj6*x1260))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x1263=((1.0)*cj6);
IkReal x1264=((1.0)*sj6);
IkReal x1265=(npx*sj7);
IkReal x1266=(cj7*npy);
j5eval[0]=((IKabs(((((-1.0)*x1264*x1265))+(((-1.0)*x1264*x1266))+(((-1.0)*npz*x1263)))))+(IKabs(((-0.1)+((npz*sj6))+(((-1.0)*x1263*x1266))+(((-1.0)*x1263*x1265))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1267=((1.0)*cj6);
IkReal x1268=((1.0)*sj6);
IkReal x1269=(npx*sj7);
IkReal x1270=(cj7*npy);
CheckValue<IkReal> x1272 = IKatan2WithCheck(IkReal(((((-1.0)*x1268*x1270))+(((-1.0)*x1268*x1269))+(((-1.0)*npz*x1267)))),IkReal(((-0.1)+(((-1.0)*x1267*x1270))+((npz*sj6))+(((-1.0)*x1267*x1269)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1272.valid){
continue;
}
IkReal x1271=x1272.value;
j5array[0]=((-1.0)*x1271);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1271)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1273=IKsin(j5);
IkReal x1274=IKcos(j5);
IkReal x1275=(cj7*npy);
IkReal x1276=(npx*sj7);
IkReal x1277=(sj6*x1273);
IkReal x1278=((1.0)*cj6*x1274);
evalcond[0]=(((x1276*x1277))+((cj6*npz*x1273))+((x1275*x1277))+(((-1.0)*x1275*x1278))+(((-1.0)*x1276*x1278))+(((-0.1)*x1274))+((npz*sj6*x1274)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1279=(npx*sj7);
IkReal x1280=(cj7*npy);
IkReal x1281=((1.0)*cj6);
CheckValue<IkReal> x1283 = IKatan2WithCheck(IkReal(((-0.1)+((npz*sj6))+(((-1.0)*x1279*x1281))+(((-1.0)*x1280*x1281)))),IkReal((((cj6*npz))+((sj6*x1279))+((sj6*x1280)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1283.valid){
continue;
}
IkReal x1282=x1283.value;
j5array[0]=((-1.0)*x1282);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1282)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1284=IKsin(j5);
IkReal x1285=IKcos(j5);
IkReal x1286=((1.0)*cj7*npy);
IkReal x1287=(sj6*x1285);
IkReal x1288=(cj6*x1284);
IkReal x1289=((1.0)*npx*sj7);
evalcond[0]=((((-0.1)*x1284))+(((-1.0)*x1288*x1289))+(((-1.0)*x1287*x1289))+(((-1.0)*x1286*x1287))+(((-1.0)*x1286*x1288))+((npz*sj6*x1284))+(((-1.0)*cj6*npz*x1285)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x1290=(npx*sj7);
IkReal x1291=(cj7*npy);
IkReal x1292=((1.0)*cj6);
j5eval[0]=((IKabs(((-0.1)+((npz*sj6))+(((-1.0)*x1290*x1292))+(((-1.0)*x1291*x1292)))))+(IKabs((((cj6*npz))+((sj6*x1291))+((sj6*x1290))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x1293=((1.0)*cj6);
IkReal x1294=((1.0)*sj6);
IkReal x1295=(npx*sj7);
IkReal x1296=(cj7*npy);
j5eval[0]=((IKabs(((((-1.0)*npz*x1293))+(((-1.0)*x1294*x1295))+(((-1.0)*x1294*x1296)))))+(IKabs(((-0.1)+((npz*sj6))+(((-1.0)*x1293*x1296))+(((-1.0)*x1293*x1295))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1297=((1.0)*cj6);
IkReal x1298=((1.0)*sj6);
IkReal x1299=(npx*sj7);
IkReal x1300=(cj7*npy);
CheckValue<IkReal> x1302 = IKatan2WithCheck(IkReal(((((-1.0)*npz*x1297))+(((-1.0)*x1298*x1299))+(((-1.0)*x1298*x1300)))),IkReal(((-0.1)+((npz*sj6))+(((-1.0)*x1297*x1300))+(((-1.0)*x1297*x1299)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1302.valid){
continue;
}
IkReal x1301=x1302.value;
j5array[0]=((-1.0)*x1301);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1301)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1303=IKsin(j5);
IkReal x1304=IKcos(j5);
IkReal x1305=(cj7*npy);
IkReal x1306=(npx*sj7);
IkReal x1307=(sj6*x1303);
IkReal x1308=((1.0)*cj6*x1304);
evalcond[0]=(((x1306*x1307))+(((-1.0)*x1306*x1308))+((x1305*x1307))+(((-0.1)*x1304))+(((-1.0)*x1305*x1308))+((cj6*npz*x1303))+((npz*sj6*x1304)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1309=(npx*sj7);
IkReal x1310=(cj7*npy);
IkReal x1311=((1.0)*cj6);
CheckValue<IkReal> x1313 = IKatan2WithCheck(IkReal(((-0.1)+((npz*sj6))+(((-1.0)*x1310*x1311))+(((-1.0)*x1309*x1311)))),IkReal((((cj6*npz))+((sj6*x1310))+((sj6*x1309)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1313.valid){
continue;
}
IkReal x1312=x1313.value;
j5array[0]=((-1.0)*x1312);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1312)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1314=IKsin(j5);
IkReal x1315=IKcos(j5);
IkReal x1316=((1.0)*cj7*npy);
IkReal x1317=(sj6*x1315);
IkReal x1318=(cj6*x1314);
IkReal x1319=((1.0)*npx*sj7);
evalcond[0]=((((-1.0)*x1318*x1319))+(((-1.0)*x1317*x1319))+(((-1.0)*cj6*npz*x1315))+(((-0.1)*x1314))+((npz*sj6*x1314))+(((-1.0)*x1316*x1317))+(((-1.0)*x1316*x1318)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1320=((5000.0)*pp);
IkReal x1321=((461.0)*cj4);
IkReal x1322=(npx*sj7);
IkReal x1323=(cj6*npz);
IkReal x1324=((1143.025)*sj6);
IkReal x1325=(cj7*npy);
IkReal x1326=((359.58)*sj4);
CheckValue<IkReal> x1327=IKPowWithIntegerCheck(((((-1.0)*cj6*x1321*x1322))+(((-1.0)*cj6*x1321*x1325))+((npz*sj6*x1321))+(((-46.1)*cj4))),-1);
if(!x1327.valid){
continue;
}
CheckValue<IkReal> x1328=IKPowWithIntegerCheck(cj4,-1);
if(!x1328.valid){
continue;
}
if( IKabs(((x1327.value)*(((((-1143.025)*x1323))+((sj6*x1325*x1326))+((x1320*x1323))+(((-1.0)*x1324*x1325))+(((-1.0)*x1322*x1324))+((x1323*x1326))+((sj6*x1320*x1325))+((sj6*x1320*x1322))+((sj6*x1322*x1326)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.00216919739696312)*(x1328.value)*(((-1143.025)+x1320+x1326)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1327.value)*(((((-1143.025)*x1323))+((sj6*x1325*x1326))+((x1320*x1323))+(((-1.0)*x1324*x1325))+(((-1.0)*x1322*x1324))+((x1323*x1326))+((sj6*x1320*x1325))+((sj6*x1320*x1322))+((sj6*x1322*x1326))))))+IKsqr(((0.00216919739696312)*(x1328.value)*(((-1143.025)+x1320+x1326))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((x1327.value)*(((((-1143.025)*x1323))+((sj6*x1325*x1326))+((x1320*x1323))+(((-1.0)*x1324*x1325))+(((-1.0)*x1322*x1324))+((x1323*x1326))+((sj6*x1320*x1325))+((sj6*x1320*x1322))+((sj6*x1322*x1326))))), ((0.00216919739696312)*(x1328.value)*(((-1143.025)+x1320+x1326))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1329=IKcos(j5);
IkReal x1330=IKsin(j5);
IkReal x1331=(npz*sj6);
IkReal x1332=((0.461)*cj4);
IkReal x1333=((1.0)*cj7*npy);
IkReal x1334=(sj6*x1329);
IkReal x1335=(cj6*x1330);
IkReal x1336=((1.0)*cj6*npz);
IkReal x1337=(cj4*x1329);
IkReal x1338=(npx*sj6*sj7);
IkReal x1339=((1.0)*npx*sj7);
IkReal x1340=(cj6*x1329);
evalcond[0]=((-0.228605)+(((-0.0922)*x1337))+(((0.071916)*sj4))+pp);
evalcond[1]=((-0.1)+x1331+(((-1.0)*x1329*x1332))+(((-1.0)*cj6*x1333))+(((-1.0)*cj6*x1339)));
evalcond[2]=((((-1.0)*x1338))+(((-1.0)*sj6*x1333))+((x1330*x1332))+(((-1.0)*x1336)));
evalcond[3]=((((-1.0)*x1335*x1339))+(((-0.1)*x1330))+(((-1.0)*x1334*x1339))+(((-1.0)*x1329*x1336))+(((-1.0)*x1333*x1334))+(((-1.0)*x1333*x1335))+((x1330*x1331)));
evalcond[4]=(((x1329*x1331))+((npz*x1335))+(((-1.0)*x1339*x1340))+((cj7*npy*sj6*x1330))+(((-0.1)*x1329))+(((-1.0)*x1333*x1340))+((x1330*x1338))+(((-1.0)*x1332)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1341=((1000.0)*sj6);
IkReal x1342=(cj7*npy);
IkReal x1343=(npx*sj7);
IkReal x1344=((1000.0)*cj6);
CheckValue<IkReal> x1345=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x1345.valid){
continue;
}
CheckValue<IkReal> x1346 = IKatan2WithCheck(IkReal((((npz*x1344))+((x1341*x1342))+((x1341*x1343)))),IkReal(((-100.0)+((npz*x1341))+(((-1.0)*x1342*x1344))+(((-1.0)*x1343*x1344)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1346.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1345.value)))+(x1346.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1347=IKcos(j5);
IkReal x1348=IKsin(j5);
IkReal x1349=(npz*sj6);
IkReal x1350=((0.461)*cj4);
IkReal x1351=((1.0)*cj7*npy);
IkReal x1352=(sj6*x1347);
IkReal x1353=(cj6*x1348);
IkReal x1354=((1.0)*cj6*npz);
IkReal x1355=(cj4*x1347);
IkReal x1356=(npx*sj6*sj7);
IkReal x1357=((1.0)*npx*sj7);
IkReal x1358=(cj6*x1347);
evalcond[0]=((-0.228605)+(((0.071916)*sj4))+pp+(((-0.0922)*x1355)));
evalcond[1]=((-0.1)+x1349+(((-1.0)*x1347*x1350))+(((-1.0)*cj6*x1357))+(((-1.0)*cj6*x1351)));
evalcond[2]=((((-1.0)*x1354))+(((-1.0)*x1356))+(((-1.0)*sj6*x1351))+((x1348*x1350)));
evalcond[3]=((((-1.0)*x1352*x1357))+(((-1.0)*x1347*x1354))+((x1348*x1349))+(((-0.1)*x1348))+(((-1.0)*x1351*x1353))+(((-1.0)*x1351*x1352))+(((-1.0)*x1353*x1357)));
evalcond[4]=((((-1.0)*x1350))+((cj7*npy*sj6*x1348))+((x1347*x1349))+((x1348*x1356))+(((-0.1)*x1347))+(((-1.0)*x1357*x1358))+(((-1.0)*x1351*x1358))+((npz*x1353)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1359=((1000.0)*sj6);
CheckValue<IkReal> x1360=IKPowWithIntegerCheck(IKsign(cj4),-1);
if(!x1360.valid){
continue;
}
CheckValue<IkReal> x1361 = IKatan2WithCheck(IkReal(((((1000.0)*cj6*npz))+((npx*sj7*x1359))+((cj7*npy*x1359)))),IkReal(((-1143.025)+(((359.58)*sj4))+(((5000.0)*pp)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1361.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1360.value)))+(x1361.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x1362=IKcos(j5);
IkReal x1363=IKsin(j5);
IkReal x1364=(npz*sj6);
IkReal x1365=((0.461)*cj4);
IkReal x1366=((1.0)*cj7*npy);
IkReal x1367=(sj6*x1362);
IkReal x1368=(cj6*x1363);
IkReal x1369=((1.0)*cj6*npz);
IkReal x1370=(cj4*x1362);
IkReal x1371=(npx*sj6*sj7);
IkReal x1372=((1.0)*npx*sj7);
IkReal x1373=(cj6*x1362);
evalcond[0]=((-0.228605)+(((0.071916)*sj4))+(((-0.0922)*x1370))+pp);
evalcond[1]=((-0.1)+x1364+(((-1.0)*x1362*x1365))+(((-1.0)*cj6*x1366))+(((-1.0)*cj6*x1372)));
evalcond[2]=((((-1.0)*sj6*x1366))+((x1363*x1365))+(((-1.0)*x1371))+(((-1.0)*x1369)));
evalcond[3]=((((-1.0)*x1366*x1367))+(((-1.0)*x1366*x1368))+((x1363*x1364))+(((-1.0)*x1362*x1369))+(((-1.0)*x1367*x1372))+(((-1.0)*x1368*x1372))+(((-0.1)*x1363)));
evalcond[4]=(((npz*x1368))+((cj7*npy*sj6*x1363))+(((-1.0)*x1372*x1373))+(((-1.0)*x1366*x1373))+((x1363*x1371))+((x1362*x1364))+(((-0.1)*x1362))+(((-1.0)*x1365)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x123=((1.0)*sj7);
IkReal x124=((1.0)*sj4);
IkReal x125=((1.0)*sj5);
IkReal x126=((1.0)*cj4);
IkReal x127=((1.0)*sj6);
IkReal x128=(((r00*sj7))+((cj7*r01)));
IkReal x129=(((cj7*r00))+(((-1.0)*r01*x123)));
IkReal x130=(((r10*sj7))+((cj7*r11)));
IkReal x131=((((-1.0)*r11*x123))+((cj7*r10)));
IkReal x132=(((cj7*r21))+((r20*sj7)));
IkReal x133=(((cj7*r20))+(((-1.0)*r21*x123)));
IkReal x134=(((cj6*x128))+(((-1.0)*r02*x127)));
IkReal x135=(((sj6*x128))+((cj6*r02)));
IkReal x136=(((cj6*x130))+(((-1.0)*r12*x127)));
IkReal x137=(((sj6*x130))+((cj6*r12)));
IkReal x138=(((sj6*x132))+((cj6*r22)));
IkReal x139=(((cj6*x132))+(((-1.0)*r22*x127)));
IkReal x140=((((-1.0)*x125*x135))+((cj5*x134)));
IkReal x141=((((-1.0)*x125*x137))+((cj5*x136)));
IkReal x142=((((-1.0)*x125*x138))+((cj5*x139)));
new_r00=((((-1.0)*x124*x140))+((cj4*x129)));
new_r01=(((sj5*x134))+((cj5*x135)));
new_r02=((((-1.0)*x126*x140))+(((-1.0)*x124*x129)));
new_r10=((((-1.0)*x124*x141))+((cj4*x131)));
new_r11=(((sj5*x136))+((cj5*x137)));
new_r12=((((-1.0)*x124*x131))+(((-1.0)*x126*x141)));
new_r20=((((-1.0)*x124*x142))+((cj4*x133)));
new_r21=(((sj5*x139))+((cj5*x138)));
new_r22=((((-1.0)*x124*x133))+(((-1.0)*x126*x142)));
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
sj2array[0]=((-1.0)*new_r22);
if( sj2array[0] >= -1-IKFAST_SINCOS_THRESH && sj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKasin(sj2array[0]);
    cj2array[0] = IKcos(j2array[0]);
    sj2array[1] = sj2array[0];
    j2array[1] = j2array[0] > 0 ? (IKPI-j2array[0]) : (-IKPI-j2array[0]);
    cj2array[1] = -cj2array[0];
}
else if( isnan(sj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
j1eval[0]=cj2;
j1eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j1eval[2]=IKsign(cj2);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=cj2;
j1eval[1]=new_r02;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j3mul = 1;
j3=0;
j1mul=1.0;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1=IKatan2(new_r01, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].fmul = j1mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j3mul = 1;
j3=0;
j1mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1=IKatan2(((-1.0)*new_r01), new_r11);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].fmul = j1mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x143=new_r22*new_r22;
IkReal x144=((16.0)*new_r10);
IkReal x145=((16.0)*new_r01);
IkReal x146=((16.0)*new_r00);
IkReal x147=(new_r11*new_r22);
IkReal x148=((8.0)*new_r00);
IkReal x149=(x143*x144);
IkReal x150=(x143*x145);
j1eval[0]=((IKabs(((((-1.0)*x145))+x150)))+(IKabs(((((-1.0)*x149))+x144)))+(IKabs(((((-8.0)*x147))+((x143*x148)))))+(IKabs(((((32.0)*new_r00))+(((-1.0)*x143*x146))+(((-16.0)*x147)))))+(IKabs(((((-1.0)*x150))+x145)))+(IKabs((((new_r22*x148))+(((-8.0)*new_r11)))))+(IKabs((((new_r22*x146))+(((16.0)*new_r11))+(((-32.0)*new_r11*x143)))))+(IKabs(((((-1.0)*x144))+x149))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j3]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j1evalpoly[1];
IkReal x151=new_r22*new_r22;
IkReal x152=((16.0)*new_r01);
IkReal x153=(new_r00*new_r22);
IkReal x154=(x151*x152);
IkReal x155=((((8.0)*x153))+(((-8.0)*new_r11)));
op[0]=x155;
op[1]=((((-1.0)*x152))+x154);
op[2]=((((-32.0)*new_r11*x151))+(((16.0)*new_r11))+(((16.0)*x153)));
op[3]=((((-1.0)*x154))+x152);
op[4]=x155;
polyroots4(op,zeror,numroots);
IkReal j1array[4], cj1array[4], sj1array[4], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[4]={true,true,true,true};
_nj1 = 4;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x156=new_r22*new_r22;
IkReal x157=((16.0)*new_r10);
IkReal x158=(new_r11*new_r22);
IkReal x159=((8.0)*x158);
IkReal x160=(new_r00*x156);
IkReal x161=((8.0)*x160);
IkReal x162=(x156*x157);
j1evalpoly[0]=((((-1.0)*x159))+(((htj1*htj1)*(((((32.0)*new_r00))+(((-16.0)*x160))+(((-16.0)*x158))))))+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x159))+x161))))+(((htj1*htj1*htj1)*(((((-1.0)*x162))+x157))))+((htj1*(((((-1.0)*x157))+x162))))+x161);
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j3eval[3];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x163=new_r22*new_r22;
IkReal x164=cj1*cj1;
IkReal x165=(new_r22*sj1);
IkReal x166=((((-1.0)*x164))+(((-1.0)*x163))+((x163*x164)));
j3eval[0]=x166;
j3eval[1]=((IKabs((((new_r01*x165))+(((-1.0)*cj1*new_r00)))))+(IKabs((((new_r00*x165))+((cj1*new_r01))))));
j3eval[2]=IKsign(x166);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=new_r22;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=cj1;
j3eval[1]=new_r22;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x167=IKsin(j3);
IkReal x168=IKcos(j3);
IkReal x169=((1.0)*new_r22);
IkReal x170=((1.0)*x168);
IkReal x171=((1.0)*x167);
evalcond[0]=(x167+new_r11);
evalcond[1]=((((-1.0)*x170))+new_r10);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x167*x169)));
evalcond[3]=((((-1.0)*x168*x169))+(((-1.0)*new_r01)));
evalcond[4]=((((-1.0)*new_r00*x169))+(((-1.0)*x171)));
evalcond[5]=((((-1.0)*x170))+(((-1.0)*new_r01*x169)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x172=IKsin(j3);
IkReal x173=IKcos(j3);
IkReal x174=((1.0)*x173);
IkReal x175=((1.0)*x172);
evalcond[0]=(x172+(((-1.0)*new_r11)));
evalcond[1]=((((-1.0)*new_r22*x175))+new_r00);
evalcond[2]=((((-1.0)*new_r22*x174))+new_r01);
evalcond[3]=((((-1.0)*x174))+(((-1.0)*new_r10)));
evalcond[4]=((((-1.0)*x175))+((new_r00*new_r22)));
evalcond[5]=((((-1.0)*x174))+((new_r01*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x176=new_r22*new_r22;
CheckValue<IkReal> x177=IKPowWithIntegerCheck(((-1.0)+x176),-1);
if(!x177.valid){
continue;
}
if(((x176*(x177.value))) < -0.00001)
continue;
IkReal gconst6=IKsqrt((x176*(x177.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj1)))))+(IKabs((cj1+(((-1.0)*gconst6)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst6*gconst6))))) < -0.00001)
continue;
IkReal x178=IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6)))));
if( IKabs(((((-1.0)*new_r11*x178))+(((-1.0)*gconst6*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x178))+((gconst6*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*x178))+(((-1.0)*gconst6*new_r01))))+IKsqr((((new_r10*x178))+((gconst6*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*x178))+(((-1.0)*gconst6*new_r01))), (((new_r10*x178))+((gconst6*new_r00))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x179=IKcos(j3);
IkReal x180=IKsin(j3);
IkReal x181=((1.0)*new_r22);
IkReal x182=(gconst6*new_r10);
IkReal x183=(gconst6*new_r11);
IkReal x184=((1.0)*x179);
IkReal x185=(gconst6*x180);
IkReal x186=(gconst6*x179);
IkReal x187=x178;
IkReal x188=(new_r00*x187);
IkReal x189=(new_r01*x187);
IkReal x190=(x180*x187);
evalcond[0]=(((new_r11*x187))+((gconst6*new_r01))+x180);
evalcond[1]=(((new_r10*x187))+((gconst6*new_r00))+(((-1.0)*x184)));
evalcond[2]=(((new_r22*x179*x187))+x185+new_r01);
evalcond[3]=(x190+new_r11+(((-1.0)*x181*x186)));
evalcond[4]=((((-1.0)*x188))+(((-1.0)*x180*x181))+x182);
evalcond[5]=((((-1.0)*x189))+x183+(((-1.0)*x179*x181)));
evalcond[6]=(((new_r22*x190))+(((-1.0)*gconst6*x184))+new_r00);
evalcond[7]=((((-1.0)*x184*x187))+new_r10+(((-1.0)*x181*x185)));
evalcond[8]=((((-1.0)*x180))+((new_r22*x182))+(((-1.0)*x181*x188)));
evalcond[9]=((((-1.0)*x184))+((new_r22*x183))+(((-1.0)*x181*x189)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x191=new_r22*new_r22;
CheckValue<IkReal> x192=IKPowWithIntegerCheck(((-1.0)+x191),-1);
if(!x192.valid){
continue;
}
if(((x191*(x192.value))) < -0.00001)
continue;
IkReal gconst6=IKsqrt((x191*(x192.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj1)))))+(IKabs((cj1+(((-1.0)*gconst6)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst6*gconst6))))) < -0.00001)
continue;
IkReal x193=IKsqrt(((1.0)+(((-1.0)*(gconst6*gconst6)))));
if( IKabs((((new_r11*x193))+(((-1.0)*gconst6*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((gconst6*new_r00))+(((-1.0)*new_r10*x193)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r11*x193))+(((-1.0)*gconst6*new_r01))))+IKsqr((((gconst6*new_r00))+(((-1.0)*new_r10*x193))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((((new_r11*x193))+(((-1.0)*gconst6*new_r01))), (((gconst6*new_r00))+(((-1.0)*new_r10*x193))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x194=IKsin(j3);
IkReal x195=IKcos(j3);
IkReal x196=(gconst6*new_r10);
IkReal x197=((1.0)*new_r22);
IkReal x198=(gconst6*new_r11);
IkReal x199=((1.0)*x195);
IkReal x200=(gconst6*x194);
IkReal x201=(x195*x197);
IkReal x202=x193;
IkReal x203=(new_r01*x202);
IkReal x204=(new_r00*x202);
IkReal x205=((1.0)*x202);
IkReal x206=(x194*x202);
evalcond[0]=(((gconst6*new_r01))+x194+(((-1.0)*new_r11*x205)));
evalcond[1]=(((gconst6*new_r00))+(((-1.0)*x199))+(((-1.0)*new_r10*x205)));
evalcond[2]=((((-1.0)*x194*x197))+x196+x204);
evalcond[3]=(x198+(((-1.0)*x201))+x203);
evalcond[4]=((((-1.0)*x201*x202))+x200+new_r01);
evalcond[5]=((((-1.0)*x197*x200))+((x195*x202))+new_r10);
evalcond[6]=((((-1.0)*x194))+((new_r22*x196))+((new_r22*x204)));
evalcond[7]=((((-1.0)*x199))+((new_r22*x198))+((new_r22*x203)));
evalcond[8]=((((-1.0)*x194*x205))+new_r11+(((-1.0)*gconst6*x201)));
evalcond[9]=((((-1.0)*x197*x206))+(((-1.0)*gconst6*x199))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x207=new_r22*new_r22;
CheckValue<IkReal> x208=IKPowWithIntegerCheck(((-1.0)+x207),-1);
if(!x208.valid){
continue;
}
if(((x207*(x208.value))) < -0.00001)
continue;
IkReal gconst7=((-1.0)*(IKsqrt((x207*(x208.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj1+(((-1.0)*gconst7)))))+(IKabs(((-1.0)+(IKsign(sj1)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
IkReal x209=IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7)))));
if( IKabs(((((-1.0)*gconst7*new_r01))+(((-1.0)*new_r11*x209)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x209))+((gconst7*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst7*new_r01))+(((-1.0)*new_r11*x209))))+IKsqr((((new_r10*x209))+((gconst7*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst7*new_r01))+(((-1.0)*new_r11*x209))), (((new_r10*x209))+((gconst7*new_r00))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x210=IKsin(j3);
IkReal x211=IKcos(j3);
IkReal x212=((1.0)*new_r22);
IkReal x213=(gconst7*new_r11);
IkReal x214=(gconst7*new_r10);
IkReal x215=((1.0)*x211);
IkReal x216=(gconst7*x211);
IkReal x217=(gconst7*x210);
IkReal x218=x209;
IkReal x219=(new_r00*x218);
IkReal x220=((1.0)*x218);
IkReal x221=(x210*x218);
evalcond[0]=(x210+((new_r11*x218))+((gconst7*new_r01)));
evalcond[1]=((((-1.0)*x215))+((gconst7*new_r00))+((new_r10*x218)));
evalcond[2]=(((new_r22*x211*x218))+x217+new_r01);
evalcond[3]=(x221+new_r11+(((-1.0)*x212*x216)));
evalcond[4]=(x214+(((-1.0)*x210*x212))+(((-1.0)*x219)));
evalcond[5]=((((-1.0)*new_r01*x220))+x213+(((-1.0)*x211*x212)));
evalcond[6]=((((-1.0)*gconst7*x215))+((new_r22*x221))+new_r00);
evalcond[7]=(new_r10+(((-1.0)*x212*x217))+(((-1.0)*x215*x218)));
evalcond[8]=(((new_r22*x214))+(((-1.0)*x210))+(((-1.0)*x212*x219)));
evalcond[9]=(((new_r22*x213))+(((-1.0)*new_r01*x212*x218))+(((-1.0)*x215)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x222=new_r22*new_r22;
CheckValue<IkReal> x223=IKPowWithIntegerCheck(((-1.0)+x222),-1);
if(!x223.valid){
continue;
}
if(((x222*(x223.value))) < -0.00001)
continue;
IkReal gconst7=((-1.0)*(IKsqrt((x222*(x223.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj1+(((-1.0)*gconst7)))))+(IKabs(((1.0)+(IKsign(sj1)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst7*gconst7))))) < -0.00001)
continue;
IkReal x224=IKsqrt(((1.0)+(((-1.0)*(gconst7*gconst7)))));
if( IKabs(((((-1.0)*gconst7*new_r01))+((new_r11*x224)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r10*x224))+((gconst7*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst7*new_r01))+((new_r11*x224))))+IKsqr(((((-1.0)*new_r10*x224))+((gconst7*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst7*new_r01))+((new_r11*x224))), ((((-1.0)*new_r10*x224))+((gconst7*new_r00))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x225=IKsin(j3);
IkReal x226=IKcos(j3);
IkReal x227=(gconst7*new_r11);
IkReal x228=(gconst7*new_r22);
IkReal x229=((1.0)*x226);
IkReal x230=((1.0)*x225);
IkReal x231=x224;
IkReal x232=(new_r22*x231);
IkReal x233=((1.0)*x231);
evalcond[0]=(x225+((gconst7*new_r01))+(((-1.0)*new_r11*x233)));
evalcond[1]=((((-1.0)*new_r10*x233))+((gconst7*new_r00))+(((-1.0)*x229)));
evalcond[2]=((((-1.0)*new_r22*x230))+((new_r00*x231))+((gconst7*new_r10)));
evalcond[3]=(((new_r01*x231))+x227+(((-1.0)*new_r22*x229)));
evalcond[4]=(((gconst7*x225))+new_r01+(((-1.0)*x229*x232)));
evalcond[5]=(((x226*x231))+new_r10+(((-1.0)*x228*x230)));
evalcond[6]=(((new_r00*x232))+(((-1.0)*x230))+((new_r10*x228)));
evalcond[7]=(((new_r01*x232))+((new_r22*x227))+(((-1.0)*x229)));
evalcond[8]=((((-1.0)*x230*x231))+(((-1.0)*x228*x229))+new_r11);
evalcond[9]=((((-1.0)*x230*x232))+new_r00+(((-1.0)*gconst7*x229)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x234=((1.0)*cj1*new_r01);
CheckValue<IkReal> x235=IKPowWithIntegerCheck(cj1,-1);
if(!x235.valid){
continue;
}
CheckValue<IkReal> x236=IKPowWithIntegerCheck(new_r22,-1);
if(!x236.valid){
continue;
}
if( IKabs(((((-1.0)*x234))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x235.value)*(x236.value)*(((((-1.0)*sj1*x234))+((new_r11*(cj1*cj1))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x234))+(((-1.0)*new_r11*sj1))))+IKsqr(((x235.value)*(x236.value)*(((((-1.0)*sj1*x234))+((new_r11*(cj1*cj1)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*x234))+(((-1.0)*new_r11*sj1))), ((x235.value)*(x236.value)*(((((-1.0)*sj1*x234))+((new_r11*(cj1*cj1)))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x237=IKcos(j3);
IkReal x238=IKsin(j3);
IkReal x239=(cj1*new_r22);
IkReal x240=(new_r22*sj1);
IkReal x241=((1.0)*new_r00);
IkReal x242=((1.0)*new_r01);
IkReal x243=((1.0)*x237);
IkReal x244=(cj1*x238);
IkReal x245=((1.0)*x238);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x238);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x243)));
evalcond[2]=(((x237*x240))+x244+new_r01);
evalcond[3]=(((sj1*x238))+new_r11+(((-1.0)*x239*x243)));
evalcond[4]=((((-1.0)*sj1*x241))+((cj1*new_r10))+(((-1.0)*new_r22*x245)));
evalcond[5]=((((-1.0)*sj1*x242))+((cj1*new_r11))+(((-1.0)*new_r22*x243)));
evalcond[6]=((((-1.0)*cj1*x243))+((x238*x240))+new_r00);
evalcond[7]=((((-1.0)*sj1*x243))+new_r10+(((-1.0)*x239*x245)));
evalcond[8]=(((new_r10*x239))+(((-1.0)*x240*x241))+(((-1.0)*x245)));
evalcond[9]=(((new_r11*x239))+(((-1.0)*x240*x242))+(((-1.0)*x243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x246=((1.0)*new_r01);
CheckValue<IkReal> x247=IKPowWithIntegerCheck(new_r22,-1);
if(!x247.valid){
continue;
}
if( IKabs(((((-1.0)*cj1*x246))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x247.value)*(((((-1.0)*sj1*x246))+((cj1*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x246))+(((-1.0)*new_r11*sj1))))+IKsqr(((x247.value)*(((((-1.0)*sj1*x246))+((cj1*new_r11))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj1*x246))+(((-1.0)*new_r11*sj1))), ((x247.value)*(((((-1.0)*sj1*x246))+((cj1*new_r11))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x248=IKcos(j3);
IkReal x249=IKsin(j3);
IkReal x250=(cj1*new_r22);
IkReal x251=(new_r22*sj1);
IkReal x252=((1.0)*new_r00);
IkReal x253=((1.0)*new_r01);
IkReal x254=((1.0)*x248);
IkReal x255=(cj1*x249);
IkReal x256=((1.0)*x249);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x249);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x254)));
evalcond[2]=(((x248*x251))+x255+new_r01);
evalcond[3]=((((-1.0)*x250*x254))+new_r11+((sj1*x249)));
evalcond[4]=(((cj1*new_r10))+(((-1.0)*sj1*x252))+(((-1.0)*new_r22*x256)));
evalcond[5]=(((cj1*new_r11))+(((-1.0)*sj1*x253))+(((-1.0)*new_r22*x254)));
evalcond[6]=(((x249*x251))+(((-1.0)*cj1*x254))+new_r00);
evalcond[7]=((((-1.0)*x250*x256))+(((-1.0)*sj1*x254))+new_r10);
evalcond[8]=((((-1.0)*x251*x252))+((new_r10*x250))+(((-1.0)*x256)));
evalcond[9]=((((-1.0)*x251*x253))+((new_r11*x250))+(((-1.0)*x254)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x257=new_r22*new_r22;
IkReal x258=cj1*cj1;
IkReal x259=(new_r22*sj1);
CheckValue<IkReal> x260 = IKatan2WithCheck(IkReal((((new_r00*x259))+((cj1*new_r01)))),IkReal((((new_r01*x259))+(((-1.0)*cj1*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x260.valid){
continue;
}
CheckValue<IkReal> x261=IKPowWithIntegerCheck(IKsign((((x257*x258))+(((-1.0)*x257))+(((-1.0)*x258)))),-1);
if(!x261.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x260.value)+(((1.5707963267949)*(x261.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x262=IKcos(j3);
IkReal x263=IKsin(j3);
IkReal x264=(cj1*new_r22);
IkReal x265=(new_r22*sj1);
IkReal x266=((1.0)*new_r00);
IkReal x267=((1.0)*new_r01);
IkReal x268=((1.0)*x262);
IkReal x269=(cj1*x263);
IkReal x270=((1.0)*x263);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x263);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x268)));
evalcond[2]=(((x262*x265))+x269+new_r01);
evalcond[3]=(new_r11+(((-1.0)*x264*x268))+((sj1*x263)));
evalcond[4]=((((-1.0)*sj1*x266))+(((-1.0)*new_r22*x270))+((cj1*new_r10)));
evalcond[5]=((((-1.0)*sj1*x267))+((cj1*new_r11))+(((-1.0)*new_r22*x268)));
evalcond[6]=((((-1.0)*cj1*x268))+((x263*x265))+new_r00);
evalcond[7]=((((-1.0)*sj1*x268))+new_r10+(((-1.0)*x264*x270)));
evalcond[8]=((((-1.0)*x270))+(((-1.0)*x265*x266))+((new_r10*x264)));
evalcond[9]=((((-1.0)*x265*x267))+(((-1.0)*x268))+((new_r11*x264)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x272=IKPowWithIntegerCheck(cj2,-1);
if(!x272.valid){
continue;
}
IkReal x271=x272.value;
CheckValue<IkReal> x273=IKPowWithIntegerCheck(new_r02,-1);
if(!x273.valid){
continue;
}
CheckValue<IkReal> x274=IKPowWithIntegerCheck(x271,-2);
if(!x274.valid){
continue;
}
if( IKabs((x271*(x273.value)*(((x274.value)+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x271)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x271*(x273.value)*(((x274.value)+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x271))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x271*(x273.value)*(((x274.value)+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x271));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x275=IKsin(j1);
IkReal x276=IKcos(j1);
IkReal x277=((1.0)*x275);
IkReal x278=(cj2*x276);
IkReal x279=(new_r12*x276);
evalcond[0]=(x278+new_r12);
evalcond[1]=((((-1.0)*cj2*x277))+new_r02);
evalcond[2]=(((new_r02*x276))+((new_r12*x275)));
evalcond[3]=(cj2+x279+(((-1.0)*new_r02*x277)));
evalcond[4]=((((-1.0)*cj2*new_r00*x277))+((new_r20*sj2))+((new_r10*x278)));
evalcond[5]=((((-1.0)*cj2*new_r01*x277))+((new_r21*sj2))+((new_r11*x278)));
evalcond[6]=(((new_r02*sj2*x275))+(((-1.0)*sj2*x279))+((cj2*new_r22)));
evalcond[7]=((1.0)+(((-1.0)*cj2*new_r02*x277))+((new_r22*sj2))+((new_r12*x278)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj2;
j3eval[1]=sj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=sj1;
j3eval[2]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x280=((1.0)*cj1);
if( IKabs(((((-1.0)*new_r01*x280))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj1))+(((-1.0)*new_r11*x280)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x280))+(((-1.0)*new_r11*sj1))))+IKsqr((((new_r01*sj1))+(((-1.0)*new_r11*x280))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r01*x280))+(((-1.0)*new_r11*sj1))), (((new_r01*sj1))+(((-1.0)*new_r11*x280))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x281=IKsin(j3);
IkReal x282=IKcos(j3);
IkReal x283=((1.0)*sj1);
IkReal x284=(cj1*x281);
IkReal x285=(cj1*x282);
IkReal x286=(x282*x283);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x281);
evalcond[1]=(((cj1*new_r10))+(((-1.0)*new_r00*x283))+x281);
evalcond[2]=(((cj1*new_r11))+x282+(((-1.0)*new_r01*x283)));
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x282)));
evalcond[4]=(x285+new_r11+((sj1*x281)));
evalcond[5]=(x284+(((-1.0)*x286))+new_r01);
evalcond[6]=(x284+(((-1.0)*x286))+new_r10);
evalcond[7]=((((-1.0)*x281*x283))+(((-1.0)*x285))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x287=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj1*x287))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x287))+((cj1*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x287))+(((-1.0)*new_r11*sj1))))+IKsqr(((((-1.0)*sj1*x287))+((cj1*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj1*x287))+(((-1.0)*new_r11*sj1))), ((((-1.0)*sj1*x287))+((cj1*new_r11))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x288=IKcos(j3);
IkReal x289=IKsin(j3);
IkReal x290=((1.0)*sj1);
IkReal x291=((1.0)*x288);
IkReal x292=(sj1*x289);
IkReal x293=((1.0)*x289);
IkReal x294=(sj1*x288);
IkReal x295=(cj1*x291);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x289);
evalcond[1]=(((new_r10*sj1))+(((-1.0)*x291))+((cj1*new_r00)));
evalcond[2]=(x294+new_r01+((cj1*x289)));
evalcond[3]=((((-1.0)*x295))+x292+new_r11);
evalcond[4]=((((-1.0)*x293))+((cj1*new_r10))+(((-1.0)*new_r00*x290)));
evalcond[5]=((((-1.0)*new_r01*x290))+(((-1.0)*x291))+((cj1*new_r11)));
evalcond[6]=((((-1.0)*x295))+x292+new_r00);
evalcond[7]=((((-1.0)*cj1*x293))+(((-1.0)*x288*x290))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x296=IKcos(j3);
IkReal x297=IKsin(j3);
IkReal x298=((1.0)*sj2);
IkReal x299=((1.0)*x296);
IkReal x300=((1.0)*x297);
evalcond[0]=(x297+new_r01);
evalcond[1]=((((-1.0)*x299))+new_r00);
evalcond[2]=(new_r11+((sj2*x296)));
evalcond[3]=(new_r10+((sj2*x297)));
evalcond[4]=((((-1.0)*cj2*x300))+new_r20);
evalcond[5]=((((-1.0)*cj2*x299))+new_r21);
evalcond[6]=((((-1.0)*new_r10*x298))+((cj2*new_r20))+(((-1.0)*x300)));
evalcond[7]=((((-1.0)*new_r11*x298))+(((-1.0)*x299))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x301=IKsin(j3);
IkReal x302=IKcos(j3);
IkReal x303=((1.0)*x302);
IkReal x304=((1.0)*x301);
evalcond[0]=(x301+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*cj2*x304))+new_r20);
evalcond[2]=((((-1.0)*cj2*x303))+new_r21);
evalcond[3]=((((-1.0)*sj2*x303))+new_r11);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x303)));
evalcond[5]=(((sj2*x301))+(((-1.0)*new_r10)));
evalcond[6]=(((new_r10*sj2))+((cj2*new_r20))+(((-1.0)*x304)));
evalcond[7]=(((new_r11*sj2))+((cj2*new_r21))+(((-1.0)*x303)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r20, new_r21);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x305=IKsin(j3);
IkReal x306=IKcos(j3);
IkReal x307=((1.0)*x306);
evalcond[0]=((((-1.0)*x305))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x307)));
evalcond[2]=(new_r11+((sj1*x305)));
evalcond[3]=(((cj1*x305))+new_r01);
evalcond[4]=((((-1.0)*sj1*x307))+new_r10);
evalcond[5]=((((-1.0)*cj1*x307))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x305);
evalcond[7]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x307)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x308=IKsin(j3);
IkReal x309=IKcos(j3);
IkReal x310=((1.0)*x309);
evalcond[0]=(x308+new_r20);
evalcond[1]=(x309+new_r21);
evalcond[2]=(new_r11+((sj1*x308)));
evalcond[3]=(((cj1*x308))+new_r01);
evalcond[4]=((((-1.0)*sj1*x310))+new_r10);
evalcond[5]=((((-1.0)*cj1*x310))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x308);
evalcond[7]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x310)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=IKabs(new_r22);
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j3array[2], cj3array[2], sj3array[2], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[2]={true,true};
_nj3 = 2;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x312=IKPowWithIntegerCheck(cj2,-1);
if(!x312.valid){
continue;
}
IkReal x311=x312.value;
CheckValue<IkReal> x313=IKPowWithIntegerCheck(sj1,-1);
if(!x313.valid){
continue;
}
CheckValue<IkReal> x314=IKPowWithIntegerCheck(sj2,-1);
if(!x314.valid){
continue;
}
if( IKabs((new_r20*x311)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x311*(x313.value)*(x314.value)*((((cj1*new_r20))+((cj2*new_r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x311))+IKsqr((x311*(x313.value)*(x314.value)*((((cj1*new_r20))+((cj2*new_r01))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x311), (x311*(x313.value)*(x314.value)*((((cj1*new_r20))+((cj2*new_r01))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x315=IKsin(j3);
IkReal x316=IKcos(j3);
IkReal x317=(cj1*new_r11);
IkReal x318=((1.0)*cj2);
IkReal x319=((1.0)*sj2);
IkReal x320=((1.0)*sj1);
IkReal x321=(cj1*new_r10);
IkReal x322=(sj1*sj2);
IkReal x323=((1.0)*x316);
IkReal x324=(cj1*x315);
IkReal x325=(sj2*x315);
IkReal x326=(sj2*x316);
evalcond[0]=((((-1.0)*x315*x318))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x316*x318)));
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x315);
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x323))+((cj1*new_r00)));
evalcond[4]=(((cj1*x326))+((sj1*x315))+new_r11);
evalcond[5]=(x325+x321+(((-1.0)*new_r00*x320)));
evalcond[6]=(x326+x317+(((-1.0)*new_r01*x320)));
evalcond[7]=((((-1.0)*sj1*x316*x319))+x324+new_r01);
evalcond[8]=(((sj2*x324))+(((-1.0)*x316*x320))+new_r10);
evalcond[9]=((((-1.0)*sj1*x315*x319))+(((-1.0)*cj1*x323))+new_r00);
evalcond[10]=(((new_r00*x322))+(((-1.0)*x319*x321))+((cj2*new_r20))+(((-1.0)*x315)));
evalcond[11]=(((new_r01*x322))+(((-1.0)*x323))+((cj2*new_r21))+(((-1.0)*x317*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x328=IKPowWithIntegerCheck(cj2,-1);
if(!x328.valid){
continue;
}
IkReal x327=x328.value;
CheckValue<IkReal> x329=IKPowWithIntegerCheck(sj1,-1);
if(!x329.valid){
continue;
}
if( IKabs((x327*(x329.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x327)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x327*(x329.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))))+IKsqr((new_r21*x327))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x327*(x329.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))), (new_r21*x327));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x330=IKsin(j3);
IkReal x331=IKcos(j3);
IkReal x332=(cj1*new_r11);
IkReal x333=((1.0)*cj2);
IkReal x334=((1.0)*sj2);
IkReal x335=((1.0)*sj1);
IkReal x336=(cj1*new_r10);
IkReal x337=(sj1*sj2);
IkReal x338=((1.0)*x331);
IkReal x339=(cj1*x330);
IkReal x340=(sj2*x330);
IkReal x341=(sj2*x331);
evalcond[0]=((((-1.0)*x330*x333))+new_r20);
evalcond[1]=((((-1.0)*x331*x333))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x330);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x338)));
evalcond[4]=(((cj1*x341))+new_r11+((sj1*x330)));
evalcond[5]=(x336+x340+(((-1.0)*new_r00*x335)));
evalcond[6]=(x332+x341+(((-1.0)*new_r01*x335)));
evalcond[7]=((((-1.0)*sj1*x331*x334))+x339+new_r01);
evalcond[8]=(((sj2*x339))+(((-1.0)*x331*x335))+new_r10);
evalcond[9]=((((-1.0)*sj1*x330*x334))+new_r00+(((-1.0)*cj1*x338)));
evalcond[10]=(((new_r00*x337))+(((-1.0)*x330))+((cj2*new_r20))+(((-1.0)*x334*x336)));
evalcond[11]=(((new_r01*x337))+(((-1.0)*x338))+(((-1.0)*x332*x334))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x342=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x342.valid){
continue;
}
CheckValue<IkReal> x343 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x343.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x342.value)))+(x343.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x344=IKsin(j3);
IkReal x345=IKcos(j3);
IkReal x346=(cj1*new_r11);
IkReal x347=((1.0)*cj2);
IkReal x348=((1.0)*sj2);
IkReal x349=((1.0)*sj1);
IkReal x350=(cj1*new_r10);
IkReal x351=(sj1*sj2);
IkReal x352=((1.0)*x345);
IkReal x353=(cj1*x344);
IkReal x354=(sj2*x344);
IkReal x355=(sj2*x345);
evalcond[0]=((((-1.0)*x344*x347))+new_r20);
evalcond[1]=((((-1.0)*x345*x347))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x344);
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x352))+((cj1*new_r00)));
evalcond[4]=(((cj1*x355))+((sj1*x344))+new_r11);
evalcond[5]=(x350+x354+(((-1.0)*new_r00*x349)));
evalcond[6]=(x355+x346+(((-1.0)*new_r01*x349)));
evalcond[7]=(x353+new_r01+(((-1.0)*sj1*x345*x348)));
evalcond[8]=(((sj2*x353))+(((-1.0)*x345*x349))+new_r10);
evalcond[9]=((((-1.0)*sj1*x344*x348))+(((-1.0)*cj1*x352))+new_r00);
evalcond[10]=((((-1.0)*x348*x350))+((cj2*new_r20))+(((-1.0)*x344))+((new_r00*x351)));
evalcond[11]=(((new_r01*x351))+(((-1.0)*x352))+(((-1.0)*x346*x348))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x356=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x356.valid){
continue;
}
CheckValue<IkReal> x357 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x357.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x356.value)))+(x357.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x358=IKsin(j1);
IkReal x359=IKcos(j1);
IkReal x360=((1.0)*x358);
IkReal x361=(cj2*x359);
IkReal x362=(new_r12*x359);
evalcond[0]=(x361+new_r12);
evalcond[1]=((((-1.0)*cj2*x360))+new_r02);
evalcond[2]=(((new_r02*x359))+((new_r12*x358)));
evalcond[3]=(cj2+x362+(((-1.0)*new_r02*x360)));
evalcond[4]=(((new_r20*sj2))+((new_r10*x361))+(((-1.0)*cj2*new_r00*x360)));
evalcond[5]=((((-1.0)*cj2*new_r01*x360))+((new_r21*sj2))+((new_r11*x361)));
evalcond[6]=((((-1.0)*sj2*x362))+((new_r02*sj2*x358))+((cj2*new_r22)));
evalcond[7]=((1.0)+(((-1.0)*cj2*new_r02*x360))+((new_r22*sj2))+((new_r12*x361)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj2;
j3eval[1]=sj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=sj1;
j3eval[2]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x363=((1.0)*cj1);
if( IKabs(((((-1.0)*new_r11*sj1))+(((-1.0)*new_r01*x363)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj1))+(((-1.0)*new_r11*x363)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj1))+(((-1.0)*new_r01*x363))))+IKsqr((((new_r01*sj1))+(((-1.0)*new_r11*x363))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*sj1))+(((-1.0)*new_r01*x363))), (((new_r01*sj1))+(((-1.0)*new_r11*x363))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x364=IKsin(j3);
IkReal x365=IKcos(j3);
IkReal x366=((1.0)*sj1);
IkReal x367=(cj1*x364);
IkReal x368=(cj1*x365);
IkReal x369=(x365*x366);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x364);
evalcond[1]=((((-1.0)*new_r00*x366))+((cj1*new_r10))+x364);
evalcond[2]=(((cj1*new_r11))+x365+(((-1.0)*new_r01*x366)));
evalcond[3]=((((-1.0)*x365))+((new_r10*sj1))+((cj1*new_r00)));
evalcond[4]=(((sj1*x364))+x368+new_r11);
evalcond[5]=((((-1.0)*x369))+x367+new_r01);
evalcond[6]=((((-1.0)*x369))+x367+new_r10);
evalcond[7]=((((-1.0)*x368))+(((-1.0)*x364*x366))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x370=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj1*x370))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*new_r11))+(((-1.0)*sj1*x370)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x370))+(((-1.0)*new_r11*sj1))))+IKsqr((((cj1*new_r11))+(((-1.0)*sj1*x370))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj1*x370))+(((-1.0)*new_r11*sj1))), (((cj1*new_r11))+(((-1.0)*sj1*x370))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x371=IKcos(j3);
IkReal x372=IKsin(j3);
IkReal x373=((1.0)*sj1);
IkReal x374=((1.0)*x371);
IkReal x375=(sj1*x372);
IkReal x376=((1.0)*x372);
IkReal x377=(sj1*x371);
IkReal x378=(cj1*x374);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x372);
evalcond[1]=(((new_r10*sj1))+(((-1.0)*x374))+((cj1*new_r00)));
evalcond[2]=(x377+((cj1*x372))+new_r01);
evalcond[3]=((((-1.0)*x378))+x375+new_r11);
evalcond[4]=((((-1.0)*new_r00*x373))+(((-1.0)*x376))+((cj1*new_r10)));
evalcond[5]=((((-1.0)*x374))+((cj1*new_r11))+(((-1.0)*new_r01*x373)));
evalcond[6]=((((-1.0)*x378))+x375+new_r00);
evalcond[7]=((((-1.0)*cj1*x376))+(((-1.0)*x371*x373))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x379=IKcos(j3);
IkReal x380=IKsin(j3);
IkReal x381=((1.0)*sj2);
IkReal x382=((1.0)*x379);
IkReal x383=((1.0)*x380);
evalcond[0]=(x380+new_r01);
evalcond[1]=((((-1.0)*x382))+new_r00);
evalcond[2]=(((sj2*x379))+new_r11);
evalcond[3]=(new_r10+((sj2*x380)));
evalcond[4]=((((-1.0)*cj2*x383))+new_r20);
evalcond[5]=((((-1.0)*cj2*x382))+new_r21);
evalcond[6]=((((-1.0)*new_r10*x381))+(((-1.0)*x383))+((cj2*new_r20)));
evalcond[7]=((((-1.0)*new_r11*x381))+(((-1.0)*x382))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x384=IKsin(j3);
IkReal x385=IKcos(j3);
IkReal x386=((1.0)*x385);
IkReal x387=((1.0)*x384);
evalcond[0]=(x384+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*cj2*x387))+new_r20);
evalcond[2]=((((-1.0)*cj2*x386))+new_r21);
evalcond[3]=(new_r11+(((-1.0)*sj2*x386)));
evalcond[4]=((((-1.0)*x386))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r10))+((sj2*x384)));
evalcond[6]=(((new_r10*sj2))+(((-1.0)*x387))+((cj2*new_r20)));
evalcond[7]=(((new_r11*sj2))+(((-1.0)*x386))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r20, new_r21);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x388=IKsin(j3);
IkReal x389=IKcos(j3);
IkReal x390=((1.0)*x389);
evalcond[0]=((((-1.0)*x388))+new_r20);
evalcond[1]=((((-1.0)*x390))+new_r21);
evalcond[2]=(new_r11+((sj1*x388)));
evalcond[3]=(((cj1*x388))+new_r01);
evalcond[4]=((((-1.0)*sj1*x390))+new_r10);
evalcond[5]=((((-1.0)*cj1*x390))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x388);
evalcond[7]=((((-1.0)*x390))+((new_r10*sj1))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x391=IKsin(j3);
IkReal x392=IKcos(j3);
IkReal x393=((1.0)*x392);
evalcond[0]=(x391+new_r20);
evalcond[1]=(x392+new_r21);
evalcond[2]=(((sj1*x391))+new_r11);
evalcond[3]=(((cj1*x391))+new_r01);
evalcond[4]=((((-1.0)*sj1*x393))+new_r10);
evalcond[5]=((((-1.0)*cj1*x393))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x391);
evalcond[7]=((((-1.0)*x393))+((new_r10*sj1))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=IKabs(new_r22);
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j3array[2], cj3array[2], sj3array[2], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[2]={true,true};
_nj3 = 2;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x395=IKPowWithIntegerCheck(cj2,-1);
if(!x395.valid){
continue;
}
IkReal x394=x395.value;
CheckValue<IkReal> x396=IKPowWithIntegerCheck(sj1,-1);
if(!x396.valid){
continue;
}
CheckValue<IkReal> x397=IKPowWithIntegerCheck(sj2,-1);
if(!x397.valid){
continue;
}
if( IKabs((new_r20*x394)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x394*(x396.value)*(x397.value)*((((cj1*new_r20))+((cj2*new_r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x394))+IKsqr((x394*(x396.value)*(x397.value)*((((cj1*new_r20))+((cj2*new_r01))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x394), (x394*(x396.value)*(x397.value)*((((cj1*new_r20))+((cj2*new_r01))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x398=IKsin(j3);
IkReal x399=IKcos(j3);
IkReal x400=(cj1*new_r11);
IkReal x401=((1.0)*cj2);
IkReal x402=((1.0)*sj2);
IkReal x403=((1.0)*sj1);
IkReal x404=(cj1*new_r10);
IkReal x405=(sj1*sj2);
IkReal x406=((1.0)*x399);
IkReal x407=(cj1*x398);
IkReal x408=(sj2*x398);
IkReal x409=(sj2*x399);
evalcond[0]=((((-1.0)*x398*x401))+new_r20);
evalcond[1]=((((-1.0)*x399*x401))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x398);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x406)));
evalcond[4]=(((sj1*x398))+new_r11+((cj1*x409)));
evalcond[5]=(x404+x408+(((-1.0)*new_r00*x403)));
evalcond[6]=(x400+x409+(((-1.0)*new_r01*x403)));
evalcond[7]=((((-1.0)*sj1*x399*x402))+x407+new_r01);
evalcond[8]=(((sj2*x407))+(((-1.0)*x399*x403))+new_r10);
evalcond[9]=((((-1.0)*cj1*x406))+new_r00+(((-1.0)*sj1*x398*x402)));
evalcond[10]=((((-1.0)*x398))+(((-1.0)*x402*x404))+((cj2*new_r20))+((new_r00*x405)));
evalcond[11]=((((-1.0)*x400*x402))+((cj2*new_r21))+((new_r01*x405))+(((-1.0)*x406)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x411=IKPowWithIntegerCheck(cj2,-1);
if(!x411.valid){
continue;
}
IkReal x410=x411.value;
CheckValue<IkReal> x412=IKPowWithIntegerCheck(sj1,-1);
if(!x412.valid){
continue;
}
if( IKabs((x410*(x412.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x410)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x410*(x412.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))))+IKsqr((new_r21*x410))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x410*(x412.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))), (new_r21*x410));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x413=IKsin(j3);
IkReal x414=IKcos(j3);
IkReal x415=(cj1*new_r11);
IkReal x416=((1.0)*cj2);
IkReal x417=((1.0)*sj2);
IkReal x418=((1.0)*sj1);
IkReal x419=(cj1*new_r10);
IkReal x420=(sj1*sj2);
IkReal x421=((1.0)*x414);
IkReal x422=(cj1*x413);
IkReal x423=(sj2*x413);
IkReal x424=(sj2*x414);
evalcond[0]=((((-1.0)*x413*x416))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x414*x416)));
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x413);
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x421))+((cj1*new_r00)));
evalcond[4]=(((sj1*x413))+new_r11+((cj1*x424)));
evalcond[5]=(x419+x423+(((-1.0)*new_r00*x418)));
evalcond[6]=(x415+x424+(((-1.0)*new_r01*x418)));
evalcond[7]=(x422+(((-1.0)*sj1*x414*x417))+new_r01);
evalcond[8]=(new_r10+((sj2*x422))+(((-1.0)*x414*x418)));
evalcond[9]=((((-1.0)*cj1*x421))+new_r00+(((-1.0)*sj1*x413*x417)));
evalcond[10]=((((-1.0)*x417*x419))+((cj2*new_r20))+((new_r00*x420))+(((-1.0)*x413)));
evalcond[11]=((((-1.0)*x421))+((cj2*new_r21))+(((-1.0)*x415*x417))+((new_r01*x420)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x425=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x425.valid){
continue;
}
CheckValue<IkReal> x426 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x426.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x425.value)))+(x426.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x427=IKsin(j3);
IkReal x428=IKcos(j3);
IkReal x429=(cj1*new_r11);
IkReal x430=((1.0)*cj2);
IkReal x431=((1.0)*sj2);
IkReal x432=((1.0)*sj1);
IkReal x433=(cj1*new_r10);
IkReal x434=(sj1*sj2);
IkReal x435=((1.0)*x428);
IkReal x436=(cj1*x427);
IkReal x437=(sj2*x427);
IkReal x438=(sj2*x428);
evalcond[0]=((((-1.0)*x427*x430))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x428*x430)));
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x427);
evalcond[3]=((((-1.0)*x435))+((new_r10*sj1))+((cj1*new_r00)));
evalcond[4]=(((cj1*x438))+new_r11+((sj1*x427)));
evalcond[5]=((((-1.0)*new_r00*x432))+x433+x437);
evalcond[6]=((((-1.0)*new_r01*x432))+x429+x438);
evalcond[7]=((((-1.0)*sj1*x428*x431))+x436+new_r01);
evalcond[8]=(((sj2*x436))+new_r10+(((-1.0)*x428*x432)));
evalcond[9]=((((-1.0)*sj1*x427*x431))+(((-1.0)*cj1*x435))+new_r00);
evalcond[10]=((((-1.0)*x427))+((new_r00*x434))+(((-1.0)*x431*x433))+((cj2*new_r20)));
evalcond[11]=(((new_r01*x434))+(((-1.0)*x435))+(((-1.0)*x429*x431))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x439=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x439.valid){
continue;
}
CheckValue<IkReal> x440 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x440.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x439.value)))+(x440.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x441=((1.0)*cj2);
evalcond[0]=((((-1.0)*x441*(IKsin(j3))))+new_r20);
evalcond[1]=((((-1.0)*x441*(IKcos(j3))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[3];
j1eval[0]=cj2;
j1eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j1eval[2]=IKsign(cj2);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=cj2;
j1eval[1]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x442=((1.0)*sj3);
IkReal x443=(((new_r10*new_r11))+((new_r00*new_r01)));
j1eval[0]=x443;
j1eval[1]=IKsign(x443);
j1eval[2]=((IKabs((((new_r01*sj3))+(((-1.0)*new_r10*x442)))))+(IKabs(((((-1.0)*new_r00*x442))+(((-1.0)*new_r11*x442))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x444=((1.0)*sj3);
IkReal x445=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x445;
j1eval[1]=((IKabs(((((-1.0)*new_r01*x444))+(((-1.0)*cj3*new_r11)))))+(IKabs(((((-1.0)*new_r11*x444))+((cj3*new_r01))))));
j1eval[2]=IKsign(x445);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x446=(((new_r11*sj3))+((cj3*new_r01)));
j1eval[0]=x446;
j1eval[1]=((IKabs(((-1.0)+(cj3*cj3)+(new_r01*new_r01))))+(IKabs(((((-1.0)*cj3*sj3))+(((-1.0)*new_r01*new_r11))))));
j1eval[2]=IKsign(x446);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x448 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x448)==0){
continue;
}
IkReal x447=pow(x448,-0.5);
CheckValue<IkReal> x449 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x449.valid){
continue;
}
IkReal gconst0=((-1.0)*(x449.value));
IkReal gconst1=((-1.0)*new_r01*x447);
IkReal gconst2=(new_r11*x447);
CheckValue<IkReal> x450 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x450.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x450.value)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x453 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x453.valid){
continue;
}
IkReal x451=((-1.0)*(x453.value));
IkReal x452=x447;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x451;
IkReal gconst0=x451;
IkReal gconst1=((-1.0)*new_r01*x452);
IkReal gconst2=(new_r11*x452);
IkReal x454=new_r01*new_r01;
IkReal x455=(new_r00*new_r01);
IkReal x456=(((new_r10*new_r11))+x455);
IkReal x457=x447;
IkReal x458=(new_r01*x457);
j1eval[0]=x456;
j1eval[1]=((IKabs((((x455*x457))+((new_r11*x458)))))+(IKabs((((new_r10*x458))+(((-1.0)*x454*x457))))));
j1eval[2]=IKsign(x456);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
CheckValue<IkReal> x461 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x461.valid){
continue;
}
IkReal x459=((-1.0)*(x461.value));
IkReal x460=x447;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x459;
IkReal gconst0=x459;
IkReal gconst1=((-1.0)*new_r01*x460);
IkReal gconst2=(new_r11*x460);
IkReal x462=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x462;
j1eval[1]=IKsign(x462);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x465 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x465.valid){
continue;
}
IkReal x463=((-1.0)*(x465.value));
IkReal x464=x447;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x463;
IkReal gconst0=x463;
IkReal gconst1=((-1.0)*new_r01*x464);
IkReal gconst2=(new_r11*x464);
IkReal x466=new_r01*new_r01;
IkReal x467=new_r11*new_r11;
IkReal x468=((1.0)*x466);
CheckValue<IkReal> x474=IKPowWithIntegerCheck((x467+x466),-1);
if(!x474.valid){
continue;
}
IkReal x469=x474.value;
CheckValue<IkReal> x475=IKPowWithIntegerCheck(((((-1.0)*x467))+(((-1.0)*x468))),-1);
if(!x475.valid){
continue;
}
IkReal x470=x475.value;
IkReal x471=((1.0)*x470);
IkReal x472=(new_r11*x471);
IkReal x473=(new_r01*x471);
j1eval[0]=((IKabs(((((-1.0)*new_r01*x472*(new_r11*new_r11)))+(((-1.0)*new_r01*x472))+(((-1.0)*x472*(new_r01*new_r01*new_r01))))))+(IKabs((((x469*(x467*x467)))+(((-1.0)*x468*x469))+((x466*x467*x469))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x477 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x477.valid){
continue;
}
IkReal x476=((-1.0)*(x477.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x476;
new_r11=0;
new_r00=0;
IkReal gconst0=x476;
IkReal x478 = new_r01*new_r01;
if(IKabs(x478)==0){
continue;
}
IkReal gconst1=((-1.0)*new_r01*(pow(x478,-0.5)));
IkReal gconst2=0;
j1eval[0]=new_r01;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x480 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x480.valid){
continue;
}
IkReal x479=((-1.0)*(x480.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x479;
new_r11=0;
new_r00=0;
IkReal gconst0=x479;
IkReal x481 = new_r01*new_r01;
if(IKabs(x481)==0){
continue;
}
IkReal gconst1=((-1.0)*new_r01*(pow(x481,-0.5)));
IkReal gconst2=0;
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x482=IKPowWithIntegerCheck(gconst1,-1);
if(!x482.valid){
continue;
}
cj1array[0]=((-1.0)*new_r01*(x482.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x483=IKsin(j1);
IkReal x484=IKcos(j1);
evalcond[0]=(new_r10*x483);
evalcond[1]=(gconst1*x483);
evalcond[2]=((-1.0)*new_r01*x483);
evalcond[3]=(gconst1+((new_r01*x484)));
evalcond[4]=(gconst1+((new_r10*x484)));
evalcond[5]=(new_r10+((gconst1*x484)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x485=IKPowWithIntegerCheck(new_r10,-1);
if(!x485.valid){
continue;
}
cj1array[0]=((-1.0)*gconst1*(x485.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x486=IKsin(j1);
IkReal x487=IKcos(j1);
IkReal x488=(gconst1*x487);
evalcond[0]=(new_r10*x486);
evalcond[1]=(gconst1*x486);
evalcond[2]=((-1.0)*new_r01*x486);
evalcond[3]=(gconst1+((new_r01*x487)));
evalcond[4]=(x488+new_r01);
evalcond[5]=(x488+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x489=IKPowWithIntegerCheck(new_r01,-1);
if(!x489.valid){
continue;
}
cj1array[0]=((-1.0)*gconst1*(x489.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x490=IKsin(j1);
IkReal x491=IKcos(j1);
IkReal x492=(gconst1*x491);
evalcond[0]=(new_r10*x490);
evalcond[1]=(gconst1*x490);
evalcond[2]=((-1.0)*new_r01*x490);
evalcond[3]=(gconst1+((new_r10*x491)));
evalcond[4]=(x492+new_r01);
evalcond[5]=(x492+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst1;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x494 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x494.valid){
continue;
}
IkReal x493=((-1.0)*(x494.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x493;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst0=x493;
IkReal gconst1=((-1.0)*new_r01);
IkReal gconst2=new_r11;
j1eval[0]=-1.0;
j1eval[1]=((IKabs(new_r01*new_r01))+(IKabs((new_r01*new_r11))));
j1eval[2]=-1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x496 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x496.valid){
continue;
}
IkReal x495=((-1.0)*(x496.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x495;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst0=x495;
IkReal gconst1=((-1.0)*new_r01);
IkReal gconst2=new_r11;
j1eval[0]=-1.0;
j1eval[1]=-1.0;
j1eval[2]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x498 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x498.valid){
continue;
}
IkReal x497=((-1.0)*(x498.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x497;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst0=x497;
IkReal gconst1=((-1.0)*new_r01);
IkReal gconst2=new_r11;
j1eval[0]=1.0;
j1eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j1eval[2]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x499=((1.0)*new_r11);
CheckValue<IkReal> x500 = IKatan2WithCheck(IkReal((((gconst2*new_r01))+(((-1.0)*gconst1*x499)))),IkReal(((((-1.0)*gconst2*x499))+(((-1.0)*gconst1*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x500.valid){
continue;
}
CheckValue<IkReal> x501=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x501.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x500.value)+(((1.5707963267949)*(x501.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x502=IKcos(j1);
IkReal x503=IKsin(j1);
IkReal x504=(gconst1*x502);
IkReal x505=(gconst1*x503);
IkReal x506=(gconst2*x502);
IkReal x507=((1.0)*x503);
IkReal x508=(gconst2*x507);
evalcond[0]=(gconst1+((new_r11*x503))+((new_r01*x502)));
evalcond[1]=(x505+x506+new_r11);
evalcond[2]=((((-1.0)*x508))+x504);
evalcond[3]=((((-1.0)*new_r01*x507))+gconst2+((new_r11*x502)));
evalcond[4]=((((-1.0)*x508))+x504+new_r01);
evalcond[5]=((((-1.0)*x505))+(((-1.0)*x506)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x509=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst2*gconst2)))+(((-1.0)*(gconst1*gconst1))))),-1);
if(!x509.valid){
continue;
}
CheckValue<IkReal> x510 = IKatan2WithCheck(IkReal((gconst1*new_r11)),IkReal((gconst2*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x510.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x509.value)))+(x510.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x511=IKcos(j1);
IkReal x512=IKsin(j1);
IkReal x513=(gconst1*x511);
IkReal x514=(gconst1*x512);
IkReal x515=(gconst2*x511);
IkReal x516=((1.0)*x512);
IkReal x517=(gconst2*x516);
evalcond[0]=(((new_r01*x511))+((new_r11*x512))+gconst1);
evalcond[1]=(x515+x514+new_r11);
evalcond[2]=(x513+(((-1.0)*x517)));
evalcond[3]=(((new_r11*x511))+gconst2+(((-1.0)*new_r01*x516)));
evalcond[4]=(x513+new_r01+(((-1.0)*x517)));
evalcond[5]=((((-1.0)*x514))+(((-1.0)*x515)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x518=IKPowWithIntegerCheck(IKsign((((gconst1*new_r01))+(((-1.0)*gconst2*new_r11)))),-1);
if(!x518.valid){
continue;
}
CheckValue<IkReal> x519 = IKatan2WithCheck(IkReal((gconst1*gconst2)),IkReal(((-1.0)*(gconst1*gconst1))),IKFAST_ATAN2_MAGTHRESH);
if(!x519.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x518.value)))+(x519.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x520=IKcos(j1);
IkReal x521=IKsin(j1);
IkReal x522=(gconst1*x520);
IkReal x523=(gconst1*x521);
IkReal x524=(gconst2*x520);
IkReal x525=((1.0)*x521);
IkReal x526=(gconst2*x525);
evalcond[0]=(((new_r01*x520))+gconst1+((new_r11*x521)));
evalcond[1]=(x523+x524+new_r11);
evalcond[2]=((((-1.0)*x526))+x522);
evalcond[3]=(gconst2+((new_r11*x520))+(((-1.0)*new_r01*x525)));
evalcond[4]=((((-1.0)*x526))+x522+new_r01);
evalcond[5]=((((-1.0)*x524))+(((-1.0)*x523)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x527=IKPowWithIntegerCheck(gconst2,-1);
if(!x527.valid){
continue;
}
cj1array[0]=(new_r00*(x527.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x528=IKsin(j1);
IkReal x529=IKcos(j1);
IkReal x530=((-1.0)*x528);
evalcond[0]=(new_r11*x528);
evalcond[1]=(new_r00*x530);
evalcond[2]=(gconst2*x530);
evalcond[3]=(((gconst2*x529))+new_r11);
evalcond[4]=(gconst2+((new_r11*x529)));
evalcond[5]=((((-1.0)*gconst2))+((new_r00*x529)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x532 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x532.valid){
continue;
}
IkReal x531=((-1.0)*(x532.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x531;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst0=x531;
IkReal gconst1=0;
IkReal x533 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x533)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x533,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x535 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x535.valid){
continue;
}
IkReal x534=((-1.0)*(x535.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x534;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst0=x534;
IkReal gconst1=0;
IkReal x536 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x536)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x536,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x538 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x538.valid){
continue;
}
IkReal x537=((-1.0)*(x538.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x537;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst0=x537;
IkReal gconst1=0;
IkReal x539 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x539)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x539,-0.5)));
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x540=IKPowWithIntegerCheck(new_r10,-1);
if(!x540.valid){
continue;
}
CheckValue<IkReal> x541=IKPowWithIntegerCheck(gconst2,-1);
if(!x541.valid){
continue;
}
if( IKabs((gconst2*(x540.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x541.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst2*(x540.value)))+IKsqr(((-1.0)*new_r11*(x541.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((gconst2*(x540.value)), ((-1.0)*new_r11*(x541.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x542=IKsin(j1);
IkReal x543=IKcos(j1);
IkReal x544=(gconst2*x543);
IkReal x545=(gconst2*x542);
evalcond[0]=(new_r11*x542);
evalcond[1]=(new_r10*x543);
evalcond[2]=((-1.0)*x545);
evalcond[3]=((-1.0)*x544);
evalcond[4]=(x544+new_r11);
evalcond[5]=(gconst2+((new_r11*x543)));
evalcond[6]=((((-1.0)*x545))+new_r10);
evalcond[7]=(((new_r10*x542))+(((-1.0)*gconst2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x546=IKPowWithIntegerCheck(gconst2,-1);
if(!x546.valid){
continue;
}
CheckValue<IkReal> x547=IKPowWithIntegerCheck(new_r11,-1);
if(!x547.valid){
continue;
}
if( IKabs((new_r10*(x546.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst2*(x547.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x546.value)))+IKsqr(((-1.0)*gconst2*(x547.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x546.value)), ((-1.0)*gconst2*(x547.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x548=IKsin(j1);
IkReal x549=IKcos(j1);
IkReal x550=(gconst2*x549);
IkReal x551=(gconst2*x548);
evalcond[0]=(new_r11*x548);
evalcond[1]=(new_r10*x549);
evalcond[2]=((-1.0)*x551);
evalcond[3]=((-1.0)*x550);
evalcond[4]=(x550+new_r11);
evalcond[5]=(gconst2+((new_r11*x549)));
evalcond[6]=((((-1.0)*x551))+new_r10);
evalcond[7]=(((new_r10*x548))+(((-1.0)*gconst2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x552 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x552.valid){
continue;
}
CheckValue<IkReal> x553=IKPowWithIntegerCheck(IKsign(gconst2),-1);
if(!x553.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x552.value)+(((1.5707963267949)*(x553.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x554=IKsin(j1);
IkReal x555=IKcos(j1);
IkReal x556=(gconst2*x555);
IkReal x557=(gconst2*x554);
evalcond[0]=(new_r11*x554);
evalcond[1]=(new_r10*x555);
evalcond[2]=((-1.0)*x557);
evalcond[3]=((-1.0)*x556);
evalcond[4]=(x556+new_r11);
evalcond[5]=(((new_r11*x555))+gconst2);
evalcond[6]=((((-1.0)*x557))+new_r10);
evalcond[7]=(((new_r10*x554))+(((-1.0)*gconst2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x559 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x559.valid){
continue;
}
IkReal x558=((-1.0)*(x559.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x558;
new_r01=0;
IkReal gconst0=x558;
IkReal gconst1=0;
IkReal x560 = new_r11*new_r11;
if(IKabs(x560)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x560,-0.5)));
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x562 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x562.valid){
continue;
}
IkReal x561=((-1.0)*(x562.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x561;
new_r01=0;
IkReal gconst0=x561;
IkReal gconst1=0;
IkReal x563 = new_r11*new_r11;
if(IKabs(x563)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x563,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x565 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x565.valid){
continue;
}
IkReal x564=((-1.0)*(x565.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst1;
cj3=gconst2;
j3=x564;
new_r01=0;
IkReal gconst0=x564;
IkReal gconst1=0;
IkReal x566 = new_r11*new_r11;
if(IKabs(x566)==0){
continue;
}
IkReal gconst2=(new_r11*(pow(x566,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x567=IKPowWithIntegerCheck(gconst2,-1);
if(!x567.valid){
continue;
}
CheckValue<IkReal> x568=IKPowWithIntegerCheck(new_r11,-1);
if(!x568.valid){
continue;
}
if( IKabs((new_r10*(x567.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst2*(x568.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x567.value)))+IKsqr(((-1.0)*gconst2*(x568.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x567.value)), ((-1.0)*gconst2*(x568.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x569=IKsin(j1);
IkReal x570=IKcos(j1);
IkReal x571=(gconst2*x570);
IkReal x572=(gconst2*x569);
evalcond[0]=(new_r11*x569);
evalcond[1]=((-1.0)*x572);
evalcond[2]=(x571+new_r11);
evalcond[3]=(((new_r11*x570))+gconst2);
evalcond[4]=((((-1.0)*x572))+new_r10);
evalcond[5]=((((-1.0)*x571))+new_r00);
evalcond[6]=(((new_r10*x570))+(((-1.0)*new_r00*x569)));
evalcond[7]=(((new_r00*x570))+(((-1.0)*gconst2))+((new_r10*x569)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x573 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x573.valid){
continue;
}
CheckValue<IkReal> x574=IKPowWithIntegerCheck(IKsign(gconst2),-1);
if(!x574.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x573.value)+(((1.5707963267949)*(x574.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x575=IKsin(j1);
IkReal x576=IKcos(j1);
IkReal x577=(gconst2*x576);
IkReal x578=(gconst2*x575);
evalcond[0]=(new_r11*x575);
evalcond[1]=((-1.0)*x578);
evalcond[2]=(x577+new_r11);
evalcond[3]=(((new_r11*x576))+gconst2);
evalcond[4]=((((-1.0)*x578))+new_r10);
evalcond[5]=((((-1.0)*x577))+new_r00);
evalcond[6]=(((new_r10*x576))+(((-1.0)*new_r00*x575)));
evalcond[7]=(((new_r00*x576))+((new_r10*x575))+(((-1.0)*gconst2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x579=IKPowWithIntegerCheck(IKsign(gconst2),-1);
if(!x579.valid){
continue;
}
CheckValue<IkReal> x580 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x580.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x579.value)))+(x580.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x581=IKsin(j1);
IkReal x582=IKcos(j1);
IkReal x583=(gconst2*x582);
IkReal x584=(gconst2*x581);
evalcond[0]=(new_r11*x581);
evalcond[1]=((-1.0)*x584);
evalcond[2]=(x583+new_r11);
evalcond[3]=(gconst2+((new_r11*x582)));
evalcond[4]=((((-1.0)*x584))+new_r10);
evalcond[5]=((((-1.0)*x583))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x581))+((new_r10*x582)));
evalcond[7]=((((-1.0)*gconst2))+((new_r00*x582))+((new_r10*x581)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x585=((1.0)*new_r11);
CheckValue<IkReal> x586 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x585))+((gconst1*gconst2)))),IkReal(((new_r11*new_r11)+(((-1.0)*(gconst1*gconst1))))),IKFAST_ATAN2_MAGTHRESH);
if(!x586.valid){
continue;
}
CheckValue<IkReal> x587=IKPowWithIntegerCheck(IKsign((((gconst1*new_r01))+(((-1.0)*gconst2*x585)))),-1);
if(!x587.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x586.value)+(((1.5707963267949)*(x587.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x588=IKcos(j1);
IkReal x589=IKsin(j1);
IkReal x590=(gconst1*x588);
IkReal x591=(gconst2*x588);
IkReal x592=(gconst1*x589);
IkReal x593=((1.0)*x589);
IkReal x594=(gconst2*x593);
evalcond[0]=(gconst1+((new_r01*x588))+((new_r11*x589)));
evalcond[1]=(x592+x591+new_r11);
evalcond[2]=((((-1.0)*new_r00*x593))+gconst1+((new_r10*x588)));
evalcond[3]=(gconst2+(((-1.0)*new_r01*x593))+((new_r11*x588)));
evalcond[4]=((((-1.0)*x594))+x590+new_r01);
evalcond[5]=((((-1.0)*x594))+x590+new_r10);
evalcond[6]=((((-1.0)*gconst2))+((new_r00*x588))+((new_r10*x589)));
evalcond[7]=((((-1.0)*x592))+(((-1.0)*x591))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x595=((1.0)*new_r11);
CheckValue<IkReal> x596 = IKatan2WithCheck(IkReal((((gconst2*new_r01))+(((-1.0)*gconst1*x595)))),IkReal(((((-1.0)*gconst1*new_r01))+(((-1.0)*gconst2*x595)))),IKFAST_ATAN2_MAGTHRESH);
if(!x596.valid){
continue;
}
CheckValue<IkReal> x597=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x597.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x596.value)+(((1.5707963267949)*(x597.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x598=IKcos(j1);
IkReal x599=IKsin(j1);
IkReal x600=(gconst1*x598);
IkReal x601=(gconst2*x598);
IkReal x602=(gconst1*x599);
IkReal x603=((1.0)*x599);
IkReal x604=(gconst2*x603);
evalcond[0]=(((new_r11*x599))+gconst1+((new_r01*x598)));
evalcond[1]=(x602+x601+new_r11);
evalcond[2]=(((new_r10*x598))+gconst1+(((-1.0)*new_r00*x603)));
evalcond[3]=(((new_r11*x598))+gconst2+(((-1.0)*new_r01*x603)));
evalcond[4]=(x600+(((-1.0)*x604))+new_r01);
evalcond[5]=(x600+(((-1.0)*x604))+new_r10);
evalcond[6]=(((new_r10*x599))+((new_r00*x598))+(((-1.0)*gconst2)));
evalcond[7]=((((-1.0)*x601))+(((-1.0)*x602))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x605=((1.0)*gconst1);
CheckValue<IkReal> x606 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x605))+((gconst1*new_r01)))),IkReal(((((-1.0)*new_r11*x605))+(((-1.0)*new_r00*x605)))),IKFAST_ATAN2_MAGTHRESH);
if(!x606.valid){
continue;
}
CheckValue<IkReal> x607=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x607.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x606.value)+(((1.5707963267949)*(x607.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x608=IKcos(j1);
IkReal x609=IKsin(j1);
IkReal x610=(gconst1*x608);
IkReal x611=(gconst2*x608);
IkReal x612=(gconst1*x609);
IkReal x613=((1.0)*x609);
IkReal x614=(gconst2*x613);
evalcond[0]=(gconst1+((new_r11*x609))+((new_r01*x608)));
evalcond[1]=(x611+x612+new_r11);
evalcond[2]=(gconst1+((new_r10*x608))+(((-1.0)*new_r00*x613)));
evalcond[3]=(gconst2+((new_r11*x608))+(((-1.0)*new_r01*x613)));
evalcond[4]=((((-1.0)*x614))+x610+new_r01);
evalcond[5]=((((-1.0)*x614))+x610+new_r10);
evalcond[6]=((((-1.0)*gconst2))+((new_r10*x609))+((new_r00*x608)));
evalcond[7]=((((-1.0)*x611))+(((-1.0)*x612))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x616 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x616)==0){
continue;
}
IkReal x615=pow(x616,-0.5);
CheckValue<IkReal> x617 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x617.valid){
continue;
}
IkReal gconst3=((3.14159265358979)+(((-1.0)*(x617.value))));
IkReal gconst4=((1.0)*new_r01*x615);
IkReal gconst5=((-1.0)*new_r11*x615);
CheckValue<IkReal> x618 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x618.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x618.value)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x621 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x621.valid){
continue;
}
IkReal x619=((1.0)*(x621.value));
IkReal x620=x615;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x619)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x619)));
IkReal gconst4=((1.0)*new_r01*x620);
IkReal gconst5=((-1.0)*new_r11*x620);
IkReal x622=new_r01*new_r01;
IkReal x623=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x624=x615;
IkReal x625=((1.0)*new_r01*x624);
j1eval[0]=x623;
j1eval[1]=IKsign(x623);
j1eval[2]=((IKabs(((((-1.0)*new_r00*x625))+(((-1.0)*new_r11*x625)))))+(IKabs(((((-1.0)*new_r10*x625))+((x622*x624))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
CheckValue<IkReal> x628 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x628.valid){
continue;
}
IkReal x626=((1.0)*(x628.value));
IkReal x627=x615;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x626)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x626)));
IkReal gconst4=((1.0)*new_r01*x627);
IkReal gconst5=((-1.0)*new_r11*x627);
IkReal x629=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x629;
j1eval[1]=IKsign(x629);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x632 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x632.valid){
continue;
}
IkReal x630=((1.0)*(x632.value));
IkReal x631=x615;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x630)));
IkReal gconst3=((3.14159265358979)+(((-1.0)*x630)));
IkReal gconst4=((1.0)*new_r01*x631);
IkReal gconst5=((-1.0)*new_r11*x631);
IkReal x633=new_r01*new_r01;
IkReal x634=new_r11*new_r11;
IkReal x635=((1.0)*x633);
CheckValue<IkReal> x641=IKPowWithIntegerCheck((x634+x633),-1);
if(!x641.valid){
continue;
}
IkReal x636=x641.value;
CheckValue<IkReal> x642=IKPowWithIntegerCheck(((((-1.0)*x635))+(((-1.0)*x634))),-1);
if(!x642.valid){
continue;
}
IkReal x637=x642.value;
IkReal x638=((1.0)*x637);
IkReal x639=(new_r11*x638);
IkReal x640=(new_r01*x638);
j1eval[0]=((IKabs((((x636*(x634*x634)))+(((-1.0)*x635*x636))+((x633*x634*x636)))))+(IKabs(((((-1.0)*new_r01*x639*(new_r11*new_r11)))+(((-1.0)*new_r01*x639))+(((-1.0)*x639*(new_r01*new_r01*new_r01)))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x644 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x644.valid){
continue;
}
IkReal x643=((1.0)*(x644.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x643)));
new_r11=0;
new_r00=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x643)));
IkReal x645 = new_r01*new_r01;
if(IKabs(x645)==0){
continue;
}
IkReal gconst4=((1.0)*new_r01*(pow(x645,-0.5)));
IkReal gconst5=0;
j1eval[0]=new_r01;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x647 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x647.valid){
continue;
}
IkReal x646=((1.0)*(x647.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x646)));
new_r11=0;
new_r00=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x646)));
IkReal x648 = new_r01*new_r01;
if(IKabs(x648)==0){
continue;
}
IkReal gconst4=((1.0)*new_r01*(pow(x648,-0.5)));
IkReal gconst5=0;
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x649=IKPowWithIntegerCheck(gconst4,-1);
if(!x649.valid){
continue;
}
cj1array[0]=((-1.0)*new_r01*(x649.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x650=IKsin(j1);
IkReal x651=IKcos(j1);
evalcond[0]=(new_r10*x650);
evalcond[1]=(gconst4*x650);
evalcond[2]=((-1.0)*new_r01*x650);
evalcond[3]=(gconst4+((new_r01*x651)));
evalcond[4]=(gconst4+((new_r10*x651)));
evalcond[5]=(((gconst4*x651))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x652=IKPowWithIntegerCheck(new_r10,-1);
if(!x652.valid){
continue;
}
cj1array[0]=((-1.0)*gconst4*(x652.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x653=IKsin(j1);
IkReal x654=IKcos(j1);
IkReal x655=(gconst4*x654);
evalcond[0]=(new_r10*x653);
evalcond[1]=(gconst4*x653);
evalcond[2]=((-1.0)*new_r01*x653);
evalcond[3]=(gconst4+((new_r01*x654)));
evalcond[4]=(x655+new_r01);
evalcond[5]=(x655+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x656=IKPowWithIntegerCheck(new_r01,-1);
if(!x656.valid){
continue;
}
cj1array[0]=((-1.0)*gconst4*(x656.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x657=IKsin(j1);
IkReal x658=IKcos(j1);
IkReal x659=(gconst4*x658);
evalcond[0]=(new_r10*x657);
evalcond[1]=(gconst4*x657);
evalcond[2]=((-1.0)*new_r01*x657);
evalcond[3]=(gconst4+((new_r10*x658)));
evalcond[4]=(x659+new_r01);
evalcond[5]=(x659+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst4;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[4];
CheckValue<IkReal> x661 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x661.valid){
continue;
}
IkReal x660=((1.0)*(x661.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x660)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x660)));
IkReal gconst4=((1.0)*new_r01);
IkReal gconst5=((-1.0)*new_r11);
j1eval[0]=1.0;
j1eval[1]=1.0;
j1eval[2]=new_r01;
j1eval[3]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  || IKabs(j1eval[3]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x663 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x663.valid){
continue;
}
IkReal x662=((1.0)*(x663.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x662)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x662)));
IkReal gconst4=((1.0)*new_r01);
IkReal gconst5=((-1.0)*new_r11);
j1eval[0]=-1.0;
j1eval[1]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
j1eval[2]=-1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x665 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x665.valid){
continue;
}
IkReal x664=((1.0)*(x665.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x664)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x664)));
IkReal gconst4=((1.0)*new_r01);
IkReal gconst5=((-1.0)*new_r11);
j1eval[0]=1.0;
j1eval[1]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
j1eval[2]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x666=((1.0)*new_r11);
CheckValue<IkReal> x667 = IKatan2WithCheck(IkReal((((gconst5*new_r01))+(((-1.0)*gconst4*x666)))),IkReal(((((-1.0)*gconst4*new_r01))+(((-1.0)*gconst5*x666)))),IKFAST_ATAN2_MAGTHRESH);
if(!x667.valid){
continue;
}
CheckValue<IkReal> x668=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x668.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x667.value)+(((1.5707963267949)*(x668.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x669=IKcos(j1);
IkReal x670=IKsin(j1);
IkReal x671=(gconst4*x669);
IkReal x672=((1.0)*x670);
IkReal x673=(gconst5*x669);
IkReal x674=(gconst5*x672);
evalcond[0]=(((new_r11*x670))+gconst4+((new_r01*x669)));
evalcond[1]=(((gconst4*x670))+x673+new_r11);
evalcond[2]=(x671+(((-1.0)*x674)));
evalcond[3]=((((-1.0)*new_r01*x672))+gconst5+((new_r11*x669)));
evalcond[4]=(x671+new_r01+(((-1.0)*x674)));
evalcond[5]=((((-1.0)*gconst4*x672))+(((-1.0)*x673)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x675 = IKatan2WithCheck(IkReal((gconst4*new_r11)),IkReal((gconst5*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x675.valid){
continue;
}
CheckValue<IkReal> x676=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst4*gconst4)))+(((-1.0)*(gconst5*gconst5))))),-1);
if(!x676.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x675.value)+(((1.5707963267949)*(x676.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x677=IKcos(j1);
IkReal x678=IKsin(j1);
IkReal x679=(gconst4*x677);
IkReal x680=((1.0)*x678);
IkReal x681=(gconst5*x677);
IkReal x682=(gconst5*x680);
evalcond[0]=(((new_r11*x678))+((new_r01*x677))+gconst4);
evalcond[1]=(((gconst4*x678))+x681+new_r11);
evalcond[2]=((((-1.0)*x682))+x679);
evalcond[3]=(((new_r11*x677))+(((-1.0)*new_r01*x680))+gconst5);
evalcond[4]=((((-1.0)*x682))+x679+new_r01);
evalcond[5]=((((-1.0)*x681))+(((-1.0)*gconst4*x680)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x683 = IKatan2WithCheck(IkReal((gconst4*gconst5)),IkReal(((-1.0)*(gconst4*gconst4))),IKFAST_ATAN2_MAGTHRESH);
if(!x683.valid){
continue;
}
CheckValue<IkReal> x684=IKPowWithIntegerCheck(IKsign((((gconst4*new_r01))+(((-1.0)*gconst5*new_r11)))),-1);
if(!x684.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x683.value)+(((1.5707963267949)*(x684.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x685=IKcos(j1);
IkReal x686=IKsin(j1);
IkReal x687=(gconst4*x685);
IkReal x688=((1.0)*x686);
IkReal x689=(gconst5*x685);
IkReal x690=(gconst5*x688);
evalcond[0]=(gconst4+((new_r01*x685))+((new_r11*x686)));
evalcond[1]=(((gconst4*x686))+x689+new_r11);
evalcond[2]=(x687+(((-1.0)*x690)));
evalcond[3]=((((-1.0)*new_r01*x688))+gconst5+((new_r11*x685)));
evalcond[4]=(x687+(((-1.0)*x690))+new_r01);
evalcond[5]=((((-1.0)*x689))+(((-1.0)*gconst4*x688)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x691=IKPowWithIntegerCheck(gconst5,-1);
if(!x691.valid){
continue;
}
cj1array[0]=(new_r00*(x691.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x692=IKsin(j1);
IkReal x693=IKcos(j1);
IkReal x694=((-1.0)*x692);
evalcond[0]=(new_r11*x692);
evalcond[1]=(new_r00*x694);
evalcond[2]=(gconst5*x694);
evalcond[3]=(new_r11+((gconst5*x693)));
evalcond[4]=(gconst5+((new_r11*x693)));
evalcond[5]=((((-1.0)*gconst5))+((new_r00*x693)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x696 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x696.valid){
continue;
}
IkReal x695=((1.0)*(x696.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x695)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x695)));
IkReal gconst4=0;
IkReal x697 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x697)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x697,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x699 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x699.valid){
continue;
}
IkReal x698=((1.0)*(x699.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x698)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x698)));
IkReal gconst4=0;
IkReal x700 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x700)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x700,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x702 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x702.valid){
continue;
}
IkReal x701=((1.0)*(x702.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x701)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x701)));
IkReal gconst4=0;
IkReal x703 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x703)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x703,-0.5)));
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x704=IKPowWithIntegerCheck(new_r10,-1);
if(!x704.valid){
continue;
}
CheckValue<IkReal> x705=IKPowWithIntegerCheck(gconst5,-1);
if(!x705.valid){
continue;
}
if( IKabs((gconst5*(x704.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x705.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst5*(x704.value)))+IKsqr(((-1.0)*new_r11*(x705.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((gconst5*(x704.value)), ((-1.0)*new_r11*(x705.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x706=IKsin(j1);
IkReal x707=IKcos(j1);
IkReal x708=((1.0)*gconst5);
IkReal x709=((-1.0)*gconst5);
evalcond[0]=(new_r11*x706);
evalcond[1]=(new_r10*x707);
evalcond[2]=(x706*x709);
evalcond[3]=(x707*x709);
evalcond[4]=(((gconst5*x707))+new_r11);
evalcond[5]=(gconst5+((new_r11*x707)));
evalcond[6]=((((-1.0)*x706*x708))+new_r10);
evalcond[7]=((((-1.0)*x708))+((new_r10*x706)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x710=IKPowWithIntegerCheck(gconst5,-1);
if(!x710.valid){
continue;
}
CheckValue<IkReal> x711=IKPowWithIntegerCheck(new_r11,-1);
if(!x711.valid){
continue;
}
if( IKabs((new_r10*(x710.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst5*(x711.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x710.value)))+IKsqr(((-1.0)*gconst5*(x711.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x710.value)), ((-1.0)*gconst5*(x711.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x712=IKsin(j1);
IkReal x713=IKcos(j1);
IkReal x714=((1.0)*gconst5);
IkReal x715=((-1.0)*gconst5);
evalcond[0]=(new_r11*x712);
evalcond[1]=(new_r10*x713);
evalcond[2]=(x712*x715);
evalcond[3]=(x713*x715);
evalcond[4]=(((gconst5*x713))+new_r11);
evalcond[5]=(gconst5+((new_r11*x713)));
evalcond[6]=((((-1.0)*x712*x714))+new_r10);
evalcond[7]=((((-1.0)*x714))+((new_r10*x712)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x716 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x716.valid){
continue;
}
CheckValue<IkReal> x717=IKPowWithIntegerCheck(IKsign(gconst5),-1);
if(!x717.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x716.value)+(((1.5707963267949)*(x717.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x718=IKsin(j1);
IkReal x719=IKcos(j1);
IkReal x720=((1.0)*gconst5);
IkReal x721=((-1.0)*gconst5);
evalcond[0]=(new_r11*x718);
evalcond[1]=(new_r10*x719);
evalcond[2]=(x718*x721);
evalcond[3]=(x719*x721);
evalcond[4]=(((gconst5*x719))+new_r11);
evalcond[5]=(gconst5+((new_r11*x719)));
evalcond[6]=(new_r10+(((-1.0)*x718*x720)));
evalcond[7]=((((-1.0)*x720))+((new_r10*x718)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x723 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x723.valid){
continue;
}
IkReal x722=((1.0)*(x723.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x722)));
new_r01=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x722)));
IkReal gconst4=0;
IkReal x724 = new_r11*new_r11;
if(IKabs(x724)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x724,-0.5)));
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x726 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
IkReal x725=((1.0)*(x726.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x725)));
new_r01=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x725)));
IkReal gconst4=0;
IkReal x727 = new_r11*new_r11;
if(IKabs(x727)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x727,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x729 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x729.valid){
continue;
}
IkReal x728=((1.0)*(x729.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst4;
cj3=gconst5;
j3=((3.14159265)+(((-1.0)*x728)));
new_r01=0;
IkReal gconst3=((3.14159265358979)+(((-1.0)*x728)));
IkReal gconst4=0;
IkReal x730 = new_r11*new_r11;
if(IKabs(x730)==0){
continue;
}
IkReal gconst5=((-1.0)*new_r11*(pow(x730,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x731=IKPowWithIntegerCheck(gconst5,-1);
if(!x731.valid){
continue;
}
CheckValue<IkReal> x732=IKPowWithIntegerCheck(new_r11,-1);
if(!x732.valid){
continue;
}
if( IKabs((new_r10*(x731.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst5*(x732.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x731.value)))+IKsqr(((-1.0)*gconst5*(x732.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x731.value)), ((-1.0)*gconst5*(x732.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x733=IKsin(j1);
IkReal x734=IKcos(j1);
IkReal x735=((1.0)*gconst5);
evalcond[0]=(new_r11*x733);
evalcond[1]=((-1.0)*gconst5*x733);
evalcond[2]=(((gconst5*x734))+new_r11);
evalcond[3]=(gconst5+((new_r11*x734)));
evalcond[4]=((((-1.0)*x733*x735))+new_r10);
evalcond[5]=((((-1.0)*x734*x735))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x733))+((new_r10*x734)));
evalcond[7]=(((new_r00*x734))+(((-1.0)*x735))+((new_r10*x733)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x736 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x736.valid){
continue;
}
CheckValue<IkReal> x737=IKPowWithIntegerCheck(IKsign(gconst5),-1);
if(!x737.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x736.value)+(((1.5707963267949)*(x737.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x738=IKsin(j1);
IkReal x739=IKcos(j1);
IkReal x740=((1.0)*gconst5);
evalcond[0]=(new_r11*x738);
evalcond[1]=((-1.0)*gconst5*x738);
evalcond[2]=(((gconst5*x739))+new_r11);
evalcond[3]=(gconst5+((new_r11*x739)));
evalcond[4]=((((-1.0)*x738*x740))+new_r10);
evalcond[5]=((((-1.0)*x739*x740))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x738))+((new_r10*x739)));
evalcond[7]=(((new_r00*x739))+(((-1.0)*x740))+((new_r10*x738)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x741 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x741.valid){
continue;
}
CheckValue<IkReal> x742=IKPowWithIntegerCheck(IKsign(gconst5),-1);
if(!x742.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x741.value)+(((1.5707963267949)*(x742.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x743=IKsin(j1);
IkReal x744=IKcos(j1);
IkReal x745=((1.0)*gconst5);
evalcond[0]=(new_r11*x743);
evalcond[1]=((-1.0)*gconst5*x743);
evalcond[2]=(((gconst5*x744))+new_r11);
evalcond[3]=(gconst5+((new_r11*x744)));
evalcond[4]=(new_r10+(((-1.0)*x743*x745)));
evalcond[5]=((((-1.0)*x744*x745))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x743))+((new_r10*x744)));
evalcond[7]=(((new_r10*x743))+((new_r00*x744))+(((-1.0)*x745)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x746=((1.0)*new_r11);
CheckValue<IkReal> x747=IKPowWithIntegerCheck(IKsign((((gconst4*new_r01))+(((-1.0)*gconst5*x746)))),-1);
if(!x747.valid){
continue;
}
CheckValue<IkReal> x748 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x746))+((gconst4*gconst5)))),IkReal(((new_r11*new_r11)+(((-1.0)*(gconst4*gconst4))))),IKFAST_ATAN2_MAGTHRESH);
if(!x748.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x747.value)))+(x748.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x749=IKcos(j1);
IkReal x750=IKsin(j1);
IkReal x751=((1.0)*gconst5);
IkReal x752=(gconst4*x749);
IkReal x753=((1.0)*x750);
IkReal x754=(x750*x751);
evalcond[0]=(gconst4+((new_r11*x750))+((new_r01*x749)));
evalcond[1]=(((gconst5*x749))+new_r11+((gconst4*x750)));
evalcond[2]=(gconst4+(((-1.0)*new_r00*x753))+((new_r10*x749)));
evalcond[3]=((((-1.0)*new_r01*x753))+gconst5+((new_r11*x749)));
evalcond[4]=(x752+new_r01+(((-1.0)*x754)));
evalcond[5]=(x752+new_r10+(((-1.0)*x754)));
evalcond[6]=(((new_r10*x750))+((new_r00*x749))+(((-1.0)*x751)));
evalcond[7]=((((-1.0)*gconst4*x753))+new_r00+(((-1.0)*x749*x751)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x755=((1.0)*new_r11);
CheckValue<IkReal> x756=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x756.valid){
continue;
}
CheckValue<IkReal> x757 = IKatan2WithCheck(IkReal((((gconst5*new_r01))+(((-1.0)*gconst4*x755)))),IkReal(((((-1.0)*gconst4*new_r01))+(((-1.0)*gconst5*x755)))),IKFAST_ATAN2_MAGTHRESH);
if(!x757.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x756.value)))+(x757.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x758=IKcos(j1);
IkReal x759=IKsin(j1);
IkReal x760=((1.0)*gconst5);
IkReal x761=(gconst4*x758);
IkReal x762=((1.0)*x759);
IkReal x763=(x759*x760);
evalcond[0]=(gconst4+((new_r11*x759))+((new_r01*x758)));
evalcond[1]=(new_r11+((gconst5*x758))+((gconst4*x759)));
evalcond[2]=((((-1.0)*new_r00*x762))+gconst4+((new_r10*x758)));
evalcond[3]=(gconst5+((new_r11*x758))+(((-1.0)*new_r01*x762)));
evalcond[4]=((((-1.0)*x763))+x761+new_r01);
evalcond[5]=((((-1.0)*x763))+x761+new_r10);
evalcond[6]=((((-1.0)*x760))+((new_r00*x758))+((new_r10*x759)));
evalcond[7]=((((-1.0)*x758*x760))+(((-1.0)*gconst4*x762))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x764=((1.0)*gconst4);
CheckValue<IkReal> x765 = IKatan2WithCheck(IkReal((((gconst4*new_r01))+(((-1.0)*new_r10*x764)))),IkReal(((((-1.0)*new_r00*x764))+(((-1.0)*new_r11*x764)))),IKFAST_ATAN2_MAGTHRESH);
if(!x765.valid){
continue;
}
CheckValue<IkReal> x766=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x766.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x765.value)+(((1.5707963267949)*(x766.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x767=IKcos(j1);
IkReal x768=IKsin(j1);
IkReal x769=((1.0)*gconst5);
IkReal x770=(gconst4*x767);
IkReal x771=((1.0)*x768);
IkReal x772=(x768*x769);
evalcond[0]=(((new_r11*x768))+gconst4+((new_r01*x767)));
evalcond[1]=(new_r11+((gconst4*x768))+((gconst5*x767)));
evalcond[2]=(((new_r10*x767))+(((-1.0)*new_r00*x771))+gconst4);
evalcond[3]=(((new_r11*x767))+(((-1.0)*new_r01*x771))+gconst5);
evalcond[4]=(x770+(((-1.0)*x772))+new_r01);
evalcond[5]=(x770+(((-1.0)*x772))+new_r10);
evalcond[6]=(((new_r10*x768))+(((-1.0)*x769))+((new_r00*x767)));
evalcond[7]=((((-1.0)*gconst4*x771))+(((-1.0)*x767*x769))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r11=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x774 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x774.valid){
continue;
}
IkReal x773=x774.value;
j1array[0]=((-1.0)*x773);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x773)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j1))))+((new_r10*(IKcos(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x775=IKcos(j1);
IkReal x776=IKsin(j1);
IkReal x777=((1.0)*x776);
evalcond[0]=(x775+new_r11);
evalcond[1]=((((-1.0)*x777))+new_r01);
evalcond[2]=((((-1.0)*x777))+new_r10);
evalcond[3]=(new_r00+(((-1.0)*x775)));
evalcond[4]=(((new_r11*x776))+((new_r01*x775)));
evalcond[5]=((-1.0)+((new_r00*x775))+((new_r10*x776)));
evalcond[6]=((((-1.0)*new_r00*x777))+((new_r10*x775)));
evalcond[7]=((1.0)+(((-1.0)*new_r01*x777))+((new_r11*x775)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x778=IKsin(j1);
IkReal x779=IKcos(j1);
IkReal x780=((1.0)*x778);
evalcond[0]=(x778+new_r01);
evalcond[1]=(x778+new_r10);
evalcond[2]=(x779+new_r00);
evalcond[3]=(new_r11+(((-1.0)*x779)));
evalcond[4]=(((new_r11*x778))+((new_r01*x779)));
evalcond[5]=((1.0)+((new_r00*x779))+((new_r10*x778)));
evalcond[6]=(((new_r10*x779))+(((-1.0)*new_r00*x780)));
evalcond[7]=((-1.0)+(((-1.0)*new_r01*x780))+((new_r11*x779)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r11=0;
new_r00=0;
j1eval[0]=new_r01;
j1eval[1]=((IKabs(cj3))+(IKabs(sj3)));
j1eval[2]=IKsign(new_r01);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r11=0;
new_r00=0;
j1eval[0]=new_r01;
j1eval[1]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x781=IKPowWithIntegerCheck(new_r01,-1);
if(!x781.valid){
continue;
}
CheckValue<IkReal> x782=IKPowWithIntegerCheck(new_r10,-1);
if(!x782.valid){
continue;
}
if( IKabs((cj3*(x781.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj3*(x782.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj3*(x781.value)))+IKsqr(((-1.0)*sj3*(x782.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((cj3*(x781.value)), ((-1.0)*sj3*(x782.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x783=IKcos(j1);
IkReal x784=IKsin(j1);
IkReal x785=(sj3*x783);
IkReal x786=((1.0)*x784);
IkReal x787=(cj3*x786);
evalcond[0]=(sj3+((new_r01*x783)));
evalcond[1]=(sj3+((new_r10*x783)));
evalcond[2]=((((-1.0)*new_r01*x786))+cj3);
evalcond[3]=(((new_r10*x784))+(((-1.0)*cj3)));
evalcond[4]=(((cj3*x783))+((sj3*x784)));
evalcond[5]=((((-1.0)*x787))+x785+new_r01);
evalcond[6]=((((-1.0)*x787))+x785+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x788=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x788.valid){
continue;
}
CheckValue<IkReal> x789 = IKatan2WithCheck(IkReal(cj3),IkReal(((-1.0)*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x789.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x788.value)))+(x789.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x790=IKcos(j1);
IkReal x791=IKsin(j1);
IkReal x792=(sj3*x790);
IkReal x793=((1.0)*x791);
IkReal x794=(cj3*x793);
evalcond[0]=(sj3+((new_r01*x790)));
evalcond[1]=(sj3+((new_r10*x790)));
evalcond[2]=((((-1.0)*new_r01*x793))+cj3);
evalcond[3]=(((new_r10*x791))+(((-1.0)*cj3)));
evalcond[4]=(((cj3*x790))+((sj3*x791)));
evalcond[5]=((((-1.0)*x794))+x792+new_r01);
evalcond[6]=((((-1.0)*x794))+x792+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x796 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x796.valid){
continue;
}
IkReal x795=x796.value;
j1array[0]=((-1.0)*x795);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x795)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j1))))+((new_r10*(IKcos(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x798 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x798.valid){
continue;
}
IkReal x797=x798.value;
j1array[0]=((-1.0)*x797);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x797)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j1))))+(((-1.0)*new_r01*(IKsin(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r10=0;
j1eval[0]=new_r11;
j1eval[1]=IKsign(new_r11);
j1eval[2]=((IKabs(cj3))+(IKabs(sj3)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r10=0;
j1eval[0]=new_r00;
j1eval[1]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r10=0;
j1eval[0]=new_r11;
j1eval[1]=cj3;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
sj1array[0]=new_r00;
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x799=IKcos(j1);
IkReal x800=IKsin(j1);
evalcond[0]=x799;
evalcond[1]=(new_r00*x799);
evalcond[2]=(new_r11+x800);
evalcond[3]=(new_r11*x799);
evalcond[4]=((1.0)+((new_r11*x800)));
evalcond[5]=((1.0)+(((-1.0)*new_r00*x800)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
sj1array[0]=new_r11;
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x801=IKcos(j1);
IkReal x802=IKsin(j1);
evalcond[0]=(new_r00*x801);
evalcond[1]=(new_r11*x801);
evalcond[2]=((-1.0)*x801);
evalcond[3]=(new_r00+x802);
evalcond[4]=((-1.0)+((new_r11*x802)));
evalcond[5]=((-1.0)+(((-1.0)*new_r00*x802)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x804=IKPowWithIntegerCheck(new_r11,-1);
if(!x804.valid){
continue;
}
IkReal x803=x804.value;
CheckValue<IkReal> x805=IKPowWithIntegerCheck(cj3,-1);
if(!x805.valid){
continue;
}
CheckValue<IkReal> x806=IKPowWithIntegerCheck(x803,-2);
if(!x806.valid){
continue;
}
if( IKabs(((-1.0)*sj3*x803)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x803*(x805.value)*(((1.0)+(((-1.0)*(x806.value)))+(((-1.0)*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*sj3*x803))+IKsqr((x803*(x805.value)*(((1.0)+(((-1.0)*(x806.value)))+(((-1.0)*(cj3*cj3)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((-1.0)*sj3*x803), (x803*(x805.value)*(((1.0)+(((-1.0)*(x806.value)))+(((-1.0)*(cj3*cj3)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x807=IKsin(j1);
IkReal x808=IKcos(j1);
IkReal x809=((1.0)*cj3);
IkReal x810=(sj3*x807);
IkReal x811=(cj3*x808);
evalcond[0]=(sj3+((new_r11*x807)));
evalcond[1]=(cj3+((new_r11*x808)));
evalcond[2]=(sj3+(((-1.0)*new_r00*x807)));
evalcond[3]=(((new_r00*x808))+(((-1.0)*x809)));
evalcond[4]=(new_r11+x810+x811);
evalcond[5]=(((sj3*x808))+(((-1.0)*x807*x809)));
evalcond[6]=((((-1.0)*x810))+(((-1.0)*x808*x809))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x812=IKPowWithIntegerCheck(new_r00,-1);
if(!x812.valid){
continue;
}
CheckValue<IkReal> x813=IKPowWithIntegerCheck(new_r11,-1);
if(!x813.valid){
continue;
}
if( IKabs((sj3*(x812.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj3*(x813.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj3*(x812.value)))+IKsqr(((-1.0)*cj3*(x813.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((sj3*(x812.value)), ((-1.0)*cj3*(x813.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x814=IKsin(j1);
IkReal x815=IKcos(j1);
IkReal x816=((1.0)*cj3);
IkReal x817=(sj3*x814);
IkReal x818=(cj3*x815);
evalcond[0]=(sj3+((new_r11*x814)));
evalcond[1]=(cj3+((new_r11*x815)));
evalcond[2]=(sj3+(((-1.0)*new_r00*x814)));
evalcond[3]=(((new_r00*x815))+(((-1.0)*x816)));
evalcond[4]=(new_r11+x818+x817);
evalcond[5]=((((-1.0)*x814*x816))+((sj3*x815)));
evalcond[6]=((((-1.0)*x815*x816))+(((-1.0)*x817))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x819 = IKatan2WithCheck(IkReal(((-1.0)*sj3)),IkReal(((-1.0)*cj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x819.valid){
continue;
}
CheckValue<IkReal> x820=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x820.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x819.value)+(((1.5707963267949)*(x820.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x821=IKsin(j1);
IkReal x822=IKcos(j1);
IkReal x823=((1.0)*cj3);
IkReal x824=(sj3*x821);
IkReal x825=(cj3*x822);
evalcond[0]=(sj3+((new_r11*x821)));
evalcond[1]=(cj3+((new_r11*x822)));
evalcond[2]=(sj3+(((-1.0)*new_r00*x821)));
evalcond[3]=((((-1.0)*x823))+((new_r00*x822)));
evalcond[4]=(new_r11+x825+x824);
evalcond[5]=(((sj3*x822))+(((-1.0)*x821*x823)));
evalcond[6]=((((-1.0)*x822*x823))+(((-1.0)*x824))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x826 = IKatan2WithCheck(IkReal(((-1.0)+(cj3*cj3)+(new_r01*new_r01))),IkReal(((((-1.0)*cj3*sj3))+(((-1.0)*new_r01*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x826.valid){
continue;
}
CheckValue<IkReal> x827=IKPowWithIntegerCheck(IKsign((((new_r11*sj3))+((cj3*new_r01)))),-1);
if(!x827.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x826.value)+(((1.5707963267949)*(x827.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x828=IKcos(j1);
IkReal x829=IKsin(j1);
IkReal x830=(sj3*x828);
IkReal x831=((1.0)*x829);
IkReal x832=(cj3*x828);
IkReal x833=(cj3*x831);
evalcond[0]=(sj3+((new_r01*x828))+((new_r11*x829)));
evalcond[1]=(((sj3*x829))+new_r11+x832);
evalcond[2]=(sj3+((new_r10*x828))+(((-1.0)*new_r00*x831)));
evalcond[3]=(cj3+((new_r11*x828))+(((-1.0)*new_r01*x831)));
evalcond[4]=((((-1.0)*x833))+new_r01+x830);
evalcond[5]=((((-1.0)*x833))+new_r10+x830);
evalcond[6]=(((new_r10*x829))+((new_r00*x828))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*x832))+new_r00+(((-1.0)*sj3*x831)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x834=((1.0)*sj3);
CheckValue<IkReal> x835 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x834))+((cj3*new_r01)))),IkReal(((((-1.0)*cj3*new_r11))+(((-1.0)*new_r01*x834)))),IKFAST_ATAN2_MAGTHRESH);
if(!x835.valid){
continue;
}
CheckValue<IkReal> x836=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x836.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x835.value)+(((1.5707963267949)*(x836.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x837=IKcos(j1);
IkReal x838=IKsin(j1);
IkReal x839=(sj3*x837);
IkReal x840=((1.0)*x838);
IkReal x841=(cj3*x837);
IkReal x842=(cj3*x840);
evalcond[0]=(((new_r11*x838))+sj3+((new_r01*x837)));
evalcond[1]=(new_r11+x841+((sj3*x838)));
evalcond[2]=(sj3+((new_r10*x837))+(((-1.0)*new_r00*x840)));
evalcond[3]=(((new_r11*x837))+cj3+(((-1.0)*new_r01*x840)));
evalcond[4]=((((-1.0)*x842))+new_r01+x839);
evalcond[5]=((((-1.0)*x842))+new_r10+x839);
evalcond[6]=(((new_r00*x837))+(((-1.0)*cj3))+((new_r10*x838)));
evalcond[7]=((((-1.0)*sj3*x840))+(((-1.0)*x841))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x843=((1.0)*sj3);
CheckValue<IkReal> x844 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x843))+((new_r01*sj3)))),IkReal(((((-1.0)*new_r11*x843))+(((-1.0)*new_r00*x843)))),IKFAST_ATAN2_MAGTHRESH);
if(!x844.valid){
continue;
}
CheckValue<IkReal> x845=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x845.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x844.value)+(((1.5707963267949)*(x845.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x846=IKcos(j1);
IkReal x847=IKsin(j1);
IkReal x848=(sj3*x846);
IkReal x849=((1.0)*x847);
IkReal x850=(cj3*x846);
IkReal x851=(cj3*x849);
evalcond[0]=(sj3+((new_r01*x846))+((new_r11*x847)));
evalcond[1]=(new_r11+x850+((sj3*x847)));
evalcond[2]=(((new_r10*x846))+sj3+(((-1.0)*new_r00*x849)));
evalcond[3]=(cj3+(((-1.0)*new_r01*x849))+((new_r11*x846)));
evalcond[4]=((((-1.0)*x851))+new_r01+x848);
evalcond[5]=((((-1.0)*x851))+new_r10+x848);
evalcond[6]=(((new_r10*x847))+((new_r00*x846))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*sj3*x849))+(((-1.0)*x850))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x852=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj3*x852))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj3*x852))+((cj3*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x852))+(((-1.0)*new_r11*sj3))))+IKsqr(((((-1.0)*sj3*x852))+((cj3*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*cj3*x852))+(((-1.0)*new_r11*sj3))), ((((-1.0)*sj3*x852))+((cj3*new_r11))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x853=IKsin(j1);
IkReal x854=IKcos(j1);
IkReal x855=((1.0)*cj3);
IkReal x856=((1.0)*sj3);
IkReal x857=(sj3*x853);
IkReal x858=((1.0)*x853);
IkReal x859=(x854*x855);
evalcond[0]=(sj3+((new_r11*x853))+((new_r01*x854)));
evalcond[1]=(((sj3*x854))+((cj3*x853))+new_r01);
evalcond[2]=((((-1.0)*x859))+new_r11+x857);
evalcond[3]=((((-1.0)*x859))+new_r00+x857);
evalcond[4]=((((-1.0)*x855))+((new_r10*x853))+((new_r00*x854)));
evalcond[5]=((((-1.0)*x853*x855))+new_r10+(((-1.0)*x854*x856)));
evalcond[6]=((((-1.0)*x856))+(((-1.0)*new_r00*x858))+((new_r10*x854)));
evalcond[7]=((((-1.0)*x855))+(((-1.0)*new_r01*x858))+((new_r11*x854)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs((new_r10*new_r22)))+(IKabs((new_r00*new_r22))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x861 = IKatan2WithCheck(IkReal((new_r10*new_r22)),IkReal(((-1.0)*new_r00*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x861.valid){
continue;
}
IkReal x860=x861.value;
j1array[0]=((-1.0)*x860);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x860)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x862=IKcos(j1);
IkReal x863=IKsin(j1);
IkReal x864=(new_r11*x862);
IkReal x865=((1.0)*new_r01*x863);
evalcond[0]=(((new_r01*x862))+((new_r11*x863)));
evalcond[1]=(((new_r00*x862))+((new_r10*x863)));
evalcond[2]=((((-1.0)*new_r00*x863))+((new_r10*x862)));
evalcond[3]=((((-1.0)*x865))+x864);
evalcond[4]=((((-1.0)*new_r22*x865))+((new_r22*x864)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x867 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x867.valid){
continue;
}
IkReal x866=x867.value;
j1array[0]=((-1.0)*x866);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x866)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x868=IKcos(j1);
IkReal x869=IKsin(j1);
IkReal x870=(new_r22*x868);
IkReal x871=((1.0)*new_r01*x869);
IkReal x872=((1.0)*new_r00*x869);
evalcond[0]=(((new_r01*x868))+((new_r11*x869)));
evalcond[1]=(((new_r10*x868))+(((-1.0)*x872)));
evalcond[2]=(((new_r11*x868))+(((-1.0)*x871)));
evalcond[3]=((((-1.0)*new_r22*x872))+((new_r10*x870)));
evalcond[4]=((((-1.0)*new_r22*x871))+((new_r11*x870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x874 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x874.valid){
continue;
}
IkReal x873=x874.value;
j1array[0]=((-1.0)*x873);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x873)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x875=IKcos(j1);
IkReal x876=IKsin(j1);
IkReal x877=(new_r10*x875);
IkReal x878=(new_r11*x875);
IkReal x879=((1.0)*new_r01*x876);
IkReal x880=((1.0)*new_r00*x876);
evalcond[0]=(((new_r00*x875))+((new_r10*x876)));
evalcond[1]=((((-1.0)*x880))+x877);
evalcond[2]=(x878+(((-1.0)*x879)));
evalcond[3]=(((new_r22*x877))+(((-1.0)*new_r22*x880)));
evalcond[4]=((((-1.0)*new_r22*x879))+((new_r22*x878)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x882=IKPowWithIntegerCheck(cj2,-1);
if(!x882.valid){
continue;
}
IkReal x881=x882.value;
CheckValue<IkReal> x883=IKPowWithIntegerCheck(new_r11,-1);
if(!x883.valid){
continue;
}
if( IKabs((x881*(x883.value)*(((((-1.0)*cj2*sj3))+((new_r01*new_r12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x881)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x881*(x883.value)*(((((-1.0)*cj2*sj3))+((new_r01*new_r12))))))+IKsqr(((-1.0)*new_r12*x881))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x881*(x883.value)*(((((-1.0)*cj2*sj3))+((new_r01*new_r12))))), ((-1.0)*new_r12*x881));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[18];
IkReal x884=IKsin(j1);
IkReal x885=IKcos(j1);
IkReal x886=((1.0)*cj3);
IkReal x887=((1.0)*sj2);
IkReal x888=(sj2*sj3);
IkReal x889=(cj3*sj2);
IkReal x890=((1.0)*x884);
IkReal x891=(new_r10*x885);
IkReal x892=(new_r12*x885);
IkReal x893=(sj2*x884);
IkReal x894=(new_r11*x885);
evalcond[0]=(((cj2*x885))+new_r12);
evalcond[1]=((((-1.0)*cj2*x890))+new_r02);
evalcond[2]=(((new_r12*x884))+((new_r02*x885)));
evalcond[3]=(sj3+((new_r01*x885))+((new_r11*x884)));
evalcond[4]=(cj2+(((-1.0)*new_r02*x890))+x892);
evalcond[5]=(((sj3*x884))+new_r11+((x885*x889)));
evalcond[6]=(((new_r10*x884))+((new_r00*x885))+(((-1.0)*x886)));
evalcond[7]=(((sj3*x885))+new_r01+(((-1.0)*x886*x893)));
evalcond[8]=(new_r10+((x885*x888))+(((-1.0)*x884*x886)));
evalcond[9]=((((-1.0)*new_r00*x890))+x888+x891);
evalcond[10]=((((-1.0)*new_r01*x890))+x889+x894);
evalcond[11]=((((-1.0)*sj3*x884*x887))+new_r00+(((-1.0)*x885*x886)));
evalcond[12]=(((cj2*x891))+((new_r20*sj2))+(((-1.0)*cj2*new_r00*x890)));
evalcond[13]=(((cj2*x894))+(((-1.0)*cj2*new_r01*x890))+((new_r21*sj2)));
evalcond[14]=(((new_r02*x893))+((cj2*new_r22))+(((-1.0)*x887*x892)));
evalcond[15]=((1.0)+((cj2*x892))+((new_r22*sj2))+(((-1.0)*cj2*new_r02*x890)));
evalcond[16]=((((-1.0)*sj3))+((new_r00*x893))+((cj2*new_r20))+(((-1.0)*x887*x891)));
evalcond[17]=(((new_r01*x893))+(((-1.0)*x886))+((cj2*new_r21))+(((-1.0)*x887*x894)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x895=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x895.valid){
continue;
}
CheckValue<IkReal> x896 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x896.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x895.value)))+(x896.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[18];
IkReal x897=IKsin(j1);
IkReal x898=IKcos(j1);
IkReal x899=((1.0)*cj3);
IkReal x900=((1.0)*sj2);
IkReal x901=(sj2*sj3);
IkReal x902=(cj3*sj2);
IkReal x903=((1.0)*x897);
IkReal x904=(new_r10*x898);
IkReal x905=(new_r12*x898);
IkReal x906=(sj2*x897);
IkReal x907=(new_r11*x898);
evalcond[0]=(((cj2*x898))+new_r12);
evalcond[1]=(new_r02+(((-1.0)*cj2*x903)));
evalcond[2]=(((new_r12*x897))+((new_r02*x898)));
evalcond[3]=(sj3+((new_r11*x897))+((new_r01*x898)));
evalcond[4]=(cj2+(((-1.0)*new_r02*x903))+x905);
evalcond[5]=(((sj3*x897))+new_r11+((x898*x902)));
evalcond[6]=(((new_r00*x898))+((new_r10*x897))+(((-1.0)*x899)));
evalcond[7]=(((sj3*x898))+new_r01+(((-1.0)*x899*x906)));
evalcond[8]=((((-1.0)*x897*x899))+new_r10+((x898*x901)));
evalcond[9]=((((-1.0)*new_r00*x903))+x904+x901);
evalcond[10]=((((-1.0)*new_r01*x903))+x907+x902);
evalcond[11]=((((-1.0)*x898*x899))+(((-1.0)*sj3*x897*x900))+new_r00);
evalcond[12]=(((new_r20*sj2))+((cj2*x904))+(((-1.0)*cj2*new_r00*x903)));
evalcond[13]=(((cj2*x907))+(((-1.0)*cj2*new_r01*x903))+((new_r21*sj2)));
evalcond[14]=((((-1.0)*x900*x905))+((cj2*new_r22))+((new_r02*x906)));
evalcond[15]=((1.0)+((cj2*x905))+((new_r22*sj2))+(((-1.0)*cj2*new_r02*x903)));
evalcond[16]=((((-1.0)*x900*x904))+(((-1.0)*sj3))+((cj2*new_r20))+((new_r00*x906)));
evalcond[17]=((((-1.0)*x900*x907))+(((-1.0)*x899))+((cj2*new_r21))+((new_r01*x906)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j7;
vinfos[7].indices[0] = _ij7[0];
vinfos[7].indices[1] = _ij7[1];
vinfos[7].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - seednoid_eye_link (6db4b4d4c56b0e2dcd19cef272927236)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
