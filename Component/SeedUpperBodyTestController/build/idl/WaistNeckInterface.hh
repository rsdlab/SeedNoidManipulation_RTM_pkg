// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __WaistNeckInterface_hh__
#define __WaistNeckInterface_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_WaistNeckInterface
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_WaistNeckInterface
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_WaistNeckInterface
#endif



#ifndef __BasicDataType_hh_EXTERNAL_GUARD__
#define __BasicDataType_hh_EXTERNAL_GUARD__
#include "BasicDataType.hh"
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE WaistNeck

_CORBA_MODULE_BEG

  struct RETURN_ID {
    typedef _CORBA_ConstrType_Variable_Var<RETURN_ID> _var_type;

    
    ::CORBA::Long id;

    ::CORBA::String_member comment;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef RETURN_ID::_var_type RETURN_ID_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< RETURN_ID,RETURN_ID_var > RETURN_ID_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_RETURN_ID;

  struct LimitValue {
    typedef _CORBA_ConstrType_Fix_Var<LimitValue> _var_type;

    
    ::CORBA::Double upper;

    ::CORBA::Double lower;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef LimitValue::_var_type LimitValue_var;

  typedef LimitValue& LimitValue_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LimitValue;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DoubleSeq;

  class DoubleSeq_var;

  class DoubleSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef DoubleSeq_var _var_type;
    inline DoubleSeq() {}
    inline DoubleSeq(const DoubleSeq& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline DoubleSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline DoubleSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline DoubleSeq& operator = (const DoubleSeq& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DoubleSeq_out;

  class DoubleSeq_var {
  public:
    inline DoubleSeq_var() : _pd_seq(0) {}
    inline DoubleSeq_var(DoubleSeq* _s) : _pd_seq(_s) {}
    inline DoubleSeq_var(const DoubleSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new DoubleSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~DoubleSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline DoubleSeq_var& operator = (DoubleSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DoubleSeq_var& operator = (const DoubleSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new DoubleSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DoubleSeq* operator -> () { return _pd_seq; }
    inline const DoubleSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DoubleSeq& () const { return *_pd_seq; }
#else
    inline operator const DoubleSeq& () const { return *_pd_seq; }
    inline operator DoubleSeq& () { return *_pd_seq; }
#endif
      
    inline const DoubleSeq& in() const { return *_pd_seq; }
    inline DoubleSeq&       inout()    { return *_pd_seq; }
    inline DoubleSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DoubleSeq* _retn() { DoubleSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DoubleSeq_out;
    
  private:
    DoubleSeq* _pd_seq;
  };

  class DoubleSeq_out {
  public:
    inline DoubleSeq_out(DoubleSeq*& _s) : _data(_s) { _data = 0; }
    inline DoubleSeq_out(DoubleSeq_var& _s)
      : _data(_s._pd_seq) { _s = (DoubleSeq*) 0; }
    inline DoubleSeq_out(const DoubleSeq_out& _s) : _data(_s._data) {}
    inline DoubleSeq_out& operator = (const DoubleSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DoubleSeq_out& operator = (DoubleSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator DoubleSeq*&()  { return _data; }
    inline DoubleSeq*& ptr()       { return _data; }
    inline DoubleSeq* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DoubleSeq*& _data;

  private:
    DoubleSeq_out();
    DoubleSeq_out& operator=(const DoubleSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NeckPos;

  class NeckPos_var;

  class NeckPos : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef NeckPos_var _var_type;
    inline NeckPos() {}
    inline NeckPos(const NeckPos& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline NeckPos(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline NeckPos(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline NeckPos& operator = (const NeckPos& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class NeckPos_out;

  class NeckPos_var {
  public:
    inline NeckPos_var() : _pd_seq(0) {}
    inline NeckPos_var(NeckPos* _s) : _pd_seq(_s) {}
    inline NeckPos_var(const NeckPos_var& _s) {
      if( _s._pd_seq )  _pd_seq = new NeckPos(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~NeckPos_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline NeckPos_var& operator = (NeckPos* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline NeckPos_var& operator = (const NeckPos_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new NeckPos;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline NeckPos* operator -> () { return _pd_seq; }
    inline const NeckPos* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator NeckPos& () const { return *_pd_seq; }
#else
    inline operator const NeckPos& () const { return *_pd_seq; }
    inline operator NeckPos& () { return *_pd_seq; }
#endif
      
    inline const NeckPos& in() const { return *_pd_seq; }
    inline NeckPos&       inout()    { return *_pd_seq; }
    inline NeckPos*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline NeckPos* _retn() { NeckPos* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class NeckPos_out;
    
  private:
    NeckPos* _pd_seq;
  };

  class NeckPos_out {
  public:
    inline NeckPos_out(NeckPos*& _s) : _data(_s) { _data = 0; }
    inline NeckPos_out(NeckPos_var& _s)
      : _data(_s._pd_seq) { _s = (NeckPos*) 0; }
    inline NeckPos_out(const NeckPos_out& _s) : _data(_s._data) {}
    inline NeckPos_out& operator = (const NeckPos_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline NeckPos_out& operator = (NeckPos* _s) {
      _data = _s;
      return *this;
    }
    inline operator NeckPos*&()  { return _data; }
    inline NeckPos*& ptr()       { return _data; }
    inline NeckPos* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    NeckPos*& _data;

  private:
    NeckPos_out();
    NeckPos_out& operator=(const NeckPos_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WaistPos;

  class WaistPos_var;

  class WaistPos : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef WaistPos_var _var_type;
    inline WaistPos() {}
    inline WaistPos(const WaistPos& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline WaistPos(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline WaistPos(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline WaistPos& operator = (const WaistPos& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class WaistPos_out;

  class WaistPos_var {
  public:
    inline WaistPos_var() : _pd_seq(0) {}
    inline WaistPos_var(WaistPos* _s) : _pd_seq(_s) {}
    inline WaistPos_var(const WaistPos_var& _s) {
      if( _s._pd_seq )  _pd_seq = new WaistPos(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~WaistPos_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline WaistPos_var& operator = (WaistPos* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline WaistPos_var& operator = (const WaistPos_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new WaistPos;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline WaistPos* operator -> () { return _pd_seq; }
    inline const WaistPos* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator WaistPos& () const { return *_pd_seq; }
#else
    inline operator const WaistPos& () const { return *_pd_seq; }
    inline operator WaistPos& () { return *_pd_seq; }
#endif
      
    inline const WaistPos& in() const { return *_pd_seq; }
    inline WaistPos&       inout()    { return *_pd_seq; }
    inline WaistPos*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline WaistPos* _retn() { WaistPos* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class WaistPos_out;
    
  private:
    WaistPos* _pd_seq;
  };

  class WaistPos_out {
  public:
    inline WaistPos_out(WaistPos*& _s) : _data(_s) { _data = 0; }
    inline WaistPos_out(WaistPos_var& _s)
      : _data(_s._pd_seq) { _s = (WaistPos*) 0; }
    inline WaistPos_out(const WaistPos_out& _s) : _data(_s._data) {}
    inline WaistPos_out& operator = (const WaistPos_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline WaistPos_out& operator = (WaistPos* _s) {
      _data = _s;
      return *this;
    }
    inline operator WaistPos*&()  { return _data; }
    inline WaistPos*& ptr()       { return _data; }
    inline WaistPos* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    WaistPos*& _data;

  private:
    WaistPos_out();
    WaistPos_out& operator=(const WaistPos_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LimitSeq;

  class LimitSeq_var;

  class LimitSeq : public _CORBA_Unbounded_Sequence< LimitValue >  {
  public:
    typedef LimitSeq_var _var_type;
    inline LimitSeq() {}
    inline LimitSeq(const LimitSeq& _s)
      : _CORBA_Unbounded_Sequence< LimitValue > (_s) {}

    inline LimitSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< LimitValue > (_max) {}
    inline LimitSeq(_CORBA_ULong _max, _CORBA_ULong _len, LimitValue* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< LimitValue > (_max, _len, _val, _rel) {}

  

    inline LimitSeq& operator = (const LimitSeq& _s) {
      _CORBA_Unbounded_Sequence< LimitValue > ::operator=(_s);
      return *this;
    }
  };

  class LimitSeq_out;

  class LimitSeq_var {
  public:
    inline LimitSeq_var() : _pd_seq(0) {}
    inline LimitSeq_var(LimitSeq* _s) : _pd_seq(_s) {}
    inline LimitSeq_var(const LimitSeq_var& _s) {
      if( _s._pd_seq )  _pd_seq = new LimitSeq(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~LimitSeq_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline LimitSeq_var& operator = (LimitSeq* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LimitSeq_var& operator = (const LimitSeq_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new LimitSeq;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline LimitValue& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LimitSeq* operator -> () { return _pd_seq; }
    inline const LimitSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LimitSeq& () const { return *_pd_seq; }
#else
    inline operator const LimitSeq& () const { return *_pd_seq; }
    inline operator LimitSeq& () { return *_pd_seq; }
#endif
      
    inline const LimitSeq& in() const { return *_pd_seq; }
    inline LimitSeq&       inout()    { return *_pd_seq; }
    inline LimitSeq*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LimitSeq* _retn() { LimitSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LimitSeq_out;
    
  private:
    LimitSeq* _pd_seq;
  };

  class LimitSeq_out {
  public:
    inline LimitSeq_out(LimitSeq*& _s) : _data(_s) { _data = 0; }
    inline LimitSeq_out(LimitSeq_var& _s)
      : _data(_s._pd_seq) { _s = (LimitSeq*) 0; }
    inline LimitSeq_out(const LimitSeq_out& _s) : _data(_s._data) {}
    inline LimitSeq_out& operator = (const LimitSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LimitSeq_out& operator = (LimitSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator LimitSeq*&()  { return _data; }
    inline LimitSeq*& ptr()       { return _data; }
    inline LimitSeq* operator->() { return _data; }

    inline LimitValue& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LimitSeq*& _data;

  private:
    LimitSeq_out();
    LimitSeq_out& operator=(const LimitSeq_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ULONG;

  typedef ::CORBA::ULong ULONG;
  typedef ::CORBA::ULong_out ULONG_out;

  struct ManipInfo {
    typedef _CORBA_ConstrType_Variable_Var<ManipInfo> _var_type;

    
    ::CORBA::String_member manufactur;

    ::CORBA::String_member type;

    ULONG axisNum;

    ULONG cmdCycle;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ManipInfo::_var_type ManipInfo_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ManipInfo,ManipInfo_var > ManipInfo_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ManipInfo;

  _CORBA_MODULE_VARINT const ::CORBA::ULong CONST_BINARY_00000001 _init_in_decl_( = 1U );

  _CORBA_MODULE_VARINT const ::CORBA::ULong CONST_BINARY_00000010 _init_in_decl_( = 2U );

  _CORBA_MODULE_VARINT const ::CORBA::ULong CONST_BINARY_00000100 _init_in_decl_( = 4U );

  _CORBA_MODULE_VARINT const ::CORBA::ULong CONST_BINARY_00001000 _init_in_decl_( = 8U );

  _CORBA_MODULE_VARINT const ::CORBA::Long OK _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Long NG _init_in_decl_( = -1 );

  _CORBA_MODULE_VARINT const ::CORBA::Long STATUS_ERR _init_in_decl_( = -2 );

  _CORBA_MODULE_VARINT const ::CORBA::Long VALUE_ERR _init_in_decl_( = -3 );

  _CORBA_MODULE_VARINT const ::CORBA::Long NOT_SV_ON_ERR _init_in_decl_( = -4 );

  _CORBA_MODULE_VARINT const ::CORBA::Long FULL_MOTION_QUEUE_ERR _init_in_decl_( = -5 );

  _CORBA_MODULE_VARINT const ::CORBA::Long NOT_IMPLEMENTED _init_in_decl_( = -6 );

#ifndef __WaistNeck_mNeckInterface__
#define __WaistNeck_mNeckInterface__

  class NeckInterface;
  class _objref_NeckInterface;
  class _impl_NeckInterface;
  
  typedef _objref_NeckInterface* NeckInterface_ptr;
  typedef NeckInterface_ptr NeckInterfaceRef;

  class NeckInterface_Helper {
  public:
    typedef NeckInterface_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_NeckInterface, NeckInterface_Helper> NeckInterface_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_NeckInterface,NeckInterface_Helper > NeckInterface_out;

#endif

  // interface NeckInterface
  class NeckInterface {
  public:
    // Declarations for this interface type.
    typedef NeckInterface_ptr _ptr_type;
    typedef NeckInterface_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_NeckInterface :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    RETURN_ID* getFeedbackPosNeck(::WaistNeck::NeckPos_out pos);
    RETURN_ID* getNeckInfo(::WaistNeck::ManipInfo_out mInfo);
    RETURN_ID* getSoftLimitNeck(::WaistNeck::LimitSeq_out softLimit);
    RETURN_ID* getState(::WaistNeck::ULONG& state);
    RETURN_ID* servoOFF();
    RETURN_ID* servoON();
    RETURN_ID* setSoftLimitNeck(const ::WaistNeck::LimitSeq& softLimit);
    RETURN_ID* getMaxSpeedNeck(::WaistNeck::DoubleSeq_out speed);
    RETURN_ID* getMinAccelTimeNeck(::CORBA::Double& aclTime);
    RETURN_ID* movePTPNeckAbs(const ::WaistNeck::NeckPos& neckPoints);
    RETURN_ID* movePTPNeckRel(const ::WaistNeck::NeckPos& neckPoints);
    RETURN_ID* pause();
    RETURN_ID* resume();
    RETURN_ID* stop();
    RETURN_ID* setAccelTimeNeck(::CORBA::Double aclTime);
    RETURN_ID* setMaxSpeedNeck(const ::WaistNeck::DoubleSeq& speed);
    RETURN_ID* setMinAccelTimeNeck(::CORBA::Double aclTime);
    RETURN_ID* setSpeedNeck(::WaistNeck::ULONG spdRatio);
    RETURN_ID* getSpeedNeck(::WaistNeck::ULONG& spdRatio);
    RETURN_ID* movePTPNeckAbsCmdCycle(const ::WaistNeck::NeckPos& neckPoints);
    RETURN_ID* movePTPNeckRelCmdCycle(const ::WaistNeck::NeckPos& neckPoints);

    inline _objref_NeckInterface()  { _PR_setobj(0); }  // nil
    _objref_NeckInterface(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_NeckInterface();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_NeckInterface(const _objref_NeckInterface&);
    _objref_NeckInterface& operator = (const _objref_NeckInterface&);
    // not implemented

    friend class NeckInterface;
  };

  class _pof_NeckInterface : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_NeckInterface() : _OMNI_NS(proxyObjectFactory)(NeckInterface::_PD_repoId) {}
    virtual ~_pof_NeckInterface();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_NeckInterface :
    public virtual omniServant
  {
  public:
    virtual ~_impl_NeckInterface();

    virtual RETURN_ID* getFeedbackPosNeck(::WaistNeck::NeckPos_out pos) = 0;
    virtual RETURN_ID* getNeckInfo(::WaistNeck::ManipInfo_out mInfo) = 0;
    virtual RETURN_ID* getSoftLimitNeck(::WaistNeck::LimitSeq_out softLimit) = 0;
    virtual RETURN_ID* getState(::WaistNeck::ULONG& state) = 0;
    virtual RETURN_ID* servoOFF() = 0;
    virtual RETURN_ID* servoON() = 0;
    virtual RETURN_ID* setSoftLimitNeck(const ::WaistNeck::LimitSeq& softLimit) = 0;
    virtual RETURN_ID* getMaxSpeedNeck(::WaistNeck::DoubleSeq_out speed) = 0;
    virtual RETURN_ID* getMinAccelTimeNeck(::CORBA::Double& aclTime) = 0;
    virtual RETURN_ID* movePTPNeckAbs(const ::WaistNeck::NeckPos& neckPoints) = 0;
    virtual RETURN_ID* movePTPNeckRel(const ::WaistNeck::NeckPos& neckPoints) = 0;
    virtual RETURN_ID* pause() = 0;
    virtual RETURN_ID* resume() = 0;
    virtual RETURN_ID* stop() = 0;
    virtual RETURN_ID* setAccelTimeNeck(::CORBA::Double aclTime) = 0;
    virtual RETURN_ID* setMaxSpeedNeck(const ::WaistNeck::DoubleSeq& speed) = 0;
    virtual RETURN_ID* setMinAccelTimeNeck(::CORBA::Double aclTime) = 0;
    virtual RETURN_ID* setSpeedNeck(::WaistNeck::ULONG spdRatio) = 0;
    virtual RETURN_ID* getSpeedNeck(::WaistNeck::ULONG& spdRatio) = 0;
    virtual RETURN_ID* movePTPNeckAbsCmdCycle(const ::WaistNeck::NeckPos& neckPoints) = 0;
    virtual RETURN_ID* movePTPNeckRelCmdCycle(const ::WaistNeck::NeckPos& neckPoints) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NeckInterface;

#ifndef __WaistNeck_mWaistInterface__
#define __WaistNeck_mWaistInterface__

  class WaistInterface;
  class _objref_WaistInterface;
  class _impl_WaistInterface;
  
  typedef _objref_WaistInterface* WaistInterface_ptr;
  typedef WaistInterface_ptr WaistInterfaceRef;

  class WaistInterface_Helper {
  public:
    typedef WaistInterface_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_WaistInterface, WaistInterface_Helper> WaistInterface_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_WaistInterface,WaistInterface_Helper > WaistInterface_out;

#endif

  // interface WaistInterface
  class WaistInterface {
  public:
    // Declarations for this interface type.
    typedef WaistInterface_ptr _ptr_type;
    typedef WaistInterface_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_WaistInterface :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    RETURN_ID* getFeedbackPosWaist(::WaistNeck::WaistPos_out pos);
    RETURN_ID* getWaistInfo(::WaistNeck::ManipInfo_out mInfo);
    RETURN_ID* getSoftLimitWaist(::WaistNeck::LimitSeq_out softLimit);
    RETURN_ID* getState(::WaistNeck::ULONG& state);
    RETURN_ID* servoOFF();
    RETURN_ID* servoON();
    RETURN_ID* setSoftLimitWaist(const ::WaistNeck::LimitSeq& softLimit);
    RETURN_ID* getMaxSpeedWaist(::WaistNeck::DoubleSeq_out speed);
    RETURN_ID* getMinAccelTimeWaist(::CORBA::Double& aclTime);
    RETURN_ID* movePTPWaistAbs(const ::WaistNeck::WaistPos& waistPoints);
    RETURN_ID* movePTPWaistRel(const ::WaistNeck::WaistPos& waistPoints);
    RETURN_ID* pause();
    RETURN_ID* resume();
    RETURN_ID* stop();
    RETURN_ID* setAccelTimeWaist(::CORBA::Double aclTime);
    RETURN_ID* setMaxSpeedWaist(const ::WaistNeck::DoubleSeq& speed);
    RETURN_ID* setMinAccelTimeWaist(::CORBA::Double aclTime);
    RETURN_ID* setSpeedWaist(::WaistNeck::ULONG spdRatio);
    RETURN_ID* getSpeedWaist(::WaistNeck::ULONG& spdRatio);
    RETURN_ID* movePTPWaistAbsCmdCycle(const ::WaistNeck::WaistPos& waistPoints);
    RETURN_ID* movePTPWaistRelCmdCycle(const ::WaistNeck::WaistPos& waistPoints);

    inline _objref_WaistInterface()  { _PR_setobj(0); }  // nil
    _objref_WaistInterface(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_WaistInterface();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_WaistInterface(const _objref_WaistInterface&);
    _objref_WaistInterface& operator = (const _objref_WaistInterface&);
    // not implemented

    friend class WaistInterface;
  };

  class _pof_WaistInterface : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_WaistInterface() : _OMNI_NS(proxyObjectFactory)(WaistInterface::_PD_repoId) {}
    virtual ~_pof_WaistInterface();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_WaistInterface :
    public virtual omniServant
  {
  public:
    virtual ~_impl_WaistInterface();

    virtual RETURN_ID* getFeedbackPosWaist(::WaistNeck::WaistPos_out pos) = 0;
    virtual RETURN_ID* getWaistInfo(::WaistNeck::ManipInfo_out mInfo) = 0;
    virtual RETURN_ID* getSoftLimitWaist(::WaistNeck::LimitSeq_out softLimit) = 0;
    virtual RETURN_ID* getState(::WaistNeck::ULONG& state) = 0;
    virtual RETURN_ID* servoOFF() = 0;
    virtual RETURN_ID* servoON() = 0;
    virtual RETURN_ID* setSoftLimitWaist(const ::WaistNeck::LimitSeq& softLimit) = 0;
    virtual RETURN_ID* getMaxSpeedWaist(::WaistNeck::DoubleSeq_out speed) = 0;
    virtual RETURN_ID* getMinAccelTimeWaist(::CORBA::Double& aclTime) = 0;
    virtual RETURN_ID* movePTPWaistAbs(const ::WaistNeck::WaistPos& waistPoints) = 0;
    virtual RETURN_ID* movePTPWaistRel(const ::WaistNeck::WaistPos& waistPoints) = 0;
    virtual RETURN_ID* pause() = 0;
    virtual RETURN_ID* resume() = 0;
    virtual RETURN_ID* stop() = 0;
    virtual RETURN_ID* setAccelTimeWaist(::CORBA::Double aclTime) = 0;
    virtual RETURN_ID* setMaxSpeedWaist(const ::WaistNeck::DoubleSeq& speed) = 0;
    virtual RETURN_ID* setMinAccelTimeWaist(::CORBA::Double aclTime) = 0;
    virtual RETURN_ID* setSpeedWaist(::WaistNeck::ULONG spdRatio) = 0;
    virtual RETURN_ID* getSpeedWaist(::WaistNeck::ULONG& spdRatio) = 0;
    virtual RETURN_ID* movePTPWaistAbsCmdCycle(const ::WaistNeck::WaistPos& waistPoints) = 0;
    virtual RETURN_ID* movePTPWaistRelCmdCycle(const ::WaistNeck::WaistPos& waistPoints) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WaistInterface;

_CORBA_MODULE_END



_CORBA_MODULE POA_WaistNeck
_CORBA_MODULE_BEG

  class NeckInterface :
    public virtual WaistNeck::_impl_NeckInterface,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~NeckInterface();

    inline ::WaistNeck::NeckInterface_ptr _this() {
      return (::WaistNeck::NeckInterface_ptr) _do_this(::WaistNeck::NeckInterface::_PD_repoId);
    }
  };

  class WaistInterface :
    public virtual WaistNeck::_impl_WaistInterface,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~WaistInterface();

    inline ::WaistNeck::WaistInterface_ptr _this() {
      return (::WaistNeck::WaistInterface_ptr) _do_this(::WaistNeck::WaistInterface::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_WaistNeck
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const WaistNeck::RETURN_ID& _s);
extern void operator<<=(::CORBA::Any& _a, WaistNeck::RETURN_ID* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, WaistNeck::RETURN_ID*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const WaistNeck::RETURN_ID*& _sp);

extern void operator<<=(::CORBA::Any& _a, const WaistNeck::LimitValue& _s);
extern void operator<<=(::CORBA::Any& _a, WaistNeck::LimitValue* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, WaistNeck::LimitValue*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const WaistNeck::LimitValue*& _sp);

void operator<<=(::CORBA::Any& _a, const WaistNeck::DoubleSeq& _s);
void operator<<=(::CORBA::Any& _a, WaistNeck::DoubleSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, WaistNeck::DoubleSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const WaistNeck::DoubleSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const WaistNeck::NeckPos& _s);
void operator<<=(::CORBA::Any& _a, WaistNeck::NeckPos* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, WaistNeck::NeckPos*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const WaistNeck::NeckPos*& _sp);

void operator<<=(::CORBA::Any& _a, const WaistNeck::WaistPos& _s);
void operator<<=(::CORBA::Any& _a, WaistNeck::WaistPos* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, WaistNeck::WaistPos*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const WaistNeck::WaistPos*& _sp);

void operator<<=(::CORBA::Any& _a, const WaistNeck::LimitSeq& _s);
void operator<<=(::CORBA::Any& _a, WaistNeck::LimitSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, WaistNeck::LimitSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const WaistNeck::LimitSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const WaistNeck::ManipInfo& _s);
extern void operator<<=(::CORBA::Any& _a, WaistNeck::ManipInfo* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, WaistNeck::ManipInfo*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const WaistNeck::ManipInfo*& _sp);

void operator<<=(::CORBA::Any& _a, WaistNeck::NeckInterface_ptr _s);
void operator<<=(::CORBA::Any& _a, WaistNeck::NeckInterface_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, WaistNeck::NeckInterface_ptr& _s);

void operator<<=(::CORBA::Any& _a, WaistNeck::WaistInterface_ptr _s);
void operator<<=(::CORBA::Any& _a, WaistNeck::WaistInterface_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, WaistNeck::WaistInterface_ptr& _s);



inline void
WaistNeck::NeckInterface::_marshalObjRef(::WaistNeck::NeckInterface_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
WaistNeck::WaistInterface::_marshalObjRef(::WaistNeck::WaistInterface_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_WaistNeckInterface
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_WaistNeckInterface
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_WaistNeckInterface
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_WaistNeckInterface
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_WaistNeckInterface
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_WaistNeckInterface
#endif

#endif  // __WaistNeckInterface_hh__

