// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "SeedNoid_Lifter.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_SeedNoid__Lifter_mLifterAngle[] = {
  {"top", CORBA::TypeCode::PR_double_tc()},
  {"bottom", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_SeedNoid__Lifter_mLifterAngle
#  undef _0RL_tc_SeedNoid__Lifter_mLifterAngle
#endif
static CORBA::TypeCode_ptr _0RL_tc_SeedNoid__Lifter_mLifterAngle = CORBA::TypeCode::PR_struct_tc("IDL:SeedNoid_Lifter/LifterAngle:1.0", "LifterAngle", _0RL_structmember_SeedNoid__Lifter_mLifterAngle, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SeedNoid_Lifter { 
  const ::CORBA::TypeCode_ptr _tc_LifterAngle = _0RL_tc_SeedNoid__Lifter_mLifterAngle;
} 
#else
const ::CORBA::TypeCode_ptr SeedNoid_Lifter::_tc_LifterAngle = _0RL_tc_SeedNoid__Lifter_mLifterAngle;
#endif


static CORBA::PR_structMember _0RL_structmember_SeedNoid__Lifter_mLimitValue[] = {
  {"upper", CORBA::TypeCode::PR_double_tc()},
  {"lower", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_SeedNoid__Lifter_mLimitValue
#  undef _0RL_tc_SeedNoid__Lifter_mLimitValue
#endif
static CORBA::TypeCode_ptr _0RL_tc_SeedNoid__Lifter_mLimitValue = CORBA::TypeCode::PR_struct_tc("IDL:SeedNoid_Lifter/LimitValue:1.0", "LimitValue", _0RL_structmember_SeedNoid__Lifter_mLimitValue, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SeedNoid_Lifter { 
  const ::CORBA::TypeCode_ptr _tc_LimitValue = _0RL_tc_SeedNoid__Lifter_mLimitValue;
} 
#else
const ::CORBA::TypeCode_ptr SeedNoid_Lifter::_tc_LimitValue = _0RL_tc_SeedNoid__Lifter_mLimitValue;
#endif






static CORBA::TypeCode_ptr _0RL_tc_SeedNoid__Lifter_mLimitSeq = CORBA::TypeCode::PR_alias_tc("IDL:SeedNoid_Lifter/LimitSeq:1.0", "LimitSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_SeedNoid__Lifter_mLimitValue, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SeedNoid_Lifter { 
  const ::CORBA::TypeCode_ptr _tc_LimitSeq = _0RL_tc_SeedNoid__Lifter_mLimitSeq;
} 
#else
const ::CORBA::TypeCode_ptr SeedNoid_Lifter::_tc_LimitSeq = _0RL_tc_SeedNoid__Lifter_mLimitSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_SeedNoid__Lifter_mDoubleSeq = CORBA::TypeCode::PR_alias_tc("IDL:SeedNoid_Lifter/DoubleSeq:1.0", "DoubleSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SeedNoid_Lifter { 
  const ::CORBA::TypeCode_ptr _tc_DoubleSeq = _0RL_tc_SeedNoid__Lifter_mDoubleSeq;
} 
#else
const ::CORBA::TypeCode_ptr SeedNoid_Lifter::_tc_DoubleSeq = _0RL_tc_SeedNoid__Lifter_mDoubleSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_SeedNoid__Lifter_mULONG = CORBA::TypeCode::PR_alias_tc("IDL:SeedNoid_Lifter/ULONG:1.0", "ULONG", CORBA::TypeCode::PR_ulong_tc(), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SeedNoid_Lifter { 
  const ::CORBA::TypeCode_ptr _tc_ULONG = _0RL_tc_SeedNoid__Lifter_mULONG;
} 
#else
const ::CORBA::TypeCode_ptr SeedNoid_Lifter::_tc_ULONG = _0RL_tc_SeedNoid__Lifter_mULONG;
#endif

static const char* _0RL_enumMember_SeedNoid__Lifter_mRETURN__VALUE[] = { "RETURN_OK", "RETURN_MOVE_OK", "RETURN_INVALID_PARAMETER", "RETURN_NOT_FOUND", "RETURN_OUT_OF_RANGE", "RETURN_ERROR", "RETVAL_ARRIVAL_OK", "RETVAL_EMERGENCY", "RETVAL_SET_PARAM", "RETVAL_MOVE_START", "RETVAL_MOVE_STOP" };
static CORBA::TypeCode_ptr _0RL_tc_SeedNoid__Lifter_mRETURN__VALUE = CORBA::TypeCode::PR_enum_tc("IDL:SeedNoid_Lifter/RETURN_VALUE:1.0", "RETURN_VALUE", _0RL_enumMember_SeedNoid__Lifter_mRETURN__VALUE, 11, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SeedNoid_Lifter { 
  const ::CORBA::TypeCode_ptr _tc_RETURN_VALUE = _0RL_tc_SeedNoid__Lifter_mRETURN__VALUE;
} 
#else
const ::CORBA::TypeCode_ptr SeedNoid_Lifter::_tc_RETURN_VALUE = _0RL_tc_SeedNoid__Lifter_mRETURN__VALUE;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace SeedNoid_Lifter { 
  const ::CORBA::TypeCode_ptr _tc_LifterPose = CORBA::TypeCode::PR_interface_tc("IDL:SeedNoid_Lifter/LifterPose:1.0", "LifterPose", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr SeedNoid_Lifter::_tc_LifterPose = CORBA::TypeCode::PR_interface_tc("IDL:SeedNoid_Lifter/LifterPose:1.0", "LifterPose", &_0RL_tcTrack);
#endif

static void _0RL_SeedNoid__Lifter_mLifterAngle_marshal_fn(cdrStream& _s, void* _v)
{
  SeedNoid_Lifter::LifterAngle* _p = (SeedNoid_Lifter::LifterAngle*)_v;
  *_p >>= _s;
}
static void _0RL_SeedNoid__Lifter_mLifterAngle_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SeedNoid_Lifter::LifterAngle* _p = new SeedNoid_Lifter::LifterAngle;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SeedNoid__Lifter_mLifterAngle_destructor_fn(void* _v)
{
  SeedNoid_Lifter::LifterAngle* _p = (SeedNoid_Lifter::LifterAngle*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SeedNoid_Lifter::LifterAngle& _s)
{
  SeedNoid_Lifter::LifterAngle* _p = new SeedNoid_Lifter::LifterAngle(_s);
  _a.PR_insert(_0RL_tc_SeedNoid__Lifter_mLifterAngle,
               _0RL_SeedNoid__Lifter_mLifterAngle_marshal_fn,
               _0RL_SeedNoid__Lifter_mLifterAngle_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SeedNoid_Lifter::LifterAngle* _sp)
{
  _a.PR_insert(_0RL_tc_SeedNoid__Lifter_mLifterAngle,
               _0RL_SeedNoid__Lifter_mLifterAngle_marshal_fn,
               _0RL_SeedNoid__Lifter_mLifterAngle_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SeedNoid_Lifter::LifterAngle*& _sp)
{
  return _a >>= (const SeedNoid_Lifter::LifterAngle*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SeedNoid_Lifter::LifterAngle*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SeedNoid__Lifter_mLifterAngle,
                    _0RL_SeedNoid__Lifter_mLifterAngle_unmarshal_fn,
                    _0RL_SeedNoid__Lifter_mLifterAngle_marshal_fn,
                    _0RL_SeedNoid__Lifter_mLifterAngle_destructor_fn,
                    _v)) {
    _sp = (const SeedNoid_Lifter::LifterAngle*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SeedNoid__Lifter_mLimitValue_marshal_fn(cdrStream& _s, void* _v)
{
  SeedNoid_Lifter::LimitValue* _p = (SeedNoid_Lifter::LimitValue*)_v;
  *_p >>= _s;
}
static void _0RL_SeedNoid__Lifter_mLimitValue_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SeedNoid_Lifter::LimitValue* _p = new SeedNoid_Lifter::LimitValue;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SeedNoid__Lifter_mLimitValue_destructor_fn(void* _v)
{
  SeedNoid_Lifter::LimitValue* _p = (SeedNoid_Lifter::LimitValue*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SeedNoid_Lifter::LimitValue& _s)
{
  SeedNoid_Lifter::LimitValue* _p = new SeedNoid_Lifter::LimitValue(_s);
  _a.PR_insert(_0RL_tc_SeedNoid__Lifter_mLimitValue,
               _0RL_SeedNoid__Lifter_mLimitValue_marshal_fn,
               _0RL_SeedNoid__Lifter_mLimitValue_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SeedNoid_Lifter::LimitValue* _sp)
{
  _a.PR_insert(_0RL_tc_SeedNoid__Lifter_mLimitValue,
               _0RL_SeedNoid__Lifter_mLimitValue_marshal_fn,
               _0RL_SeedNoid__Lifter_mLimitValue_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SeedNoid_Lifter::LimitValue*& _sp)
{
  return _a >>= (const SeedNoid_Lifter::LimitValue*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SeedNoid_Lifter::LimitValue*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SeedNoid__Lifter_mLimitValue,
                    _0RL_SeedNoid__Lifter_mLimitValue_unmarshal_fn,
                    _0RL_SeedNoid__Lifter_mLimitValue_marshal_fn,
                    _0RL_SeedNoid__Lifter_mLimitValue_destructor_fn,
                    _v)) {
    _sp = (const SeedNoid_Lifter::LimitValue*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SeedNoid__Lifter_mLimitSeq_marshal_fn(cdrStream& _s, void* _v)
{
  SeedNoid_Lifter::LimitSeq* _p = (SeedNoid_Lifter::LimitSeq*)_v;
  *_p >>= _s;
}
static void _0RL_SeedNoid__Lifter_mLimitSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SeedNoid_Lifter::LimitSeq* _p = new SeedNoid_Lifter::LimitSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SeedNoid__Lifter_mLimitSeq_destructor_fn(void* _v)
{
  SeedNoid_Lifter::LimitSeq* _p = (SeedNoid_Lifter::LimitSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SeedNoid_Lifter::LimitSeq& _s)
{
  SeedNoid_Lifter::LimitSeq* _p = new SeedNoid_Lifter::LimitSeq(_s);
  _a.PR_insert(_0RL_tc_SeedNoid__Lifter_mLimitSeq,
               _0RL_SeedNoid__Lifter_mLimitSeq_marshal_fn,
               _0RL_SeedNoid__Lifter_mLimitSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SeedNoid_Lifter::LimitSeq* _sp)
{
  _a.PR_insert(_0RL_tc_SeedNoid__Lifter_mLimitSeq,
               _0RL_SeedNoid__Lifter_mLimitSeq_marshal_fn,
               _0RL_SeedNoid__Lifter_mLimitSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SeedNoid_Lifter::LimitSeq*& _sp)
{
  return _a >>= (const SeedNoid_Lifter::LimitSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SeedNoid_Lifter::LimitSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SeedNoid__Lifter_mLimitSeq,
                    _0RL_SeedNoid__Lifter_mLimitSeq_unmarshal_fn,
                    _0RL_SeedNoid__Lifter_mLimitSeq_marshal_fn,
                    _0RL_SeedNoid__Lifter_mLimitSeq_destructor_fn,
                    _v)) {
    _sp = (const SeedNoid_Lifter::LimitSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SeedNoid__Lifter_mDoubleSeq_marshal_fn(cdrStream& _s, void* _v)
{
  SeedNoid_Lifter::DoubleSeq* _p = (SeedNoid_Lifter::DoubleSeq*)_v;
  *_p >>= _s;
}
static void _0RL_SeedNoid__Lifter_mDoubleSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SeedNoid_Lifter::DoubleSeq* _p = new SeedNoid_Lifter::DoubleSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_SeedNoid__Lifter_mDoubleSeq_destructor_fn(void* _v)
{
  SeedNoid_Lifter::DoubleSeq* _p = (SeedNoid_Lifter::DoubleSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const SeedNoid_Lifter::DoubleSeq& _s)
{
  SeedNoid_Lifter::DoubleSeq* _p = new SeedNoid_Lifter::DoubleSeq(_s);
  _a.PR_insert(_0RL_tc_SeedNoid__Lifter_mDoubleSeq,
               _0RL_SeedNoid__Lifter_mDoubleSeq_marshal_fn,
               _0RL_SeedNoid__Lifter_mDoubleSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, SeedNoid_Lifter::DoubleSeq* _sp)
{
  _a.PR_insert(_0RL_tc_SeedNoid__Lifter_mDoubleSeq,
               _0RL_SeedNoid__Lifter_mDoubleSeq_marshal_fn,
               _0RL_SeedNoid__Lifter_mDoubleSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SeedNoid_Lifter::DoubleSeq*& _sp)
{
  return _a >>= (const SeedNoid_Lifter::DoubleSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const SeedNoid_Lifter::DoubleSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_SeedNoid__Lifter_mDoubleSeq,
                    _0RL_SeedNoid__Lifter_mDoubleSeq_unmarshal_fn,
                    _0RL_SeedNoid__Lifter_mDoubleSeq_marshal_fn,
                    _0RL_SeedNoid__Lifter_mDoubleSeq_destructor_fn,
                    _v)) {
    _sp = (const SeedNoid_Lifter::DoubleSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_SeedNoid__Lifter_mRETURN__VALUE_marshal_fn(cdrStream& _s, void* _v)
{
  SeedNoid_Lifter::RETURN_VALUE* _p = (SeedNoid_Lifter::RETURN_VALUE*)_v;
  *_p >>= _s;
}
static void _0RL_SeedNoid__Lifter_mRETURN__VALUE_unmarshal_fn(cdrStream& _s, void*& _v)
{
  SeedNoid_Lifter::RETURN_VALUE* _p = (SeedNoid_Lifter::RETURN_VALUE*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, SeedNoid_Lifter::RETURN_VALUE _s)
{
  _a.PR_insert(_0RL_tc_SeedNoid__Lifter_mRETURN__VALUE,
               _0RL_SeedNoid__Lifter_mRETURN__VALUE_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SeedNoid_Lifter::RETURN_VALUE& _s)
{
  return _a.PR_extract(_0RL_tc_SeedNoid__Lifter_mRETURN__VALUE,
                       _0RL_SeedNoid__Lifter_mRETURN__VALUE_unmarshal_fn,
                       &_s);
}

static void _0RL_SeedNoid__Lifter_mLifterPose_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_SeedNoid__Lifter_mLifterPose_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(SeedNoid_Lifter::LifterPose::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_SeedNoid__Lifter_mLifterPose_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, SeedNoid_Lifter::LifterPose_ptr _o)
{
  SeedNoid_Lifter::LifterPose_ptr _no = SeedNoid_Lifter::LifterPose::_duplicate(_o);
  _a.PR_insert(SeedNoid_Lifter::_tc_LifterPose,
               _0RL_SeedNoid__Lifter_mLifterPose_marshal_fn,
               _0RL_SeedNoid__Lifter_mLifterPose_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, SeedNoid_Lifter::LifterPose_ptr* _op)
{
  _a.PR_insert(SeedNoid_Lifter::_tc_LifterPose,
               _0RL_SeedNoid__Lifter_mLifterPose_marshal_fn,
               _0RL_SeedNoid__Lifter_mLifterPose_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = SeedNoid_Lifter::LifterPose::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, SeedNoid_Lifter::LifterPose_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(SeedNoid_Lifter::_tc_LifterPose,
                    _0RL_SeedNoid__Lifter_mLifterPose_unmarshal_fn,
                    _0RL_SeedNoid__Lifter_mLifterPose_marshal_fn,
                    _0RL_SeedNoid__Lifter_mLifterPose_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (SeedNoid_Lifter::LifterPose_ptr)_r->_ptrToObjRef(SeedNoid_Lifter::LifterPose::_PD_repoId);
    else
      _o = SeedNoid_Lifter::LifterPose::_nil();
    return 1;
  }
  return 0;
}

