// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "ExtendedDataTypes.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_RTC_mRGBColour[] = {
  {"r", CORBA::TypeCode::PR_double_tc()},
  {"g", CORBA::TypeCode::PR_double_tc()},
  {"b", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mRGBColour
#  undef _0RL_tc_RTC_mRGBColour
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mRGBColour = CORBA::TypeCode::PR_struct_tc("IDL:RTC/RGBColour:1.0", "RGBColour", _0RL_structmember_RTC_mRGBColour, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_RGBColour = _0RL_tc_RTC_mRGBColour;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_RGBColour = _0RL_tc_RTC_mRGBColour;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mPoint2D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPoint2D
#  undef _0RL_tc_RTC_mPoint2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoint2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Point2D:1.0", "Point2D", _0RL_structmember_RTC_mPoint2D, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Point2D = _0RL_tc_RTC_mPoint2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Point2D = _0RL_tc_RTC_mPoint2D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mVector2D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVector2D
#  undef _0RL_tc_RTC_mVector2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVector2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Vector2D:1.0", "Vector2D", _0RL_structmember_RTC_mVector2D, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Vector2D = _0RL_tc_RTC_mVector2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Vector2D = _0RL_tc_RTC_mVector2D;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mPose2D[] = {
  {"position", _0RL_tc_RTC_mPoint2D},
  {"heading", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPose2D
#  undef _0RL_tc_RTC_mPose2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPose2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Pose2D:1.0", "Pose2D", _0RL_structmember_RTC_mPose2D, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Pose2D = _0RL_tc_RTC_mPose2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Pose2D = _0RL_tc_RTC_mPose2D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mVelocity2D[] = {
  {"vx", CORBA::TypeCode::PR_double_tc()},
  {"vy", CORBA::TypeCode::PR_double_tc()},
  {"va", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVelocity2D
#  undef _0RL_tc_RTC_mVelocity2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVelocity2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Velocity2D:1.0", "Velocity2D", _0RL_structmember_RTC_mVelocity2D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Velocity2D = _0RL_tc_RTC_mVelocity2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Velocity2D = _0RL_tc_RTC_mVelocity2D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mAcceleration2D[] = {
  {"ax", CORBA::TypeCode::PR_double_tc()},
  {"ay", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mAcceleration2D
#  undef _0RL_tc_RTC_mAcceleration2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mAcceleration2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Acceleration2D:1.0", "Acceleration2D", _0RL_structmember_RTC_mAcceleration2D, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Acceleration2D = _0RL_tc_RTC_mAcceleration2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Acceleration2D = _0RL_tc_RTC_mAcceleration2D;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mPoseVel2D[] = {
  {"pose", _0RL_tc_RTC_mPose2D},
  {"velocities", _0RL_tc_RTC_mVelocity2D}
};

#ifdef _0RL_tc_RTC_mPoseVel2D
#  undef _0RL_tc_RTC_mPoseVel2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoseVel2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PoseVel2D:1.0", "PoseVel2D", _0RL_structmember_RTC_mPoseVel2D, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PoseVel2D = _0RL_tc_RTC_mPoseVel2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PoseVel2D = _0RL_tc_RTC_mPoseVel2D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mSize2D[] = {
  {"l", CORBA::TypeCode::PR_double_tc()},
  {"w", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mSize2D
#  undef _0RL_tc_RTC_mSize2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mSize2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Size2D:1.0", "Size2D", _0RL_structmember_RTC_mSize2D, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Size2D = _0RL_tc_RTC_mSize2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Size2D = _0RL_tc_RTC_mSize2D;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mGeometry2D[] = {
  {"pose", _0RL_tc_RTC_mPose2D},
  {"size", _0RL_tc_RTC_mSize2D}
};

#ifdef _0RL_tc_RTC_mGeometry2D
#  undef _0RL_tc_RTC_mGeometry2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGeometry2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Geometry2D:1.0", "Geometry2D", _0RL_structmember_RTC_mGeometry2D, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Geometry2D = _0RL_tc_RTC_mGeometry2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Geometry2D = _0RL_tc_RTC_mGeometry2D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mCovariance2D[] = {
  {"xx", CORBA::TypeCode::PR_double_tc()},
  {"xy", CORBA::TypeCode::PR_double_tc()},
  {"xt", CORBA::TypeCode::PR_double_tc()},
  {"yy", CORBA::TypeCode::PR_double_tc()},
  {"yt", CORBA::TypeCode::PR_double_tc()},
  {"tt", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mCovariance2D
#  undef _0RL_tc_RTC_mCovariance2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mCovariance2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Covariance2D:1.0", "Covariance2D", _0RL_structmember_RTC_mCovariance2D, 6, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Covariance2D = _0RL_tc_RTC_mCovariance2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Covariance2D = _0RL_tc_RTC_mCovariance2D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mPointCovariance2D[] = {
  {"xx", CORBA::TypeCode::PR_double_tc()},
  {"xy", CORBA::TypeCode::PR_double_tc()},
  {"yy", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPointCovariance2D
#  undef _0RL_tc_RTC_mPointCovariance2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPointCovariance2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PointCovariance2D:1.0", "PointCovariance2D", _0RL_structmember_RTC_mPointCovariance2D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PointCovariance2D = _0RL_tc_RTC_mPointCovariance2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PointCovariance2D = _0RL_tc_RTC_mPointCovariance2D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mCarlike[] = {
  {"speed", CORBA::TypeCode::PR_double_tc()},
  {"steeringAngle", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mCarlike
#  undef _0RL_tc_RTC_mCarlike
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mCarlike = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Carlike:1.0", "Carlike", _0RL_structmember_RTC_mCarlike, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Carlike = _0RL_tc_RTC_mCarlike;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Carlike = _0RL_tc_RTC_mCarlike;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mSpeedHeading2D[] = {
  {"speed", CORBA::TypeCode::PR_double_tc()},
  {"heading", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mSpeedHeading2D
#  undef _0RL_tc_RTC_mSpeedHeading2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mSpeedHeading2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/SpeedHeading2D:1.0", "SpeedHeading2D", _0RL_structmember_RTC_mSpeedHeading2D, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_SpeedHeading2D = _0RL_tc_RTC_mSpeedHeading2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_SpeedHeading2D = _0RL_tc_RTC_mSpeedHeading2D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mPoint3D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"z", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mPoint3D
#  undef _0RL_tc_RTC_mPoint3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoint3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Point3D:1.0", "Point3D", _0RL_structmember_RTC_mPoint3D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Point3D = _0RL_tc_RTC_mPoint3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Point3D = _0RL_tc_RTC_mPoint3D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mVector3D[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"z", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVector3D
#  undef _0RL_tc_RTC_mVector3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVector3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Vector3D:1.0", "Vector3D", _0RL_structmember_RTC_mVector3D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Vector3D = _0RL_tc_RTC_mVector3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Vector3D = _0RL_tc_RTC_mVector3D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mOrientation3D[] = {
  {"r", CORBA::TypeCode::PR_double_tc()},
  {"p", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mOrientation3D
#  undef _0RL_tc_RTC_mOrientation3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mOrientation3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Orientation3D:1.0", "Orientation3D", _0RL_structmember_RTC_mOrientation3D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Orientation3D = _0RL_tc_RTC_mOrientation3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Orientation3D = _0RL_tc_RTC_mOrientation3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mPose3D[] = {
  {"position", _0RL_tc_RTC_mPoint3D},
  {"orientation", _0RL_tc_RTC_mOrientation3D}
};

#ifdef _0RL_tc_RTC_mPose3D
#  undef _0RL_tc_RTC_mPose3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPose3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Pose3D:1.0", "Pose3D", _0RL_structmember_RTC_mPose3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Pose3D = _0RL_tc_RTC_mPose3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Pose3D = _0RL_tc_RTC_mPose3D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mVelocity3D[] = {
  {"vx", CORBA::TypeCode::PR_double_tc()},
  {"vy", CORBA::TypeCode::PR_double_tc()},
  {"vz", CORBA::TypeCode::PR_double_tc()},
  {"vr", CORBA::TypeCode::PR_double_tc()},
  {"vp", CORBA::TypeCode::PR_double_tc()},
  {"va", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mVelocity3D
#  undef _0RL_tc_RTC_mVelocity3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mVelocity3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Velocity3D:1.0", "Velocity3D", _0RL_structmember_RTC_mVelocity3D, 6, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Velocity3D = _0RL_tc_RTC_mVelocity3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Velocity3D = _0RL_tc_RTC_mVelocity3D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mAngularVelocity3D[] = {
  {"avx", CORBA::TypeCode::PR_double_tc()},
  {"avy", CORBA::TypeCode::PR_double_tc()},
  {"avz", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mAngularVelocity3D
#  undef _0RL_tc_RTC_mAngularVelocity3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mAngularVelocity3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/AngularVelocity3D:1.0", "AngularVelocity3D", _0RL_structmember_RTC_mAngularVelocity3D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_AngularVelocity3D = _0RL_tc_RTC_mAngularVelocity3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_AngularVelocity3D = _0RL_tc_RTC_mAngularVelocity3D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mAcceleration3D[] = {
  {"ax", CORBA::TypeCode::PR_double_tc()},
  {"ay", CORBA::TypeCode::PR_double_tc()},
  {"az", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mAcceleration3D
#  undef _0RL_tc_RTC_mAcceleration3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mAcceleration3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Acceleration3D:1.0", "Acceleration3D", _0RL_structmember_RTC_mAcceleration3D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Acceleration3D = _0RL_tc_RTC_mAcceleration3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Acceleration3D = _0RL_tc_RTC_mAcceleration3D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mAngularAcceleration3D[] = {
  {"aax", CORBA::TypeCode::PR_double_tc()},
  {"aay", CORBA::TypeCode::PR_double_tc()},
  {"aaz", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mAngularAcceleration3D
#  undef _0RL_tc_RTC_mAngularAcceleration3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mAngularAcceleration3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/AngularAcceleration3D:1.0", "AngularAcceleration3D", _0RL_structmember_RTC_mAngularAcceleration3D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_AngularAcceleration3D = _0RL_tc_RTC_mAngularAcceleration3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_AngularAcceleration3D = _0RL_tc_RTC_mAngularAcceleration3D;
#endif






static CORBA::PR_structMember _0RL_structmember_RTC_mPoseVel3D[] = {
  {"pose", _0RL_tc_RTC_mPose3D},
  {"velocities", _0RL_tc_RTC_mVelocity3D}
};

#ifdef _0RL_tc_RTC_mPoseVel3D
#  undef _0RL_tc_RTC_mPoseVel3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mPoseVel3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/PoseVel3D:1.0", "PoseVel3D", _0RL_structmember_RTC_mPoseVel3D, 2, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_PoseVel3D = _0RL_tc_RTC_mPoseVel3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_PoseVel3D = _0RL_tc_RTC_mPoseVel3D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mSize3D[] = {
  {"l", CORBA::TypeCode::PR_double_tc()},
  {"w", CORBA::TypeCode::PR_double_tc()},
  {"h", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mSize3D
#  undef _0RL_tc_RTC_mSize3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mSize3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Size3D:1.0", "Size3D", _0RL_structmember_RTC_mSize3D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Size3D = _0RL_tc_RTC_mSize3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Size3D = _0RL_tc_RTC_mSize3D;
#endif






static CORBA::PR_structMember _0RL_structmember_RTC_mGeometry3D[] = {
  {"pose", _0RL_tc_RTC_mPose3D},
  {"size", _0RL_tc_RTC_mSize3D}
};

#ifdef _0RL_tc_RTC_mGeometry3D
#  undef _0RL_tc_RTC_mGeometry3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mGeometry3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Geometry3D:1.0", "Geometry3D", _0RL_structmember_RTC_mGeometry3D, 2, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Geometry3D = _0RL_tc_RTC_mGeometry3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Geometry3D = _0RL_tc_RTC_mGeometry3D;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mCovariance3D[] = {
  {"xx", CORBA::TypeCode::PR_double_tc()},
  {"xy", CORBA::TypeCode::PR_double_tc()},
  {"xz", CORBA::TypeCode::PR_double_tc()},
  {"xr", CORBA::TypeCode::PR_double_tc()},
  {"xp", CORBA::TypeCode::PR_double_tc()},
  {"xa", CORBA::TypeCode::PR_double_tc()},
  {"yy", CORBA::TypeCode::PR_double_tc()},
  {"yz", CORBA::TypeCode::PR_double_tc()},
  {"yr", CORBA::TypeCode::PR_double_tc()},
  {"yp", CORBA::TypeCode::PR_double_tc()},
  {"ya", CORBA::TypeCode::PR_double_tc()},
  {"zz", CORBA::TypeCode::PR_double_tc()},
  {"zr", CORBA::TypeCode::PR_double_tc()},
  {"zp", CORBA::TypeCode::PR_double_tc()},
  {"za", CORBA::TypeCode::PR_double_tc()},
  {"rr", CORBA::TypeCode::PR_double_tc()},
  {"rp", CORBA::TypeCode::PR_double_tc()},
  {"ra", CORBA::TypeCode::PR_double_tc()},
  {"pp", CORBA::TypeCode::PR_double_tc()},
  {"pa", CORBA::TypeCode::PR_double_tc()},
  {"aa", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mCovariance3D
#  undef _0RL_tc_RTC_mCovariance3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mCovariance3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Covariance3D:1.0", "Covariance3D", _0RL_structmember_RTC_mCovariance3D, 21, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Covariance3D = _0RL_tc_RTC_mCovariance3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Covariance3D = _0RL_tc_RTC_mCovariance3D;
#endif



static CORBA::PR_structMember _0RL_structmember_RTC_mSpeedHeading3D[] = {
  {"speed", CORBA::TypeCode::PR_double_tc()},
  {"direction", _0RL_tc_RTC_mOrientation3D}
};

#ifdef _0RL_tc_RTC_mSpeedHeading3D
#  undef _0RL_tc_RTC_mSpeedHeading3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mSpeedHeading3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/SpeedHeading3D:1.0", "SpeedHeading3D", _0RL_structmember_RTC_mSpeedHeading3D, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_SpeedHeading3D = _0RL_tc_RTC_mSpeedHeading3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_SpeedHeading3D = _0RL_tc_RTC_mSpeedHeading3D;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mOAP[] = {
  {"orientation", _0RL_tc_RTC_mVector3D},
  {"approach", _0RL_tc_RTC_mVector3D},
  {"position", _0RL_tc_RTC_mVector3D}
};

#ifdef _0RL_tc_RTC_mOAP
#  undef _0RL_tc_RTC_mOAP
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mOAP = CORBA::TypeCode::PR_struct_tc("IDL:RTC/OAP:1.0", "OAP", _0RL_structmember_RTC_mOAP, 3, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_OAP = _0RL_tc_RTC_mOAP;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_OAP = _0RL_tc_RTC_mOAP;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mTime[] = {
  {"sec", CORBA::TypeCode::PR_ulong_tc()},
  {"nsec", CORBA::TypeCode::PR_ulong_tc()}
};

#ifdef _0RL_tc_RTC_mTime
#  undef _0RL_tc_RTC_mTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTime = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Time:1.0", "Time", _0RL_structmember_RTC_mTime, 2, &_0RL_tcTrack);


static CORBA::PR_structMember _0RL_structmember_RTC_mTimedRGBColour[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mRGBColour}
};

#ifdef _0RL_tc_RTC_mTimedRGBColour
#  undef _0RL_tc_RTC_mTimedRGBColour
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedRGBColour = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedRGBColour:1.0", "TimedRGBColour", _0RL_structmember_RTC_mTimedRGBColour, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedRGBColour = _0RL_tc_RTC_mTimedRGBColour;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedRGBColour = _0RL_tc_RTC_mTimedRGBColour;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedPoint2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mPoint2D}
};

#ifdef _0RL_tc_RTC_mTimedPoint2D
#  undef _0RL_tc_RTC_mTimedPoint2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedPoint2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedPoint2D:1.0", "TimedPoint2D", _0RL_structmember_RTC_mTimedPoint2D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedPoint2D = _0RL_tc_RTC_mTimedPoint2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedPoint2D = _0RL_tc_RTC_mTimedPoint2D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedVector2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mVector2D}
};

#ifdef _0RL_tc_RTC_mTimedVector2D
#  undef _0RL_tc_RTC_mTimedVector2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedVector2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedVector2D:1.0", "TimedVector2D", _0RL_structmember_RTC_mTimedVector2D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedVector2D = _0RL_tc_RTC_mTimedVector2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedVector2D = _0RL_tc_RTC_mTimedVector2D;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mTimedPose2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mPose2D}
};

#ifdef _0RL_tc_RTC_mTimedPose2D
#  undef _0RL_tc_RTC_mTimedPose2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedPose2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedPose2D:1.0", "TimedPose2D", _0RL_structmember_RTC_mTimedPose2D, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedPose2D = _0RL_tc_RTC_mTimedPose2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedPose2D = _0RL_tc_RTC_mTimedPose2D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedVelocity2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mVelocity2D}
};

#ifdef _0RL_tc_RTC_mTimedVelocity2D
#  undef _0RL_tc_RTC_mTimedVelocity2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedVelocity2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedVelocity2D:1.0", "TimedVelocity2D", _0RL_structmember_RTC_mTimedVelocity2D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedVelocity2D = _0RL_tc_RTC_mTimedVelocity2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedVelocity2D = _0RL_tc_RTC_mTimedVelocity2D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedAcceleration2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mAcceleration2D}
};

#ifdef _0RL_tc_RTC_mTimedAcceleration2D
#  undef _0RL_tc_RTC_mTimedAcceleration2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedAcceleration2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedAcceleration2D:1.0", "TimedAcceleration2D", _0RL_structmember_RTC_mTimedAcceleration2D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedAcceleration2D = _0RL_tc_RTC_mTimedAcceleration2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedAcceleration2D = _0RL_tc_RTC_mTimedAcceleration2D;
#endif







static CORBA::PR_structMember _0RL_structmember_RTC_mTimedPoseVel2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mPoseVel2D}
};

#ifdef _0RL_tc_RTC_mTimedPoseVel2D
#  undef _0RL_tc_RTC_mTimedPoseVel2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedPoseVel2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedPoseVel2D:1.0", "TimedPoseVel2D", _0RL_structmember_RTC_mTimedPoseVel2D, 2, &_0RL_tcTrack);






#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedPoseVel2D = _0RL_tc_RTC_mTimedPoseVel2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedPoseVel2D = _0RL_tc_RTC_mTimedPoseVel2D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedSize2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mSize2D}
};

#ifdef _0RL_tc_RTC_mTimedSize2D
#  undef _0RL_tc_RTC_mTimedSize2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedSize2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedSize2D:1.0", "TimedSize2D", _0RL_structmember_RTC_mTimedSize2D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedSize2D = _0RL_tc_RTC_mTimedSize2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedSize2D = _0RL_tc_RTC_mTimedSize2D;
#endif







static CORBA::PR_structMember _0RL_structmember_RTC_mTimedGeometry2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mGeometry2D}
};

#ifdef _0RL_tc_RTC_mTimedGeometry2D
#  undef _0RL_tc_RTC_mTimedGeometry2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedGeometry2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedGeometry2D:1.0", "TimedGeometry2D", _0RL_structmember_RTC_mTimedGeometry2D, 2, &_0RL_tcTrack);






#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedGeometry2D = _0RL_tc_RTC_mTimedGeometry2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedGeometry2D = _0RL_tc_RTC_mTimedGeometry2D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedCovariance2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mCovariance2D}
};

#ifdef _0RL_tc_RTC_mTimedCovariance2D
#  undef _0RL_tc_RTC_mTimedCovariance2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedCovariance2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedCovariance2D:1.0", "TimedCovariance2D", _0RL_structmember_RTC_mTimedCovariance2D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedCovariance2D = _0RL_tc_RTC_mTimedCovariance2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedCovariance2D = _0RL_tc_RTC_mTimedCovariance2D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedPointCovariance2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mPointCovariance2D}
};

#ifdef _0RL_tc_RTC_mTimedPointCovariance2D
#  undef _0RL_tc_RTC_mTimedPointCovariance2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedPointCovariance2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedPointCovariance2D:1.0", "TimedPointCovariance2D", _0RL_structmember_RTC_mTimedPointCovariance2D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedPointCovariance2D = _0RL_tc_RTC_mTimedPointCovariance2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedPointCovariance2D = _0RL_tc_RTC_mTimedPointCovariance2D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedCarlike[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mCarlike}
};

#ifdef _0RL_tc_RTC_mTimedCarlike
#  undef _0RL_tc_RTC_mTimedCarlike
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedCarlike = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedCarlike:1.0", "TimedCarlike", _0RL_structmember_RTC_mTimedCarlike, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedCarlike = _0RL_tc_RTC_mTimedCarlike;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedCarlike = _0RL_tc_RTC_mTimedCarlike;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedSpeedHeading2D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mSpeedHeading2D}
};

#ifdef _0RL_tc_RTC_mTimedSpeedHeading2D
#  undef _0RL_tc_RTC_mTimedSpeedHeading2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedSpeedHeading2D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedSpeedHeading2D:1.0", "TimedSpeedHeading2D", _0RL_structmember_RTC_mTimedSpeedHeading2D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedSpeedHeading2D = _0RL_tc_RTC_mTimedSpeedHeading2D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedSpeedHeading2D = _0RL_tc_RTC_mTimedSpeedHeading2D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedPoint3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mPoint3D}
};

#ifdef _0RL_tc_RTC_mTimedPoint3D
#  undef _0RL_tc_RTC_mTimedPoint3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedPoint3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedPoint3D:1.0", "TimedPoint3D", _0RL_structmember_RTC_mTimedPoint3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedPoint3D = _0RL_tc_RTC_mTimedPoint3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedPoint3D = _0RL_tc_RTC_mTimedPoint3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedVector3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mVector3D}
};

#ifdef _0RL_tc_RTC_mTimedVector3D
#  undef _0RL_tc_RTC_mTimedVector3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedVector3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedVector3D:1.0", "TimedVector3D", _0RL_structmember_RTC_mTimedVector3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedVector3D = _0RL_tc_RTC_mTimedVector3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedVector3D = _0RL_tc_RTC_mTimedVector3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedOrientation3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mOrientation3D}
};

#ifdef _0RL_tc_RTC_mTimedOrientation3D
#  undef _0RL_tc_RTC_mTimedOrientation3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedOrientation3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedOrientation3D:1.0", "TimedOrientation3D", _0RL_structmember_RTC_mTimedOrientation3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedOrientation3D = _0RL_tc_RTC_mTimedOrientation3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedOrientation3D = _0RL_tc_RTC_mTimedOrientation3D;
#endif






static CORBA::PR_structMember _0RL_structmember_RTC_mTimedPose3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mPose3D}
};

#ifdef _0RL_tc_RTC_mTimedPose3D
#  undef _0RL_tc_RTC_mTimedPose3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedPose3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedPose3D:1.0", "TimedPose3D", _0RL_structmember_RTC_mTimedPose3D, 2, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedPose3D = _0RL_tc_RTC_mTimedPose3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedPose3D = _0RL_tc_RTC_mTimedPose3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedVelocity3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mVelocity3D}
};

#ifdef _0RL_tc_RTC_mTimedVelocity3D
#  undef _0RL_tc_RTC_mTimedVelocity3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedVelocity3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedVelocity3D:1.0", "TimedVelocity3D", _0RL_structmember_RTC_mTimedVelocity3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedVelocity3D = _0RL_tc_RTC_mTimedVelocity3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedVelocity3D = _0RL_tc_RTC_mTimedVelocity3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedAngularVelocity3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mAngularVelocity3D}
};

#ifdef _0RL_tc_RTC_mTimedAngularVelocity3D
#  undef _0RL_tc_RTC_mTimedAngularVelocity3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedAngularVelocity3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedAngularVelocity3D:1.0", "TimedAngularVelocity3D", _0RL_structmember_RTC_mTimedAngularVelocity3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedAngularVelocity3D = _0RL_tc_RTC_mTimedAngularVelocity3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedAngularVelocity3D = _0RL_tc_RTC_mTimedAngularVelocity3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedAcceleration3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mAcceleration3D}
};

#ifdef _0RL_tc_RTC_mTimedAcceleration3D
#  undef _0RL_tc_RTC_mTimedAcceleration3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedAcceleration3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedAcceleration3D:1.0", "TimedAcceleration3D", _0RL_structmember_RTC_mTimedAcceleration3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedAcceleration3D = _0RL_tc_RTC_mTimedAcceleration3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedAcceleration3D = _0RL_tc_RTC_mTimedAcceleration3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedAngularAcceleration3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mAngularAcceleration3D}
};

#ifdef _0RL_tc_RTC_mTimedAngularAcceleration3D
#  undef _0RL_tc_RTC_mTimedAngularAcceleration3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedAngularAcceleration3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedAngularAcceleration3D:1.0", "TimedAngularAcceleration3D", _0RL_structmember_RTC_mTimedAngularAcceleration3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedAngularAcceleration3D = _0RL_tc_RTC_mTimedAngularAcceleration3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedAngularAcceleration3D = _0RL_tc_RTC_mTimedAngularAcceleration3D;
#endif








static CORBA::PR_structMember _0RL_structmember_RTC_mTimedPoseVel3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mPoseVel3D}
};

#ifdef _0RL_tc_RTC_mTimedPoseVel3D
#  undef _0RL_tc_RTC_mTimedPoseVel3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedPoseVel3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedPoseVel3D:1.0", "TimedPoseVel3D", _0RL_structmember_RTC_mTimedPoseVel3D, 2, &_0RL_tcTrack);







#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedPoseVel3D = _0RL_tc_RTC_mTimedPoseVel3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedPoseVel3D = _0RL_tc_RTC_mTimedPoseVel3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedSize3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mSize3D}
};

#ifdef _0RL_tc_RTC_mTimedSize3D
#  undef _0RL_tc_RTC_mTimedSize3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedSize3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedSize3D:1.0", "TimedSize3D", _0RL_structmember_RTC_mTimedSize3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedSize3D = _0RL_tc_RTC_mTimedSize3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedSize3D = _0RL_tc_RTC_mTimedSize3D;
#endif








static CORBA::PR_structMember _0RL_structmember_RTC_mTimedGeometry3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mGeometry3D}
};

#ifdef _0RL_tc_RTC_mTimedGeometry3D
#  undef _0RL_tc_RTC_mTimedGeometry3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedGeometry3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedGeometry3D:1.0", "TimedGeometry3D", _0RL_structmember_RTC_mTimedGeometry3D, 2, &_0RL_tcTrack);







#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedGeometry3D = _0RL_tc_RTC_mTimedGeometry3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedGeometry3D = _0RL_tc_RTC_mTimedGeometry3D;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedCovariance3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mCovariance3D}
};

#ifdef _0RL_tc_RTC_mTimedCovariance3D
#  undef _0RL_tc_RTC_mTimedCovariance3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedCovariance3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedCovariance3D:1.0", "TimedCovariance3D", _0RL_structmember_RTC_mTimedCovariance3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedCovariance3D = _0RL_tc_RTC_mTimedCovariance3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedCovariance3D = _0RL_tc_RTC_mTimedCovariance3D;
#endif





static CORBA::PR_structMember _0RL_structmember_RTC_mTimedSpeedHeading3D[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mSpeedHeading3D}
};

#ifdef _0RL_tc_RTC_mTimedSpeedHeading3D
#  undef _0RL_tc_RTC_mTimedSpeedHeading3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedSpeedHeading3D = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedSpeedHeading3D:1.0", "TimedSpeedHeading3D", _0RL_structmember_RTC_mTimedSpeedHeading3D, 2, &_0RL_tcTrack);




#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedSpeedHeading3D = _0RL_tc_RTC_mTimedSpeedHeading3D;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedSpeedHeading3D = _0RL_tc_RTC_mTimedSpeedHeading3D;
#endif







static CORBA::PR_structMember _0RL_structmember_RTC_mTimedOAP[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mOAP}
};

#ifdef _0RL_tc_RTC_mTimedOAP
#  undef _0RL_tc_RTC_mTimedOAP
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedOAP = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedOAP:1.0", "TimedOAP", _0RL_structmember_RTC_mTimedOAP, 2, &_0RL_tcTrack);






#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedOAP = _0RL_tc_RTC_mTimedOAP;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedOAP = _0RL_tc_RTC_mTimedOAP;
#endif


static CORBA::PR_structMember _0RL_structmember_RTC_mQuaternion[] = {
  {"x", CORBA::TypeCode::PR_double_tc()},
  {"y", CORBA::TypeCode::PR_double_tc()},
  {"z", CORBA::TypeCode::PR_double_tc()},
  {"w", CORBA::TypeCode::PR_double_tc()}
};

#ifdef _0RL_tc_RTC_mQuaternion
#  undef _0RL_tc_RTC_mQuaternion
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mQuaternion = CORBA::TypeCode::PR_struct_tc("IDL:RTC/Quaternion:1.0", "Quaternion", _0RL_structmember_RTC_mQuaternion, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_Quaternion = _0RL_tc_RTC_mQuaternion;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_Quaternion = _0RL_tc_RTC_mQuaternion;
#endif




static CORBA::PR_structMember _0RL_structmember_RTC_mTimedQuaternion[] = {
  {"tm", _0RL_tc_RTC_mTime},
  {"data", _0RL_tc_RTC_mQuaternion}
};

#ifdef _0RL_tc_RTC_mTimedQuaternion
#  undef _0RL_tc_RTC_mTimedQuaternion
#endif
static CORBA::TypeCode_ptr _0RL_tc_RTC_mTimedQuaternion = CORBA::TypeCode::PR_struct_tc("IDL:RTC/TimedQuaternion:1.0", "TimedQuaternion", _0RL_structmember_RTC_mTimedQuaternion, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace RTC { 
  const ::CORBA::TypeCode_ptr _tc_TimedQuaternion = _0RL_tc_RTC_mTimedQuaternion;
} 
#else
const ::CORBA::TypeCode_ptr RTC::_tc_TimedQuaternion = _0RL_tc_RTC_mTimedQuaternion;
#endif


static void _0RL_RTC_mRGBColour_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::RGBColour* _p = (RTC::RGBColour*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mRGBColour_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::RGBColour* _p = new RTC::RGBColour;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mRGBColour_destructor_fn(void* _v)
{
  RTC::RGBColour* _p = (RTC::RGBColour*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::RGBColour& _s)
{
  RTC::RGBColour* _p = new RTC::RGBColour(_s);
  _a.PR_insert(_0RL_tc_RTC_mRGBColour,
               _0RL_RTC_mRGBColour_marshal_fn,
               _0RL_RTC_mRGBColour_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::RGBColour* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mRGBColour,
               _0RL_RTC_mRGBColour_marshal_fn,
               _0RL_RTC_mRGBColour_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::RGBColour*& _sp)
{
  return _a >>= (const RTC::RGBColour*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::RGBColour*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mRGBColour,
                    _0RL_RTC_mRGBColour_unmarshal_fn,
                    _0RL_RTC_mRGBColour_marshal_fn,
                    _0RL_RTC_mRGBColour_destructor_fn,
                    _v)) {
    _sp = (const RTC::RGBColour*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPoint2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Point2D* _p = (RTC::Point2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPoint2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Point2D* _p = new RTC::Point2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPoint2D_destructor_fn(void* _v)
{
  RTC::Point2D* _p = (RTC::Point2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Point2D& _s)
{
  RTC::Point2D* _p = new RTC::Point2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mPoint2D,
               _0RL_RTC_mPoint2D_marshal_fn,
               _0RL_RTC_mPoint2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Point2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPoint2D,
               _0RL_RTC_mPoint2D_marshal_fn,
               _0RL_RTC_mPoint2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Point2D*& _sp)
{
  return _a >>= (const RTC::Point2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Point2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPoint2D,
                    _0RL_RTC_mPoint2D_unmarshal_fn,
                    _0RL_RTC_mPoint2D_marshal_fn,
                    _0RL_RTC_mPoint2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Point2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mVector2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Vector2D* _p = (RTC::Vector2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mVector2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Vector2D* _p = new RTC::Vector2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mVector2D_destructor_fn(void* _v)
{
  RTC::Vector2D* _p = (RTC::Vector2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Vector2D& _s)
{
  RTC::Vector2D* _p = new RTC::Vector2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mVector2D,
               _0RL_RTC_mVector2D_marshal_fn,
               _0RL_RTC_mVector2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Vector2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mVector2D,
               _0RL_RTC_mVector2D_marshal_fn,
               _0RL_RTC_mVector2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Vector2D*& _sp)
{
  return _a >>= (const RTC::Vector2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Vector2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mVector2D,
                    _0RL_RTC_mVector2D_unmarshal_fn,
                    _0RL_RTC_mVector2D_marshal_fn,
                    _0RL_RTC_mVector2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Vector2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPose2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Pose2D* _p = (RTC::Pose2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPose2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Pose2D* _p = new RTC::Pose2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPose2D_destructor_fn(void* _v)
{
  RTC::Pose2D* _p = (RTC::Pose2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Pose2D& _s)
{
  RTC::Pose2D* _p = new RTC::Pose2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mPose2D,
               _0RL_RTC_mPose2D_marshal_fn,
               _0RL_RTC_mPose2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Pose2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPose2D,
               _0RL_RTC_mPose2D_marshal_fn,
               _0RL_RTC_mPose2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Pose2D*& _sp)
{
  return _a >>= (const RTC::Pose2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Pose2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPose2D,
                    _0RL_RTC_mPose2D_unmarshal_fn,
                    _0RL_RTC_mPose2D_marshal_fn,
                    _0RL_RTC_mPose2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Pose2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mVelocity2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Velocity2D* _p = (RTC::Velocity2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mVelocity2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Velocity2D* _p = new RTC::Velocity2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mVelocity2D_destructor_fn(void* _v)
{
  RTC::Velocity2D* _p = (RTC::Velocity2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Velocity2D& _s)
{
  RTC::Velocity2D* _p = new RTC::Velocity2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mVelocity2D,
               _0RL_RTC_mVelocity2D_marshal_fn,
               _0RL_RTC_mVelocity2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Velocity2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mVelocity2D,
               _0RL_RTC_mVelocity2D_marshal_fn,
               _0RL_RTC_mVelocity2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Velocity2D*& _sp)
{
  return _a >>= (const RTC::Velocity2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Velocity2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mVelocity2D,
                    _0RL_RTC_mVelocity2D_unmarshal_fn,
                    _0RL_RTC_mVelocity2D_marshal_fn,
                    _0RL_RTC_mVelocity2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Velocity2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mAcceleration2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Acceleration2D* _p = (RTC::Acceleration2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mAcceleration2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Acceleration2D* _p = new RTC::Acceleration2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mAcceleration2D_destructor_fn(void* _v)
{
  RTC::Acceleration2D* _p = (RTC::Acceleration2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Acceleration2D& _s)
{
  RTC::Acceleration2D* _p = new RTC::Acceleration2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mAcceleration2D,
               _0RL_RTC_mAcceleration2D_marshal_fn,
               _0RL_RTC_mAcceleration2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Acceleration2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mAcceleration2D,
               _0RL_RTC_mAcceleration2D_marshal_fn,
               _0RL_RTC_mAcceleration2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Acceleration2D*& _sp)
{
  return _a >>= (const RTC::Acceleration2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Acceleration2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mAcceleration2D,
                    _0RL_RTC_mAcceleration2D_unmarshal_fn,
                    _0RL_RTC_mAcceleration2D_marshal_fn,
                    _0RL_RTC_mAcceleration2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Acceleration2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPoseVel2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PoseVel2D* _p = (RTC::PoseVel2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPoseVel2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PoseVel2D* _p = new RTC::PoseVel2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPoseVel2D_destructor_fn(void* _v)
{
  RTC::PoseVel2D* _p = (RTC::PoseVel2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PoseVel2D& _s)
{
  RTC::PoseVel2D* _p = new RTC::PoseVel2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mPoseVel2D,
               _0RL_RTC_mPoseVel2D_marshal_fn,
               _0RL_RTC_mPoseVel2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PoseVel2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPoseVel2D,
               _0RL_RTC_mPoseVel2D_marshal_fn,
               _0RL_RTC_mPoseVel2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PoseVel2D*& _sp)
{
  return _a >>= (const RTC::PoseVel2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PoseVel2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPoseVel2D,
                    _0RL_RTC_mPoseVel2D_unmarshal_fn,
                    _0RL_RTC_mPoseVel2D_marshal_fn,
                    _0RL_RTC_mPoseVel2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::PoseVel2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mSize2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Size2D* _p = (RTC::Size2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mSize2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Size2D* _p = new RTC::Size2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mSize2D_destructor_fn(void* _v)
{
  RTC::Size2D* _p = (RTC::Size2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Size2D& _s)
{
  RTC::Size2D* _p = new RTC::Size2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mSize2D,
               _0RL_RTC_mSize2D_marshal_fn,
               _0RL_RTC_mSize2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Size2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mSize2D,
               _0RL_RTC_mSize2D_marshal_fn,
               _0RL_RTC_mSize2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Size2D*& _sp)
{
  return _a >>= (const RTC::Size2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Size2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mSize2D,
                    _0RL_RTC_mSize2D_unmarshal_fn,
                    _0RL_RTC_mSize2D_marshal_fn,
                    _0RL_RTC_mSize2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Size2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGeometry2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Geometry2D* _p = (RTC::Geometry2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGeometry2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Geometry2D* _p = new RTC::Geometry2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGeometry2D_destructor_fn(void* _v)
{
  RTC::Geometry2D* _p = (RTC::Geometry2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Geometry2D& _s)
{
  RTC::Geometry2D* _p = new RTC::Geometry2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mGeometry2D,
               _0RL_RTC_mGeometry2D_marshal_fn,
               _0RL_RTC_mGeometry2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Geometry2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGeometry2D,
               _0RL_RTC_mGeometry2D_marshal_fn,
               _0RL_RTC_mGeometry2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Geometry2D*& _sp)
{
  return _a >>= (const RTC::Geometry2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Geometry2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGeometry2D,
                    _0RL_RTC_mGeometry2D_unmarshal_fn,
                    _0RL_RTC_mGeometry2D_marshal_fn,
                    _0RL_RTC_mGeometry2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Geometry2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mCovariance2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Covariance2D* _p = (RTC::Covariance2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mCovariance2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Covariance2D* _p = new RTC::Covariance2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mCovariance2D_destructor_fn(void* _v)
{
  RTC::Covariance2D* _p = (RTC::Covariance2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Covariance2D& _s)
{
  RTC::Covariance2D* _p = new RTC::Covariance2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mCovariance2D,
               _0RL_RTC_mCovariance2D_marshal_fn,
               _0RL_RTC_mCovariance2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Covariance2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mCovariance2D,
               _0RL_RTC_mCovariance2D_marshal_fn,
               _0RL_RTC_mCovariance2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Covariance2D*& _sp)
{
  return _a >>= (const RTC::Covariance2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Covariance2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mCovariance2D,
                    _0RL_RTC_mCovariance2D_unmarshal_fn,
                    _0RL_RTC_mCovariance2D_marshal_fn,
                    _0RL_RTC_mCovariance2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Covariance2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPointCovariance2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PointCovariance2D* _p = (RTC::PointCovariance2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPointCovariance2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PointCovariance2D* _p = new RTC::PointCovariance2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPointCovariance2D_destructor_fn(void* _v)
{
  RTC::PointCovariance2D* _p = (RTC::PointCovariance2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PointCovariance2D& _s)
{
  RTC::PointCovariance2D* _p = new RTC::PointCovariance2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mPointCovariance2D,
               _0RL_RTC_mPointCovariance2D_marshal_fn,
               _0RL_RTC_mPointCovariance2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PointCovariance2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPointCovariance2D,
               _0RL_RTC_mPointCovariance2D_marshal_fn,
               _0RL_RTC_mPointCovariance2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PointCovariance2D*& _sp)
{
  return _a >>= (const RTC::PointCovariance2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PointCovariance2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPointCovariance2D,
                    _0RL_RTC_mPointCovariance2D_unmarshal_fn,
                    _0RL_RTC_mPointCovariance2D_marshal_fn,
                    _0RL_RTC_mPointCovariance2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::PointCovariance2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mCarlike_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Carlike* _p = (RTC::Carlike*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mCarlike_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Carlike* _p = new RTC::Carlike;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mCarlike_destructor_fn(void* _v)
{
  RTC::Carlike* _p = (RTC::Carlike*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Carlike& _s)
{
  RTC::Carlike* _p = new RTC::Carlike(_s);
  _a.PR_insert(_0RL_tc_RTC_mCarlike,
               _0RL_RTC_mCarlike_marshal_fn,
               _0RL_RTC_mCarlike_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Carlike* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mCarlike,
               _0RL_RTC_mCarlike_marshal_fn,
               _0RL_RTC_mCarlike_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Carlike*& _sp)
{
  return _a >>= (const RTC::Carlike*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Carlike*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mCarlike,
                    _0RL_RTC_mCarlike_unmarshal_fn,
                    _0RL_RTC_mCarlike_marshal_fn,
                    _0RL_RTC_mCarlike_destructor_fn,
                    _v)) {
    _sp = (const RTC::Carlike*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mSpeedHeading2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::SpeedHeading2D* _p = (RTC::SpeedHeading2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mSpeedHeading2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::SpeedHeading2D* _p = new RTC::SpeedHeading2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mSpeedHeading2D_destructor_fn(void* _v)
{
  RTC::SpeedHeading2D* _p = (RTC::SpeedHeading2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::SpeedHeading2D& _s)
{
  RTC::SpeedHeading2D* _p = new RTC::SpeedHeading2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mSpeedHeading2D,
               _0RL_RTC_mSpeedHeading2D_marshal_fn,
               _0RL_RTC_mSpeedHeading2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::SpeedHeading2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mSpeedHeading2D,
               _0RL_RTC_mSpeedHeading2D_marshal_fn,
               _0RL_RTC_mSpeedHeading2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::SpeedHeading2D*& _sp)
{
  return _a >>= (const RTC::SpeedHeading2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::SpeedHeading2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mSpeedHeading2D,
                    _0RL_RTC_mSpeedHeading2D_unmarshal_fn,
                    _0RL_RTC_mSpeedHeading2D_marshal_fn,
                    _0RL_RTC_mSpeedHeading2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::SpeedHeading2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPoint3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Point3D* _p = (RTC::Point3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPoint3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Point3D* _p = new RTC::Point3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPoint3D_destructor_fn(void* _v)
{
  RTC::Point3D* _p = (RTC::Point3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Point3D& _s)
{
  RTC::Point3D* _p = new RTC::Point3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mPoint3D,
               _0RL_RTC_mPoint3D_marshal_fn,
               _0RL_RTC_mPoint3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Point3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPoint3D,
               _0RL_RTC_mPoint3D_marshal_fn,
               _0RL_RTC_mPoint3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Point3D*& _sp)
{
  return _a >>= (const RTC::Point3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Point3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPoint3D,
                    _0RL_RTC_mPoint3D_unmarshal_fn,
                    _0RL_RTC_mPoint3D_marshal_fn,
                    _0RL_RTC_mPoint3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Point3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mVector3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Vector3D* _p = (RTC::Vector3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mVector3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Vector3D* _p = new RTC::Vector3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mVector3D_destructor_fn(void* _v)
{
  RTC::Vector3D* _p = (RTC::Vector3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Vector3D& _s)
{
  RTC::Vector3D* _p = new RTC::Vector3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mVector3D,
               _0RL_RTC_mVector3D_marshal_fn,
               _0RL_RTC_mVector3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Vector3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mVector3D,
               _0RL_RTC_mVector3D_marshal_fn,
               _0RL_RTC_mVector3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Vector3D*& _sp)
{
  return _a >>= (const RTC::Vector3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Vector3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mVector3D,
                    _0RL_RTC_mVector3D_unmarshal_fn,
                    _0RL_RTC_mVector3D_marshal_fn,
                    _0RL_RTC_mVector3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Vector3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mOrientation3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Orientation3D* _p = (RTC::Orientation3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mOrientation3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Orientation3D* _p = new RTC::Orientation3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mOrientation3D_destructor_fn(void* _v)
{
  RTC::Orientation3D* _p = (RTC::Orientation3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Orientation3D& _s)
{
  RTC::Orientation3D* _p = new RTC::Orientation3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mOrientation3D,
               _0RL_RTC_mOrientation3D_marshal_fn,
               _0RL_RTC_mOrientation3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Orientation3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mOrientation3D,
               _0RL_RTC_mOrientation3D_marshal_fn,
               _0RL_RTC_mOrientation3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Orientation3D*& _sp)
{
  return _a >>= (const RTC::Orientation3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Orientation3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mOrientation3D,
                    _0RL_RTC_mOrientation3D_unmarshal_fn,
                    _0RL_RTC_mOrientation3D_marshal_fn,
                    _0RL_RTC_mOrientation3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Orientation3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPose3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Pose3D* _p = (RTC::Pose3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPose3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Pose3D* _p = new RTC::Pose3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPose3D_destructor_fn(void* _v)
{
  RTC::Pose3D* _p = (RTC::Pose3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Pose3D& _s)
{
  RTC::Pose3D* _p = new RTC::Pose3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mPose3D,
               _0RL_RTC_mPose3D_marshal_fn,
               _0RL_RTC_mPose3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Pose3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPose3D,
               _0RL_RTC_mPose3D_marshal_fn,
               _0RL_RTC_mPose3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Pose3D*& _sp)
{
  return _a >>= (const RTC::Pose3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Pose3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPose3D,
                    _0RL_RTC_mPose3D_unmarshal_fn,
                    _0RL_RTC_mPose3D_marshal_fn,
                    _0RL_RTC_mPose3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Pose3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mVelocity3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Velocity3D* _p = (RTC::Velocity3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mVelocity3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Velocity3D* _p = new RTC::Velocity3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mVelocity3D_destructor_fn(void* _v)
{
  RTC::Velocity3D* _p = (RTC::Velocity3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Velocity3D& _s)
{
  RTC::Velocity3D* _p = new RTC::Velocity3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mVelocity3D,
               _0RL_RTC_mVelocity3D_marshal_fn,
               _0RL_RTC_mVelocity3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Velocity3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mVelocity3D,
               _0RL_RTC_mVelocity3D_marshal_fn,
               _0RL_RTC_mVelocity3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Velocity3D*& _sp)
{
  return _a >>= (const RTC::Velocity3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Velocity3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mVelocity3D,
                    _0RL_RTC_mVelocity3D_unmarshal_fn,
                    _0RL_RTC_mVelocity3D_marshal_fn,
                    _0RL_RTC_mVelocity3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Velocity3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mAngularVelocity3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::AngularVelocity3D* _p = (RTC::AngularVelocity3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mAngularVelocity3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::AngularVelocity3D* _p = new RTC::AngularVelocity3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mAngularVelocity3D_destructor_fn(void* _v)
{
  RTC::AngularVelocity3D* _p = (RTC::AngularVelocity3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::AngularVelocity3D& _s)
{
  RTC::AngularVelocity3D* _p = new RTC::AngularVelocity3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mAngularVelocity3D,
               _0RL_RTC_mAngularVelocity3D_marshal_fn,
               _0RL_RTC_mAngularVelocity3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::AngularVelocity3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mAngularVelocity3D,
               _0RL_RTC_mAngularVelocity3D_marshal_fn,
               _0RL_RTC_mAngularVelocity3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::AngularVelocity3D*& _sp)
{
  return _a >>= (const RTC::AngularVelocity3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::AngularVelocity3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mAngularVelocity3D,
                    _0RL_RTC_mAngularVelocity3D_unmarshal_fn,
                    _0RL_RTC_mAngularVelocity3D_marshal_fn,
                    _0RL_RTC_mAngularVelocity3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::AngularVelocity3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mAcceleration3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Acceleration3D* _p = (RTC::Acceleration3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mAcceleration3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Acceleration3D* _p = new RTC::Acceleration3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mAcceleration3D_destructor_fn(void* _v)
{
  RTC::Acceleration3D* _p = (RTC::Acceleration3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Acceleration3D& _s)
{
  RTC::Acceleration3D* _p = new RTC::Acceleration3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mAcceleration3D,
               _0RL_RTC_mAcceleration3D_marshal_fn,
               _0RL_RTC_mAcceleration3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Acceleration3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mAcceleration3D,
               _0RL_RTC_mAcceleration3D_marshal_fn,
               _0RL_RTC_mAcceleration3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Acceleration3D*& _sp)
{
  return _a >>= (const RTC::Acceleration3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Acceleration3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mAcceleration3D,
                    _0RL_RTC_mAcceleration3D_unmarshal_fn,
                    _0RL_RTC_mAcceleration3D_marshal_fn,
                    _0RL_RTC_mAcceleration3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Acceleration3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mAngularAcceleration3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::AngularAcceleration3D* _p = (RTC::AngularAcceleration3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mAngularAcceleration3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::AngularAcceleration3D* _p = new RTC::AngularAcceleration3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mAngularAcceleration3D_destructor_fn(void* _v)
{
  RTC::AngularAcceleration3D* _p = (RTC::AngularAcceleration3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::AngularAcceleration3D& _s)
{
  RTC::AngularAcceleration3D* _p = new RTC::AngularAcceleration3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mAngularAcceleration3D,
               _0RL_RTC_mAngularAcceleration3D_marshal_fn,
               _0RL_RTC_mAngularAcceleration3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::AngularAcceleration3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mAngularAcceleration3D,
               _0RL_RTC_mAngularAcceleration3D_marshal_fn,
               _0RL_RTC_mAngularAcceleration3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::AngularAcceleration3D*& _sp)
{
  return _a >>= (const RTC::AngularAcceleration3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::AngularAcceleration3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mAngularAcceleration3D,
                    _0RL_RTC_mAngularAcceleration3D_unmarshal_fn,
                    _0RL_RTC_mAngularAcceleration3D_marshal_fn,
                    _0RL_RTC_mAngularAcceleration3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::AngularAcceleration3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mPoseVel3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::PoseVel3D* _p = (RTC::PoseVel3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mPoseVel3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::PoseVel3D* _p = new RTC::PoseVel3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mPoseVel3D_destructor_fn(void* _v)
{
  RTC::PoseVel3D* _p = (RTC::PoseVel3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::PoseVel3D& _s)
{
  RTC::PoseVel3D* _p = new RTC::PoseVel3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mPoseVel3D,
               _0RL_RTC_mPoseVel3D_marshal_fn,
               _0RL_RTC_mPoseVel3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::PoseVel3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mPoseVel3D,
               _0RL_RTC_mPoseVel3D_marshal_fn,
               _0RL_RTC_mPoseVel3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::PoseVel3D*& _sp)
{
  return _a >>= (const RTC::PoseVel3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::PoseVel3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mPoseVel3D,
                    _0RL_RTC_mPoseVel3D_unmarshal_fn,
                    _0RL_RTC_mPoseVel3D_marshal_fn,
                    _0RL_RTC_mPoseVel3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::PoseVel3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mSize3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Size3D* _p = (RTC::Size3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mSize3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Size3D* _p = new RTC::Size3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mSize3D_destructor_fn(void* _v)
{
  RTC::Size3D* _p = (RTC::Size3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Size3D& _s)
{
  RTC::Size3D* _p = new RTC::Size3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mSize3D,
               _0RL_RTC_mSize3D_marshal_fn,
               _0RL_RTC_mSize3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Size3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mSize3D,
               _0RL_RTC_mSize3D_marshal_fn,
               _0RL_RTC_mSize3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Size3D*& _sp)
{
  return _a >>= (const RTC::Size3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Size3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mSize3D,
                    _0RL_RTC_mSize3D_unmarshal_fn,
                    _0RL_RTC_mSize3D_marshal_fn,
                    _0RL_RTC_mSize3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Size3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mGeometry3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Geometry3D* _p = (RTC::Geometry3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mGeometry3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Geometry3D* _p = new RTC::Geometry3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mGeometry3D_destructor_fn(void* _v)
{
  RTC::Geometry3D* _p = (RTC::Geometry3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Geometry3D& _s)
{
  RTC::Geometry3D* _p = new RTC::Geometry3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mGeometry3D,
               _0RL_RTC_mGeometry3D_marshal_fn,
               _0RL_RTC_mGeometry3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Geometry3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mGeometry3D,
               _0RL_RTC_mGeometry3D_marshal_fn,
               _0RL_RTC_mGeometry3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Geometry3D*& _sp)
{
  return _a >>= (const RTC::Geometry3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Geometry3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mGeometry3D,
                    _0RL_RTC_mGeometry3D_unmarshal_fn,
                    _0RL_RTC_mGeometry3D_marshal_fn,
                    _0RL_RTC_mGeometry3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Geometry3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mCovariance3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Covariance3D* _p = (RTC::Covariance3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mCovariance3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Covariance3D* _p = new RTC::Covariance3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mCovariance3D_destructor_fn(void* _v)
{
  RTC::Covariance3D* _p = (RTC::Covariance3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Covariance3D& _s)
{
  RTC::Covariance3D* _p = new RTC::Covariance3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mCovariance3D,
               _0RL_RTC_mCovariance3D_marshal_fn,
               _0RL_RTC_mCovariance3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Covariance3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mCovariance3D,
               _0RL_RTC_mCovariance3D_marshal_fn,
               _0RL_RTC_mCovariance3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Covariance3D*& _sp)
{
  return _a >>= (const RTC::Covariance3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Covariance3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mCovariance3D,
                    _0RL_RTC_mCovariance3D_unmarshal_fn,
                    _0RL_RTC_mCovariance3D_marshal_fn,
                    _0RL_RTC_mCovariance3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::Covariance3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mSpeedHeading3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::SpeedHeading3D* _p = (RTC::SpeedHeading3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mSpeedHeading3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::SpeedHeading3D* _p = new RTC::SpeedHeading3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mSpeedHeading3D_destructor_fn(void* _v)
{
  RTC::SpeedHeading3D* _p = (RTC::SpeedHeading3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::SpeedHeading3D& _s)
{
  RTC::SpeedHeading3D* _p = new RTC::SpeedHeading3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mSpeedHeading3D,
               _0RL_RTC_mSpeedHeading3D_marshal_fn,
               _0RL_RTC_mSpeedHeading3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::SpeedHeading3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mSpeedHeading3D,
               _0RL_RTC_mSpeedHeading3D_marshal_fn,
               _0RL_RTC_mSpeedHeading3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::SpeedHeading3D*& _sp)
{
  return _a >>= (const RTC::SpeedHeading3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::SpeedHeading3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mSpeedHeading3D,
                    _0RL_RTC_mSpeedHeading3D_unmarshal_fn,
                    _0RL_RTC_mSpeedHeading3D_marshal_fn,
                    _0RL_RTC_mSpeedHeading3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::SpeedHeading3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mOAP_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::OAP* _p = (RTC::OAP*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mOAP_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::OAP* _p = new RTC::OAP;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mOAP_destructor_fn(void* _v)
{
  RTC::OAP* _p = (RTC::OAP*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::OAP& _s)
{
  RTC::OAP* _p = new RTC::OAP(_s);
  _a.PR_insert(_0RL_tc_RTC_mOAP,
               _0RL_RTC_mOAP_marshal_fn,
               _0RL_RTC_mOAP_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::OAP* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mOAP,
               _0RL_RTC_mOAP_marshal_fn,
               _0RL_RTC_mOAP_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::OAP*& _sp)
{
  return _a >>= (const RTC::OAP*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::OAP*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mOAP,
                    _0RL_RTC_mOAP_unmarshal_fn,
                    _0RL_RTC_mOAP_marshal_fn,
                    _0RL_RTC_mOAP_destructor_fn,
                    _v)) {
    _sp = (const RTC::OAP*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedRGBColour_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedRGBColour* _p = (RTC::TimedRGBColour*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedRGBColour_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedRGBColour* _p = new RTC::TimedRGBColour;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedRGBColour_destructor_fn(void* _v)
{
  RTC::TimedRGBColour* _p = (RTC::TimedRGBColour*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedRGBColour& _s)
{
  RTC::TimedRGBColour* _p = new RTC::TimedRGBColour(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedRGBColour,
               _0RL_RTC_mTimedRGBColour_marshal_fn,
               _0RL_RTC_mTimedRGBColour_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedRGBColour* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedRGBColour,
               _0RL_RTC_mTimedRGBColour_marshal_fn,
               _0RL_RTC_mTimedRGBColour_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedRGBColour*& _sp)
{
  return _a >>= (const RTC::TimedRGBColour*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedRGBColour*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedRGBColour,
                    _0RL_RTC_mTimedRGBColour_unmarshal_fn,
                    _0RL_RTC_mTimedRGBColour_marshal_fn,
                    _0RL_RTC_mTimedRGBColour_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedRGBColour*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedPoint2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedPoint2D* _p = (RTC::TimedPoint2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedPoint2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedPoint2D* _p = new RTC::TimedPoint2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedPoint2D_destructor_fn(void* _v)
{
  RTC::TimedPoint2D* _p = (RTC::TimedPoint2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedPoint2D& _s)
{
  RTC::TimedPoint2D* _p = new RTC::TimedPoint2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedPoint2D,
               _0RL_RTC_mTimedPoint2D_marshal_fn,
               _0RL_RTC_mTimedPoint2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedPoint2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedPoint2D,
               _0RL_RTC_mTimedPoint2D_marshal_fn,
               _0RL_RTC_mTimedPoint2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedPoint2D*& _sp)
{
  return _a >>= (const RTC::TimedPoint2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedPoint2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedPoint2D,
                    _0RL_RTC_mTimedPoint2D_unmarshal_fn,
                    _0RL_RTC_mTimedPoint2D_marshal_fn,
                    _0RL_RTC_mTimedPoint2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedPoint2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedVector2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedVector2D* _p = (RTC::TimedVector2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedVector2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedVector2D* _p = new RTC::TimedVector2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedVector2D_destructor_fn(void* _v)
{
  RTC::TimedVector2D* _p = (RTC::TimedVector2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedVector2D& _s)
{
  RTC::TimedVector2D* _p = new RTC::TimedVector2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedVector2D,
               _0RL_RTC_mTimedVector2D_marshal_fn,
               _0RL_RTC_mTimedVector2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedVector2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedVector2D,
               _0RL_RTC_mTimedVector2D_marshal_fn,
               _0RL_RTC_mTimedVector2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedVector2D*& _sp)
{
  return _a >>= (const RTC::TimedVector2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedVector2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedVector2D,
                    _0RL_RTC_mTimedVector2D_unmarshal_fn,
                    _0RL_RTC_mTimedVector2D_marshal_fn,
                    _0RL_RTC_mTimedVector2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedVector2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedPose2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedPose2D* _p = (RTC::TimedPose2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedPose2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedPose2D* _p = new RTC::TimedPose2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedPose2D_destructor_fn(void* _v)
{
  RTC::TimedPose2D* _p = (RTC::TimedPose2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedPose2D& _s)
{
  RTC::TimedPose2D* _p = new RTC::TimedPose2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedPose2D,
               _0RL_RTC_mTimedPose2D_marshal_fn,
               _0RL_RTC_mTimedPose2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedPose2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedPose2D,
               _0RL_RTC_mTimedPose2D_marshal_fn,
               _0RL_RTC_mTimedPose2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedPose2D*& _sp)
{
  return _a >>= (const RTC::TimedPose2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedPose2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedPose2D,
                    _0RL_RTC_mTimedPose2D_unmarshal_fn,
                    _0RL_RTC_mTimedPose2D_marshal_fn,
                    _0RL_RTC_mTimedPose2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedPose2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedVelocity2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedVelocity2D* _p = (RTC::TimedVelocity2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedVelocity2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedVelocity2D* _p = new RTC::TimedVelocity2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedVelocity2D_destructor_fn(void* _v)
{
  RTC::TimedVelocity2D* _p = (RTC::TimedVelocity2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedVelocity2D& _s)
{
  RTC::TimedVelocity2D* _p = new RTC::TimedVelocity2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedVelocity2D,
               _0RL_RTC_mTimedVelocity2D_marshal_fn,
               _0RL_RTC_mTimedVelocity2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedVelocity2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedVelocity2D,
               _0RL_RTC_mTimedVelocity2D_marshal_fn,
               _0RL_RTC_mTimedVelocity2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedVelocity2D*& _sp)
{
  return _a >>= (const RTC::TimedVelocity2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedVelocity2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedVelocity2D,
                    _0RL_RTC_mTimedVelocity2D_unmarshal_fn,
                    _0RL_RTC_mTimedVelocity2D_marshal_fn,
                    _0RL_RTC_mTimedVelocity2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedVelocity2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedAcceleration2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedAcceleration2D* _p = (RTC::TimedAcceleration2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedAcceleration2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedAcceleration2D* _p = new RTC::TimedAcceleration2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedAcceleration2D_destructor_fn(void* _v)
{
  RTC::TimedAcceleration2D* _p = (RTC::TimedAcceleration2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedAcceleration2D& _s)
{
  RTC::TimedAcceleration2D* _p = new RTC::TimedAcceleration2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedAcceleration2D,
               _0RL_RTC_mTimedAcceleration2D_marshal_fn,
               _0RL_RTC_mTimedAcceleration2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedAcceleration2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedAcceleration2D,
               _0RL_RTC_mTimedAcceleration2D_marshal_fn,
               _0RL_RTC_mTimedAcceleration2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedAcceleration2D*& _sp)
{
  return _a >>= (const RTC::TimedAcceleration2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedAcceleration2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedAcceleration2D,
                    _0RL_RTC_mTimedAcceleration2D_unmarshal_fn,
                    _0RL_RTC_mTimedAcceleration2D_marshal_fn,
                    _0RL_RTC_mTimedAcceleration2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedAcceleration2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedPoseVel2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedPoseVel2D* _p = (RTC::TimedPoseVel2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedPoseVel2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedPoseVel2D* _p = new RTC::TimedPoseVel2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedPoseVel2D_destructor_fn(void* _v)
{
  RTC::TimedPoseVel2D* _p = (RTC::TimedPoseVel2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedPoseVel2D& _s)
{
  RTC::TimedPoseVel2D* _p = new RTC::TimedPoseVel2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedPoseVel2D,
               _0RL_RTC_mTimedPoseVel2D_marshal_fn,
               _0RL_RTC_mTimedPoseVel2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedPoseVel2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedPoseVel2D,
               _0RL_RTC_mTimedPoseVel2D_marshal_fn,
               _0RL_RTC_mTimedPoseVel2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedPoseVel2D*& _sp)
{
  return _a >>= (const RTC::TimedPoseVel2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedPoseVel2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedPoseVel2D,
                    _0RL_RTC_mTimedPoseVel2D_unmarshal_fn,
                    _0RL_RTC_mTimedPoseVel2D_marshal_fn,
                    _0RL_RTC_mTimedPoseVel2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedPoseVel2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedSize2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedSize2D* _p = (RTC::TimedSize2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedSize2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedSize2D* _p = new RTC::TimedSize2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedSize2D_destructor_fn(void* _v)
{
  RTC::TimedSize2D* _p = (RTC::TimedSize2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedSize2D& _s)
{
  RTC::TimedSize2D* _p = new RTC::TimedSize2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedSize2D,
               _0RL_RTC_mTimedSize2D_marshal_fn,
               _0RL_RTC_mTimedSize2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedSize2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedSize2D,
               _0RL_RTC_mTimedSize2D_marshal_fn,
               _0RL_RTC_mTimedSize2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedSize2D*& _sp)
{
  return _a >>= (const RTC::TimedSize2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedSize2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedSize2D,
                    _0RL_RTC_mTimedSize2D_unmarshal_fn,
                    _0RL_RTC_mTimedSize2D_marshal_fn,
                    _0RL_RTC_mTimedSize2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedSize2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedGeometry2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedGeometry2D* _p = (RTC::TimedGeometry2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedGeometry2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedGeometry2D* _p = new RTC::TimedGeometry2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedGeometry2D_destructor_fn(void* _v)
{
  RTC::TimedGeometry2D* _p = (RTC::TimedGeometry2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedGeometry2D& _s)
{
  RTC::TimedGeometry2D* _p = new RTC::TimedGeometry2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedGeometry2D,
               _0RL_RTC_mTimedGeometry2D_marshal_fn,
               _0RL_RTC_mTimedGeometry2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedGeometry2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedGeometry2D,
               _0RL_RTC_mTimedGeometry2D_marshal_fn,
               _0RL_RTC_mTimedGeometry2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedGeometry2D*& _sp)
{
  return _a >>= (const RTC::TimedGeometry2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedGeometry2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedGeometry2D,
                    _0RL_RTC_mTimedGeometry2D_unmarshal_fn,
                    _0RL_RTC_mTimedGeometry2D_marshal_fn,
                    _0RL_RTC_mTimedGeometry2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedGeometry2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedCovariance2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedCovariance2D* _p = (RTC::TimedCovariance2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedCovariance2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedCovariance2D* _p = new RTC::TimedCovariance2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedCovariance2D_destructor_fn(void* _v)
{
  RTC::TimedCovariance2D* _p = (RTC::TimedCovariance2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedCovariance2D& _s)
{
  RTC::TimedCovariance2D* _p = new RTC::TimedCovariance2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedCovariance2D,
               _0RL_RTC_mTimedCovariance2D_marshal_fn,
               _0RL_RTC_mTimedCovariance2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedCovariance2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedCovariance2D,
               _0RL_RTC_mTimedCovariance2D_marshal_fn,
               _0RL_RTC_mTimedCovariance2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedCovariance2D*& _sp)
{
  return _a >>= (const RTC::TimedCovariance2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedCovariance2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedCovariance2D,
                    _0RL_RTC_mTimedCovariance2D_unmarshal_fn,
                    _0RL_RTC_mTimedCovariance2D_marshal_fn,
                    _0RL_RTC_mTimedCovariance2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedCovariance2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedPointCovariance2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedPointCovariance2D* _p = (RTC::TimedPointCovariance2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedPointCovariance2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedPointCovariance2D* _p = new RTC::TimedPointCovariance2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedPointCovariance2D_destructor_fn(void* _v)
{
  RTC::TimedPointCovariance2D* _p = (RTC::TimedPointCovariance2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedPointCovariance2D& _s)
{
  RTC::TimedPointCovariance2D* _p = new RTC::TimedPointCovariance2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedPointCovariance2D,
               _0RL_RTC_mTimedPointCovariance2D_marshal_fn,
               _0RL_RTC_mTimedPointCovariance2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedPointCovariance2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedPointCovariance2D,
               _0RL_RTC_mTimedPointCovariance2D_marshal_fn,
               _0RL_RTC_mTimedPointCovariance2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedPointCovariance2D*& _sp)
{
  return _a >>= (const RTC::TimedPointCovariance2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedPointCovariance2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedPointCovariance2D,
                    _0RL_RTC_mTimedPointCovariance2D_unmarshal_fn,
                    _0RL_RTC_mTimedPointCovariance2D_marshal_fn,
                    _0RL_RTC_mTimedPointCovariance2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedPointCovariance2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedCarlike_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedCarlike* _p = (RTC::TimedCarlike*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedCarlike_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedCarlike* _p = new RTC::TimedCarlike;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedCarlike_destructor_fn(void* _v)
{
  RTC::TimedCarlike* _p = (RTC::TimedCarlike*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedCarlike& _s)
{
  RTC::TimedCarlike* _p = new RTC::TimedCarlike(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedCarlike,
               _0RL_RTC_mTimedCarlike_marshal_fn,
               _0RL_RTC_mTimedCarlike_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedCarlike* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedCarlike,
               _0RL_RTC_mTimedCarlike_marshal_fn,
               _0RL_RTC_mTimedCarlike_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedCarlike*& _sp)
{
  return _a >>= (const RTC::TimedCarlike*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedCarlike*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedCarlike,
                    _0RL_RTC_mTimedCarlike_unmarshal_fn,
                    _0RL_RTC_mTimedCarlike_marshal_fn,
                    _0RL_RTC_mTimedCarlike_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedCarlike*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedSpeedHeading2D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedSpeedHeading2D* _p = (RTC::TimedSpeedHeading2D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedSpeedHeading2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedSpeedHeading2D* _p = new RTC::TimedSpeedHeading2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedSpeedHeading2D_destructor_fn(void* _v)
{
  RTC::TimedSpeedHeading2D* _p = (RTC::TimedSpeedHeading2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedSpeedHeading2D& _s)
{
  RTC::TimedSpeedHeading2D* _p = new RTC::TimedSpeedHeading2D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedSpeedHeading2D,
               _0RL_RTC_mTimedSpeedHeading2D_marshal_fn,
               _0RL_RTC_mTimedSpeedHeading2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedSpeedHeading2D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedSpeedHeading2D,
               _0RL_RTC_mTimedSpeedHeading2D_marshal_fn,
               _0RL_RTC_mTimedSpeedHeading2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedSpeedHeading2D*& _sp)
{
  return _a >>= (const RTC::TimedSpeedHeading2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedSpeedHeading2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedSpeedHeading2D,
                    _0RL_RTC_mTimedSpeedHeading2D_unmarshal_fn,
                    _0RL_RTC_mTimedSpeedHeading2D_marshal_fn,
                    _0RL_RTC_mTimedSpeedHeading2D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedSpeedHeading2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedPoint3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedPoint3D* _p = (RTC::TimedPoint3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedPoint3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedPoint3D* _p = new RTC::TimedPoint3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedPoint3D_destructor_fn(void* _v)
{
  RTC::TimedPoint3D* _p = (RTC::TimedPoint3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedPoint3D& _s)
{
  RTC::TimedPoint3D* _p = new RTC::TimedPoint3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedPoint3D,
               _0RL_RTC_mTimedPoint3D_marshal_fn,
               _0RL_RTC_mTimedPoint3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedPoint3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedPoint3D,
               _0RL_RTC_mTimedPoint3D_marshal_fn,
               _0RL_RTC_mTimedPoint3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedPoint3D*& _sp)
{
  return _a >>= (const RTC::TimedPoint3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedPoint3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedPoint3D,
                    _0RL_RTC_mTimedPoint3D_unmarshal_fn,
                    _0RL_RTC_mTimedPoint3D_marshal_fn,
                    _0RL_RTC_mTimedPoint3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedPoint3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedVector3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedVector3D* _p = (RTC::TimedVector3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedVector3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedVector3D* _p = new RTC::TimedVector3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedVector3D_destructor_fn(void* _v)
{
  RTC::TimedVector3D* _p = (RTC::TimedVector3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedVector3D& _s)
{
  RTC::TimedVector3D* _p = new RTC::TimedVector3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedVector3D,
               _0RL_RTC_mTimedVector3D_marshal_fn,
               _0RL_RTC_mTimedVector3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedVector3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedVector3D,
               _0RL_RTC_mTimedVector3D_marshal_fn,
               _0RL_RTC_mTimedVector3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedVector3D*& _sp)
{
  return _a >>= (const RTC::TimedVector3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedVector3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedVector3D,
                    _0RL_RTC_mTimedVector3D_unmarshal_fn,
                    _0RL_RTC_mTimedVector3D_marshal_fn,
                    _0RL_RTC_mTimedVector3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedVector3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedOrientation3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedOrientation3D* _p = (RTC::TimedOrientation3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedOrientation3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedOrientation3D* _p = new RTC::TimedOrientation3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedOrientation3D_destructor_fn(void* _v)
{
  RTC::TimedOrientation3D* _p = (RTC::TimedOrientation3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedOrientation3D& _s)
{
  RTC::TimedOrientation3D* _p = new RTC::TimedOrientation3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedOrientation3D,
               _0RL_RTC_mTimedOrientation3D_marshal_fn,
               _0RL_RTC_mTimedOrientation3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedOrientation3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedOrientation3D,
               _0RL_RTC_mTimedOrientation3D_marshal_fn,
               _0RL_RTC_mTimedOrientation3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedOrientation3D*& _sp)
{
  return _a >>= (const RTC::TimedOrientation3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedOrientation3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedOrientation3D,
                    _0RL_RTC_mTimedOrientation3D_unmarshal_fn,
                    _0RL_RTC_mTimedOrientation3D_marshal_fn,
                    _0RL_RTC_mTimedOrientation3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedOrientation3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedPose3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedPose3D* _p = (RTC::TimedPose3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedPose3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedPose3D* _p = new RTC::TimedPose3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedPose3D_destructor_fn(void* _v)
{
  RTC::TimedPose3D* _p = (RTC::TimedPose3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedPose3D& _s)
{
  RTC::TimedPose3D* _p = new RTC::TimedPose3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedPose3D,
               _0RL_RTC_mTimedPose3D_marshal_fn,
               _0RL_RTC_mTimedPose3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedPose3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedPose3D,
               _0RL_RTC_mTimedPose3D_marshal_fn,
               _0RL_RTC_mTimedPose3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedPose3D*& _sp)
{
  return _a >>= (const RTC::TimedPose3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedPose3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedPose3D,
                    _0RL_RTC_mTimedPose3D_unmarshal_fn,
                    _0RL_RTC_mTimedPose3D_marshal_fn,
                    _0RL_RTC_mTimedPose3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedPose3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedVelocity3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedVelocity3D* _p = (RTC::TimedVelocity3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedVelocity3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedVelocity3D* _p = new RTC::TimedVelocity3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedVelocity3D_destructor_fn(void* _v)
{
  RTC::TimedVelocity3D* _p = (RTC::TimedVelocity3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedVelocity3D& _s)
{
  RTC::TimedVelocity3D* _p = new RTC::TimedVelocity3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedVelocity3D,
               _0RL_RTC_mTimedVelocity3D_marshal_fn,
               _0RL_RTC_mTimedVelocity3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedVelocity3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedVelocity3D,
               _0RL_RTC_mTimedVelocity3D_marshal_fn,
               _0RL_RTC_mTimedVelocity3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedVelocity3D*& _sp)
{
  return _a >>= (const RTC::TimedVelocity3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedVelocity3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedVelocity3D,
                    _0RL_RTC_mTimedVelocity3D_unmarshal_fn,
                    _0RL_RTC_mTimedVelocity3D_marshal_fn,
                    _0RL_RTC_mTimedVelocity3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedVelocity3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedAngularVelocity3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedAngularVelocity3D* _p = (RTC::TimedAngularVelocity3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedAngularVelocity3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedAngularVelocity3D* _p = new RTC::TimedAngularVelocity3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedAngularVelocity3D_destructor_fn(void* _v)
{
  RTC::TimedAngularVelocity3D* _p = (RTC::TimedAngularVelocity3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedAngularVelocity3D& _s)
{
  RTC::TimedAngularVelocity3D* _p = new RTC::TimedAngularVelocity3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedAngularVelocity3D,
               _0RL_RTC_mTimedAngularVelocity3D_marshal_fn,
               _0RL_RTC_mTimedAngularVelocity3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedAngularVelocity3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedAngularVelocity3D,
               _0RL_RTC_mTimedAngularVelocity3D_marshal_fn,
               _0RL_RTC_mTimedAngularVelocity3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedAngularVelocity3D*& _sp)
{
  return _a >>= (const RTC::TimedAngularVelocity3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedAngularVelocity3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedAngularVelocity3D,
                    _0RL_RTC_mTimedAngularVelocity3D_unmarshal_fn,
                    _0RL_RTC_mTimedAngularVelocity3D_marshal_fn,
                    _0RL_RTC_mTimedAngularVelocity3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedAngularVelocity3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedAcceleration3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedAcceleration3D* _p = (RTC::TimedAcceleration3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedAcceleration3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedAcceleration3D* _p = new RTC::TimedAcceleration3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedAcceleration3D_destructor_fn(void* _v)
{
  RTC::TimedAcceleration3D* _p = (RTC::TimedAcceleration3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedAcceleration3D& _s)
{
  RTC::TimedAcceleration3D* _p = new RTC::TimedAcceleration3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedAcceleration3D,
               _0RL_RTC_mTimedAcceleration3D_marshal_fn,
               _0RL_RTC_mTimedAcceleration3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedAcceleration3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedAcceleration3D,
               _0RL_RTC_mTimedAcceleration3D_marshal_fn,
               _0RL_RTC_mTimedAcceleration3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedAcceleration3D*& _sp)
{
  return _a >>= (const RTC::TimedAcceleration3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedAcceleration3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedAcceleration3D,
                    _0RL_RTC_mTimedAcceleration3D_unmarshal_fn,
                    _0RL_RTC_mTimedAcceleration3D_marshal_fn,
                    _0RL_RTC_mTimedAcceleration3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedAcceleration3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedAngularAcceleration3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedAngularAcceleration3D* _p = (RTC::TimedAngularAcceleration3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedAngularAcceleration3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedAngularAcceleration3D* _p = new RTC::TimedAngularAcceleration3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedAngularAcceleration3D_destructor_fn(void* _v)
{
  RTC::TimedAngularAcceleration3D* _p = (RTC::TimedAngularAcceleration3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedAngularAcceleration3D& _s)
{
  RTC::TimedAngularAcceleration3D* _p = new RTC::TimedAngularAcceleration3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedAngularAcceleration3D,
               _0RL_RTC_mTimedAngularAcceleration3D_marshal_fn,
               _0RL_RTC_mTimedAngularAcceleration3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedAngularAcceleration3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedAngularAcceleration3D,
               _0RL_RTC_mTimedAngularAcceleration3D_marshal_fn,
               _0RL_RTC_mTimedAngularAcceleration3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedAngularAcceleration3D*& _sp)
{
  return _a >>= (const RTC::TimedAngularAcceleration3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedAngularAcceleration3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedAngularAcceleration3D,
                    _0RL_RTC_mTimedAngularAcceleration3D_unmarshal_fn,
                    _0RL_RTC_mTimedAngularAcceleration3D_marshal_fn,
                    _0RL_RTC_mTimedAngularAcceleration3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedAngularAcceleration3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedPoseVel3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedPoseVel3D* _p = (RTC::TimedPoseVel3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedPoseVel3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedPoseVel3D* _p = new RTC::TimedPoseVel3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedPoseVel3D_destructor_fn(void* _v)
{
  RTC::TimedPoseVel3D* _p = (RTC::TimedPoseVel3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedPoseVel3D& _s)
{
  RTC::TimedPoseVel3D* _p = new RTC::TimedPoseVel3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedPoseVel3D,
               _0RL_RTC_mTimedPoseVel3D_marshal_fn,
               _0RL_RTC_mTimedPoseVel3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedPoseVel3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedPoseVel3D,
               _0RL_RTC_mTimedPoseVel3D_marshal_fn,
               _0RL_RTC_mTimedPoseVel3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedPoseVel3D*& _sp)
{
  return _a >>= (const RTC::TimedPoseVel3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedPoseVel3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedPoseVel3D,
                    _0RL_RTC_mTimedPoseVel3D_unmarshal_fn,
                    _0RL_RTC_mTimedPoseVel3D_marshal_fn,
                    _0RL_RTC_mTimedPoseVel3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedPoseVel3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedSize3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedSize3D* _p = (RTC::TimedSize3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedSize3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedSize3D* _p = new RTC::TimedSize3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedSize3D_destructor_fn(void* _v)
{
  RTC::TimedSize3D* _p = (RTC::TimedSize3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedSize3D& _s)
{
  RTC::TimedSize3D* _p = new RTC::TimedSize3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedSize3D,
               _0RL_RTC_mTimedSize3D_marshal_fn,
               _0RL_RTC_mTimedSize3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedSize3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedSize3D,
               _0RL_RTC_mTimedSize3D_marshal_fn,
               _0RL_RTC_mTimedSize3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedSize3D*& _sp)
{
  return _a >>= (const RTC::TimedSize3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedSize3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedSize3D,
                    _0RL_RTC_mTimedSize3D_unmarshal_fn,
                    _0RL_RTC_mTimedSize3D_marshal_fn,
                    _0RL_RTC_mTimedSize3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedSize3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedGeometry3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedGeometry3D* _p = (RTC::TimedGeometry3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedGeometry3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedGeometry3D* _p = new RTC::TimedGeometry3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedGeometry3D_destructor_fn(void* _v)
{
  RTC::TimedGeometry3D* _p = (RTC::TimedGeometry3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedGeometry3D& _s)
{
  RTC::TimedGeometry3D* _p = new RTC::TimedGeometry3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedGeometry3D,
               _0RL_RTC_mTimedGeometry3D_marshal_fn,
               _0RL_RTC_mTimedGeometry3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedGeometry3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedGeometry3D,
               _0RL_RTC_mTimedGeometry3D_marshal_fn,
               _0RL_RTC_mTimedGeometry3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedGeometry3D*& _sp)
{
  return _a >>= (const RTC::TimedGeometry3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedGeometry3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedGeometry3D,
                    _0RL_RTC_mTimedGeometry3D_unmarshal_fn,
                    _0RL_RTC_mTimedGeometry3D_marshal_fn,
                    _0RL_RTC_mTimedGeometry3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedGeometry3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedCovariance3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedCovariance3D* _p = (RTC::TimedCovariance3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedCovariance3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedCovariance3D* _p = new RTC::TimedCovariance3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedCovariance3D_destructor_fn(void* _v)
{
  RTC::TimedCovariance3D* _p = (RTC::TimedCovariance3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedCovariance3D& _s)
{
  RTC::TimedCovariance3D* _p = new RTC::TimedCovariance3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedCovariance3D,
               _0RL_RTC_mTimedCovariance3D_marshal_fn,
               _0RL_RTC_mTimedCovariance3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedCovariance3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedCovariance3D,
               _0RL_RTC_mTimedCovariance3D_marshal_fn,
               _0RL_RTC_mTimedCovariance3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedCovariance3D*& _sp)
{
  return _a >>= (const RTC::TimedCovariance3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedCovariance3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedCovariance3D,
                    _0RL_RTC_mTimedCovariance3D_unmarshal_fn,
                    _0RL_RTC_mTimedCovariance3D_marshal_fn,
                    _0RL_RTC_mTimedCovariance3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedCovariance3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedSpeedHeading3D_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedSpeedHeading3D* _p = (RTC::TimedSpeedHeading3D*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedSpeedHeading3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedSpeedHeading3D* _p = new RTC::TimedSpeedHeading3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedSpeedHeading3D_destructor_fn(void* _v)
{
  RTC::TimedSpeedHeading3D* _p = (RTC::TimedSpeedHeading3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedSpeedHeading3D& _s)
{
  RTC::TimedSpeedHeading3D* _p = new RTC::TimedSpeedHeading3D(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedSpeedHeading3D,
               _0RL_RTC_mTimedSpeedHeading3D_marshal_fn,
               _0RL_RTC_mTimedSpeedHeading3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedSpeedHeading3D* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedSpeedHeading3D,
               _0RL_RTC_mTimedSpeedHeading3D_marshal_fn,
               _0RL_RTC_mTimedSpeedHeading3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedSpeedHeading3D*& _sp)
{
  return _a >>= (const RTC::TimedSpeedHeading3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedSpeedHeading3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedSpeedHeading3D,
                    _0RL_RTC_mTimedSpeedHeading3D_unmarshal_fn,
                    _0RL_RTC_mTimedSpeedHeading3D_marshal_fn,
                    _0RL_RTC_mTimedSpeedHeading3D_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedSpeedHeading3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedOAP_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedOAP* _p = (RTC::TimedOAP*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedOAP_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedOAP* _p = new RTC::TimedOAP;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedOAP_destructor_fn(void* _v)
{
  RTC::TimedOAP* _p = (RTC::TimedOAP*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedOAP& _s)
{
  RTC::TimedOAP* _p = new RTC::TimedOAP(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedOAP,
               _0RL_RTC_mTimedOAP_marshal_fn,
               _0RL_RTC_mTimedOAP_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedOAP* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedOAP,
               _0RL_RTC_mTimedOAP_marshal_fn,
               _0RL_RTC_mTimedOAP_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedOAP*& _sp)
{
  return _a >>= (const RTC::TimedOAP*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedOAP*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedOAP,
                    _0RL_RTC_mTimedOAP_unmarshal_fn,
                    _0RL_RTC_mTimedOAP_marshal_fn,
                    _0RL_RTC_mTimedOAP_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedOAP*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mQuaternion_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::Quaternion* _p = (RTC::Quaternion*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mQuaternion_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::Quaternion* _p = new RTC::Quaternion;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mQuaternion_destructor_fn(void* _v)
{
  RTC::Quaternion* _p = (RTC::Quaternion*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::Quaternion& _s)
{
  RTC::Quaternion* _p = new RTC::Quaternion(_s);
  _a.PR_insert(_0RL_tc_RTC_mQuaternion,
               _0RL_RTC_mQuaternion_marshal_fn,
               _0RL_RTC_mQuaternion_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::Quaternion* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mQuaternion,
               _0RL_RTC_mQuaternion_marshal_fn,
               _0RL_RTC_mQuaternion_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::Quaternion*& _sp)
{
  return _a >>= (const RTC::Quaternion*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::Quaternion*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mQuaternion,
                    _0RL_RTC_mQuaternion_unmarshal_fn,
                    _0RL_RTC_mQuaternion_marshal_fn,
                    _0RL_RTC_mQuaternion_destructor_fn,
                    _v)) {
    _sp = (const RTC::Quaternion*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_RTC_mTimedQuaternion_marshal_fn(cdrStream& _s, void* _v)
{
  RTC::TimedQuaternion* _p = (RTC::TimedQuaternion*)_v;
  *_p >>= _s;
}
static void _0RL_RTC_mTimedQuaternion_unmarshal_fn(cdrStream& _s, void*& _v)
{
  RTC::TimedQuaternion* _p = new RTC::TimedQuaternion;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_RTC_mTimedQuaternion_destructor_fn(void* _v)
{
  RTC::TimedQuaternion* _p = (RTC::TimedQuaternion*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const RTC::TimedQuaternion& _s)
{
  RTC::TimedQuaternion* _p = new RTC::TimedQuaternion(_s);
  _a.PR_insert(_0RL_tc_RTC_mTimedQuaternion,
               _0RL_RTC_mTimedQuaternion_marshal_fn,
               _0RL_RTC_mTimedQuaternion_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, RTC::TimedQuaternion* _sp)
{
  _a.PR_insert(_0RL_tc_RTC_mTimedQuaternion,
               _0RL_RTC_mTimedQuaternion_marshal_fn,
               _0RL_RTC_mTimedQuaternion_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, RTC::TimedQuaternion*& _sp)
{
  return _a >>= (const RTC::TimedQuaternion*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const RTC::TimedQuaternion*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_RTC_mTimedQuaternion,
                    _0RL_RTC_mTimedQuaternion_unmarshal_fn,
                    _0RL_RTC_mTimedQuaternion_marshal_fn,
                    _0RL_RTC_mTimedQuaternion_destructor_fn,
                    _v)) {
    _sp = (const RTC::TimedQuaternion*)_v;
    return 1;
  }
  return 0;
}

